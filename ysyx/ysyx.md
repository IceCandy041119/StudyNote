在ftrace下的蓝框题：  
不匹配的函数调用：可以看到在第一次f0后所有被call标记的位置函数调用后都是一个复合表达式，像f1f0这种，基本不需要什么返回地址，直接回到上次记录x1的所在地就行，因为那里还有表达式等着被处理，可以说是被编译器优化了——尾调用。  
冗余的符号表：符号表用于在汇编和链接阶段来生成一个可执行文件，可执行文件保留的意义用于调试吧？


#### 理解mainargs

请你通过RTFSC理解这个参数是如何从`make`命令中传递到`hello`程序中的, `$ISA-nemu`和`native`采用了不同的传递方法, 都值得你去了解一下.
native是通过getenv函数获取环境变量来做到得到mainargs的
nemu则是在bin文件下插入


>[!q] native和klib
>`native`的IOE是基于SDL库实现的, 这些库很有可能会调用glibc的库函数, 例如`malloc()`和`free()`. 但我们自己实现的klib通常不能完美地符合glibc的标准, 因此直觉上看, 如果定义了`__NATIVE_USE_KLIB__`, 很可能会导致SDL库产生不正确的行为.
不过你会发现, 即使定义了`__NATIVE_USE_KLIB__`, 也可以正确地在`native`上执行IOE相关的功能. 实际上, 我们使用了一个小技巧, 使得在定义了`__NATIVE_USE_KLIB__`的情况下, 避免SDL库调用klib中的函数, 而是调用glibc中的相应函数. 如果屏蔽这个小技巧, 在定义`__NATIVE_USE_KLIB__`的情况下, `native`将无法正确运行依赖IOE的程序. 你知道这个小技巧是如何做到的吗?

应该是单独分开编译做到的，前面通过CFLAGS和CXXFLAGS把这些该klib链接的东西弄了，然后单独链接SDL库


>[!note] 异常号的保存
>x86通过软件来保存异常号, 没有类似cause的寄存器. mips32和riscv32也可以这样吗? 为什么?
>
这是一个关于架构设计和中断/异常处理机制的优秀问题。
简而言之：
>- **x86：** 确实依赖**软件机制**（如堆栈）来处理和查找异常向量，通常没有一个硬件专用的寄存器来保存“异常号”或“原因码”。   
>- **MIPS32 和 RISC-V 32：** **不可以**像 x86 那样完全通过软件查找异常号。它们拥有**硬件专用寄存器**来保存异常号或原因，这是它们架构设计的一部分。
---
> MIPS32 和 RISC-V 的异常处理机制

|**架构**|**异常原因寄存器**|**主要作用**|**为什么不能纯软件实现**|
|---|---|---|---|
|**MIPS32**|**`Cause` 寄存器**|硬件将异常的原因代码（Exception Code, ExcCode）写入该寄存器。|MIPS 采用**单个统一的异常入口点**（或少数几个），处理器需要通过读取 `Cause` 寄存器来分派（dispatch）到正确的异常处理程序。|
|**RISC-V**|**`mcause` / `scause` / `ucause` 寄存器**|硬件将中断或异常的原因代码写入这个 Machine (M) / Supervisor (S) / User (U) 模式的控制状态寄存器 (CSR)。|RISC-V 同样采用**统一的异常入口点**（`mtvec`/`stvec`），必须依赖 `mcause` 来区分是中断还是异常，以及具体的类型。|

### 🧠 为什么 x86 可以而 MIPS/RISC-V 不可以？

这主要归结于三种架构在处理异常**入口点（Entry Point）**的设计哲学上的根本差异：

#### 1. x86 的设计：向量化中断表 (Vectored Interrupt Table)

- **多个入口点：** x86 架构使用一个称为 **中断描述符表（IDT, Interrupt Descriptor Table）** 的结构。IDT 存储了每个异常号（0-255）对应的**处理程序地址**。
    
- **硬件分派：** 当异常发生时，x86 硬件（或微码）会**直接使用异常号作为索引**，查找 IDT，然后跳转到特定的处理程序地址。
    
- **结果：** 因为硬件已经将程序流导向了**特定异常的专用处理函数**，软件（处理函数）本身就知道自己是哪个异常被触发了，因此不需要一个额外的 `Cause` 寄存器来保存这个“索引号”。如果需要，软件可以在跳转前将这个异常号压栈。
    

#### 2. MIPS/RISC-V 的设计：统一入口点 (Single Entry Point)

- **统一入口点：** MIPS 和 RISC-V（默认配置）通常只有一个（或极少数几个）固定的**异常处理入口地址**（在 RISC-V 中由 `mtvec` 寄存器指定）。
    
- **软件分派：** 当异常发生时，硬件只负责跳转到这个统一的入口地址。
    
- **结果：** 位于统一入口点的**软件代码**（通常是汇编编写的异常总处理程序）并不知道是哪个具体的异常导致了跳转。它必须执行以下步骤：
    
    1. **读取**专用的硬件寄存器（`Cause`/`mcause`）。
        
    2. **根据**读取到的原因代码，在软件中实现一个查找表（dispatch table）。
        
    3. **跳转**到正确的、针对该异常类型的处理程序。
        

**总结原因：**

MIPS32 和 RISC-V 必须依赖 `Cause`/`mcause` 寄存器，因为它们采用了 **“统一异常入口 + 软件分派”** 的模型。如果没有这个寄存器，统一入口点的软件就无法得知异常类型，从而无法正确分派给相应的处理函数。

相比之下，x86 采用 **“向量化入口 + 硬件分派”** 的模型，硬件已经帮软件完成了查找和跳转，故不需要专门的 `Cause` 寄存器。

### CSR相关

标准RISC-V指令集架构（ISA）为最多4,096个CSR（控制状态寄存器）预留了12位编码空间（csr\[11:0\]）。按照惯例，CSR地址的高4位（csr\[11:8\]）用于根据特权级别编码CSR的读写访问性，如表3所示。最高两位（csr\[11:10\]）指示寄存器是可读写（00、01或10）还是只读（11）。接下来的两位（csr\[9:8\]）编码可以访问CSR的最低特权级别。

访问不存在的CSR的指令被保留。尝试在没有适当权限级别的情况下访问CSR将引发非法指令异常，或者如第21.6.1节所述，引发虚拟指令异常。尝试写入只读寄存器将引发非法指令异常。可读/写寄存器也可能包含一些只读位，在这种情况下，写入只读位将被忽略。

一些整读写字段保留供将来使用。软件应忽略从这些字段读取的值，并在向同一寄存器的其他字段写入值时保留这些字段中的值。为了向前兼容，不提供这些字段的实现必须使它们为只读零。这些字段在寄存器描述中标为WPRI。