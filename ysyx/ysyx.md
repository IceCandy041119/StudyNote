在ftrace下的蓝框题：  
不匹配的函数调用：可以看到在第一次f0后所有被call标记的位置函数调用后都是一个复合表达式，像f1f0这种，基本不需要什么返回地址，直接回到上次记录x1的所在地就行，因为那里还有表达式等着被处理，可以说是被编译器优化了——尾调用。  
冗余的符号表：符号表用于在汇编和链接阶段来生成一个可执行文件，可执行文件保留的意义用于调试吧？


#### 理解mainargs

请你通过RTFSC理解这个参数是如何从`make`命令中传递到`hello`程序中的, `$ISA-nemu`和`native`采用了不同的传递方法, 都值得你去了解一下.
native是通过getenv函数获取环境变量来做到得到mainargs的
nemu则是在bin文件下插入


>[!q] native和klib
>`native`的IOE是基于SDL库实现的, 这些库很有可能会调用glibc的库函数, 例如`malloc()`和`free()`. 但我们自己实现的klib通常不能完美地符合glibc的标准, 因此直觉上看, 如果定义了`__NATIVE_USE_KLIB__`, 很可能会导致SDL库产生不正确的行为.
不过你会发现, 即使定义了`__NATIVE_USE_KLIB__`, 也可以正确地在`native`上执行IOE相关的功能. 实际上, 我们使用了一个小技巧, 使得在定义了`__NATIVE_USE_KLIB__`的情况下, 避免SDL库调用klib中的函数, 而是调用glibc中的相应函数. 如果屏蔽这个小技巧, 在定义`__NATIVE_USE_KLIB__`的情况下, `native`将无法正确运行依赖IOE的程序. 你知道这个小技巧是如何做到的吗?

应该是单独分开编译做到的，前面通过CFLAGS和CXXFLAGS把这些该klib链接的东西弄了，然后单独链接SDL库
