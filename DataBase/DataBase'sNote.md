
# Chapter 1 Introduction

## 一、数据库系统概述

### 1、基本概念

- 数据（Data）
- 数据库（DataBase）
- 数据库管理系统（DBMS）
	- 数据定义、组织存储和管理、数据操纵、事务管理和运行管理、建立与维护
- 数据库系统（DBS）
	- 数据库系统是由**数据库、数据库管理系统、应用程序和数据库管理员**组成
	- 一般把数据库系统称为数据库

### 2、数据库的特点

- 数据结构化
- 数据的共享性高、冗余性低且易扩充
- 数据独立性高
- 数据由数据库管理系统统一管理和控制
	- 安全性：防止不合法使用造成的泄密和破坏
	- 完整性：数据的正确性，有效性和相容性
	- 并发控制：多用户同时对数据进行处理
	- 数据库恢复

## 二、数据模型

根据模型的应用的不同目的，可以将模型分为两大类：
- 概念模型
	- 目的和特点
		- 目的：独立于计算机系统和具体的DBMS，真实、完整地描述现实世界中的实体、属性和它们之间的联系
		- 抽象程度：最高，反映的是用户对数据和信息的理解和看法
		- 应用阶段：需求分析和概念设计阶段
		- 核心特点：易于理解、直观、面向现实世界
	- 典型列子
		- 实体-关系模型（E-R）模型
			- 实体（Entity）：现实世界中可区分的事物
			- 属性（Attribute）：实体的特性
			- 码（Key）：实体型中能够**唯一**标识一个实体的最小属性集合
				- 类型：
					- 超码（Superkey）：能够唯一标识实体的属性集
					- 候选码（Candidate Key）：能够唯一标识实体的最小属性集，一个实体型可能有一个或多个候选码
					- 主码（Primary Key）：被设计者从候选码中选定出来，作为实体型的唯一标识的码
			- 实体型（Entity Type）：具有相同的一组实体的抽象，它是对一类事物的定义
			- 实体集（Entity Set）：同一实体型的所有实体在某一时刻的集合
			- 联系（Relationship）：实体之间的关联
- 逻辑模型和物理模型
	- 目的与特点
		- 目的：描述数据在**计算机内存存储介质上的组织方式**，包括数据的存储格式、存取路径和存储结构
		- 抽象程度：最低。它与具体的DBMS的实现细节密切相关
		- 应用阶段：物理设计阶段
		- 核心特点：关注如何高效地存取数据，与性能优化直接相关
	- 典型例子
		- 存储记录格式：如何将一个元组（行）的数据存储在磁盘块中过
		- 索引结构：数据的快速存取机制，如B+树索引、哈希索引
		- 数据压缩和加密：提高存储效率和安全性

> [!note] 实体与实体型
> 实体型是**设计和建模**的概念。关注的是共性。相当于对象编程语言中的类。而实体则是**数据和实例**的概念。关注的是个体。相当于对象编程语言中的实例。

>[!note] 码（Key）
>码的核心目的，是为了在数据库中**唯一地标识**每一条记录（元组）。
>核心功能：保证记录的唯一性和不重复性
>- 唯一标识：码所包含的属性值的组合，对于关系中的任何两个不同的记录，它们的码值绝不可能相同
>- 保证不重复：如果使用码作为查询条件，要么找到一个唯一的记录，要么找不到任何记录。这直接保证了数据库中不会出现完全相同或在码值上重复的记录
>	- 超码强调：只要能保证唯一性，就是超码
>	- 候选码：在此基础上增加了一个条件——实现唯一性的属性集必须是最小的
>	- 主码：从候选码中选出来作为关系的唯一标识

### 1、数据模型的组成要素

通常用**数据结构、数据操作和数据完整性约束条件**三部分组成
- 数据结构：描述数据库的组成对象和对象之间的联系
- 数据操作：对数据库中各种对象实例允许执行操作的集合、查询、更新
- 数据的完整性约束条件：是给定的数据模型及其联系所具有的制约和依存规则

### 2、逻辑数据模型

- 层次模型
- 网状模型
- 关系模型
- 面向对象模型
- 对象关系数据模型
- 半结构化模型

## 三、数据库系统结构

### 1、三级模式结构

**型**和**值**的概念：
- 型（type）：对某一类数据的**结果和属性的说明**
- 值（value）：是型的实例

三级模型的结构：
- 模式
	- 是全体数据的逻辑结构和特征的描述
	- 是数据库模型结构的中间层
- 外模式（子模式、用户模式） 逻辑独立性
	- 是用户能够看到和使用的局部数据的逻辑结构和特征的描述，是用户的数据视图，是与某一应用有关的数据的逻辑表示
	- 介于模式与应用之间
	- 与模式的关系是多对一
	- 与应用的关系是一对多
	- 用途
		- 保证数据库安全性的一个有力措施
		- 每个用户只能看见和访问所对应的外模式中的数据
- 内模式 物理独立性
	- 是数据物理结构和存储方式的描述
	- 是数据在数据库内部的表示方式
	- 一个数据库只有一个内模式

![[Pasted image 20251028195647.png]]
### 2、二级映像功能与数据独立性

- 外模式/模式映像
	- 模式：数据的全局逻辑结构
	- 外模式：数据的局部逻辑结构
	- 当模式改变时，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变，因为应用程序是依据外模式编写的，所以也不用修改，实现了逻辑独立性
- 模式/内模式映像
	- 数据库只有一个模式、一个内模式
	- 定义了数据全局逻辑结构与存储结构之间的对应关系
	- 当数据库的存储结构改变时，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序不必改变，保证了物理独立性

## 四、数据库系统的组成

- 硬件平台及数据库
- 软件
- 人员
	- 数据库管理员
	- 系统分析员
	- 应用程序员
	- 用户
![[Pasted image 20251028201006.png]]

# Chapter 2 Relational DataBase

关系模型有**关系数据结构、关系操作集合和关系完整性**组成

## 一、关系

### 1、关系

- **域（Domain）**
	- **定义：** 一组具有相同数据类型的值的集合。域是属性的取值范围
	- **特性：** 域是原子值的集合，域中的元素不可再分
	- **示例：** 整数域、字符串域、日期域...
- **笛卡尔积（Cartesian Product）**
	- **定义：** 给定$n$个域$D_1,D_2,\ldots,D_n$，它们的笛卡尔积$D_1 \times D_2 \times \cdots \times D_n$是所有可能元组$(d_1,d_2,\ldots,d_n)$的集合，其中$d_i \in D_i$
	- **特性：**
		- 不满足交换律：$A \times B \neq B \times A$（因为元组中的分量是有序的）
		- 基数：如果$|{D_i}|$是域$D_i$中元素的个数，则笛卡尔积的元素个数是$|D_1| \times |D_2| \times \cdots \times |D_n|$
- **关系（Relation）**
	- **定义：** 关系是域的笛卡尔积的子集，在数据库中，关系就是一张二维表
	- **分量是原子值：** 关系中的每个元素（即属性值）必须是**原子值（Atomic Value）**，即不可再分。这是关系模型遵循1NF（第一范式）的基本要求
	- **关系的基本特性：**
		- 列是同质的：表格中的每一列的分量都来自同一个域，意味着这一列中的所有值都必须符合同一个数据类型和语义约束。如都是字符串类型，或者数值类型。名字列不能写学号的值，除非你的名字改成学号
		- 列的顺序是无所谓的：关系中属性的逻辑顺序不影响关系的定义
		- 行的顺序是无所谓的：关系中元组的逻辑顺序不影响关系的定义
		- 不允许存在重复的行：关系中不能有完全相同的两个元组，这是由码的唯一性特性所隐含的
- **关系模式（Relation Schema**）
	- **定义：** 对关系的描述，即关系的结构。通常表示为$R(A_1, A_2, \ldots ,A_n)$,其中$R$是关系名，$A_i$ 是属性名
	- **与关系的区别：** 关系模式是静态的、稳定的定义，关系是动态的，随时间变化的实例数据
- **候选码**：
	- **定义：** 能够唯一标识元组的**最小属性集合**。即去掉集合中的任何一个属性，都无法保证唯一标识元组
	- **特性：** **不能存在相同的两个值**（即码值不能重复）
- **主码**：
	- **定义：** 从一个关系的所有候选码中，被**数据库设计者选定**作为该关系唯一标识的码
	- **主码与 NULL：** 主码的任何分量都**不能取空值** (NULL)
- **主属性 (Primary Attribute)：** 包含在**任何一个**候选码中的属性
- **非主属性 (Non-Primary Attribute)：** 不包含在**任何一个**候选码中的属性

三种关系表
- **基本关系表 (Base Table)**
	- **定义：** **实际存储**在数据库中，**独立存在**的关系表
	- **特性：** 基本表的数据是**物理存储**的，对它的操作（增、删、改）会直接影响数据库中的实际数据
- **查询表 (Query Result Table)**
	- **定义：** 执行 SQL 或关系代数等查询操作后**临时生成**的结果集
	- **特性：** 它是**瞬时**的，通常不会永久存储在数据库中，只存在于查询执行期间
- **视图表 (View Table)**
	- **定义：** 一种**虚拟的表**，其数据并不实际存储，而是**导出**自一个或多个基本关系表
	- **特性：** 视图是**基本表的查询定义**，每次访问视图时，DBMS 都会重新执行视图定义中对应的查询语句来获取数据

>[!note] 分量是原子值的意思
>1. 分量 (Component)
>在数据库上下文中，**分量**通常指关系（表）中**元组（行）** 在某一**属性（列）** 上的取值。简单来说，它就是表格中的**每一个单元格**里的数据。
>2. 原子值 (Atomic Value)
>**原子值**意味着这个数据单位是不可再分割的、最小的、有意义的数据项。
>- **是原子值（正确）：**  
>    - 一个整数 `25`
 >   - 一个字符串 `"张三"`
>    - 一个日期 `"2025-10-28"`    
>- **不是原子值（非原子值 / 可分值）：**  
>    - **一个列表或集合：** 例如，在一个单元格中存储 `{C001, C002, C003}`（一个学生选修了多门课程）。
 >   - **一个复合结构：** 例如，在一个单元格中存储 `"北京市海淀区"`（包含了省份、城市、区县等多个信息）。
>3. 为什么必须是原子值？
>这是关系模型满足**第一范式（1NF）** 的要求
>- **简化操作：** 如果一个分量不是原子值，那么 DBMS 无法直接对这个分量内的子项进行操作和查询。例如，如果地址是复合的，查询“海淀区”就需要特殊的字符串解析，而不是简单的等值比较。  
>- **保证统一性：** 确保所有的数据都是结构化的、同质的，使关系代数和 SQL 等标准查询语言能够有效工作。

### 2、关系模型
关系模型可以形式化地表示为：
$$R(U,D,DOM,F)$$
- R：关系名
- U：组成该关系的属性名集合
- D：U中属性名所来自的域
- DOM：属性向域的映像集合
- F：属性间数据的依赖关系的集合

## 二、关系操作

常用的关系操作：
- 查询操作：
	- 选择(基本操作)
	- 投影(基本操作)
	- 连接
	- 除
	- 并(基本操作)
	- 差(基本操作)
	- 交
	- 笛卡尔积(基本操作)
- 数据更新：
	- 插入
	- 删除
	- 修改
关系代数语言
- 用对关系的运算来表达查询的要求
- 代表：ISBL
关系演算语言
- 元组关系演算语言
	- 谓词变元的基本对象是元组变量
	- 代表：APLHA，QUEL
- 域关系演算语言
	- 谓词变元的基本对象是域变量
	- 代表：QBE
- 具有关系代数和关系演算双重特点的语言
	- 代表：SQL

## 三、关系完整性

三类完整性约束
1. 实体完整性
	- 主属性不能取空值
	- 关系模型中以**主码**作为唯一性标识
2. 参照完整性
	- 定义外码与主码之间的引用规则
	- 外码就是引用别人关系的主码，例如：选修表中的学号就是引用了学生表的主码学号，并非是选修表自己的属性。在这个例子中，选修表就是参照关系，学生表就是被参照关系
	![[Pasted image 20251028212142.png]]
	- 外码的值
		- 或者取空值（F的每个属性值均为空值）
		- 或者等于S中某个元组的主码值
3. 用户定义完整性
	- 针对某些关系数据库的约束条件，反映某具体应用所涉及的数据必须满足的语义要求
	- 例如：学生表中的名字不能为空值，这就是一种额外的约束

## 四、关系代数

运算符由两种
- 集合运算符（传统）
- 专门的关系运算符
![[Pasted image 20251028212801.png]]

传统的运算从关系的“水平”（行）角度进行
专门的运算涉及行与列
- 行：$t \in R$表示t是R的一个元组
- 列：
	![[Pasted image 20251028213703.png]]

### 1、传统运算

#### 并

![[Pasted image 20251028213010.png]]![[Pasted image 20251028213018.png]]

#### 差

![[Pasted image 20251028213057.png]]

#### 交

![[Pasted image 20251028213120.png]]

#### 笛卡尔积

![[Pasted image 20251028213134.png]]
![[Pasted image 20251028213140.png]]

### 2、专门的运算

#### 拼接

![[Pasted image 20251028214007.png]]

##### 选择selection （给定列条件进行筛选）

又称为限制

![[Pasted image 20251028214204.png]]
![[Pasted image 20251028214227.png]]

##### 投影projection （选择列组成新的关系）

选择若干属性列组成新的关系

![[Pasted image 20251028214340.png]]
![[Pasted image 20251028214350.png]]

##### 连接join （加限制的笛卡尔积运算）

在两个关系的笛卡尔积中选取属性间满足一定条件的元组

![[Pasted image 20251028215409.png]]

- 等值连接
	- 两个列相等就连接，但是不删除重复列
	![[Pasted image 20251028215512.png]]
	![[Pasted image 20251028215631.png]]
- 自然连接
	- 删除两个表中的重复列
	![[Pasted image 20251028215607.png]]
	![[Pasted image 20251028215615.png]]

在连接过程中，有些元组可能被舍弃  
将悬浮元组保存在结果中，其他属性上填空值，就是外连接  
只保留左边的就是左连接  
只保留右边就是右连接  

![[Pasted image 20251028220415.png]]
综合例子：
![[Pasted image 20251028220426.png]]

##### 除division  

- 核心目的：解决“所有”的查询
	- 除法运算用于回答这类问题：
		- **“找出关系 R 中与关系 S 中的**所有**元组都相关的元组。”**
- 定义与运算
	- 假设有两个关系 R 和 S：
		- R 的属性集为 A (例如：(X,Y))
		- S 的属性集为 B (例如：(Y))
		- 要求 B⊆A (即 S 的属性集必须是 R 的属性集的子集)。
	- **关系 R 除以关系 S (R÷S) 得到的结果 T 具有以下特性：**
		1. **属性集：** 结果 T 的属性集是 R 中去除 S 中属性后剩下的属性集。即 T=A−B (例如：(X))。
		2. **元组：** T 中的元组 t 满足：
		    - 对于 t 在 R 中，与 S 中**所有的**元组 s 进行组合（形成一个 R 的元组），这个组合元组都在 R 中。
- 典型应用示例
	- 假设在学生选课数据库中，我们有以下两个关系：
		1. **SC (选课关系)：** {StuID​,CourseID​} (表示哪个学生选了哪门课)
		2. **C1​ (课程集合)：** {CourseID​} (表示某一组特定的课程，比如 {’C1’,’C2’})。
	- **查询问题：** 找出**选修了集合 C1​ 中所有课程**的**学生 StuID**。
	- **关系代数表达式：** SC÷C1​
	- **结果解释：**
		- 如果 **学生 A** 选了 ’C1’ 和 ’C2’，那么 A 的 StuID 会出现在结果中。
		- 如果 **学生 B** 只选了 ’C1’，那么 B 的 StuID **不会**出现在结果中。
- 运算的等价表示（用基本运算表示除法）
	- 除法运算可以用关系代数中的**基本运算**（投影 π、笛卡尔积 ×、差集 −）来表示。这证明了除法运算虽然复杂，但它并不是一个基本运算。
	- $R÷S=πA−B​(R)−πA−B​((πA−B​(R)×S)−R)$
	- 简单解释这个等式：
		1. πA−B​(R): 找出所有可能的学生 (StuID)。
		2. (πA−B​(R)×S): 得到一个“**所有学生**”与“**所有目标课程**”的**完全组合**。
		3. (πA−B​(R)×S)−R: 找出**理论上应该选**（在笛卡尔积中），但**实际上没有选**（不在 R 中）的元组。
		4. πA−B​(…): 投影出那些**存在漏选课程**的学生 (StuID)。
		5. πA−B​(R)−πA−B​(…): 从所有学生中，**减去**那些存在漏选的学生，剩下的就是**选了所有目标课程的学生**。

![[Pasted image 20251028221302.png]]
![[Pasted image 20251028221313.png]]
![[Pasted image 20251028223411.png]]
![[Pasted image 20251028223618.png]]

# Chapter 3 SQL

## 一、概述  

SQL是**结构化查询语言**，是关系数据库的标准语言

| SQL功能 |          动词          |
| :---: | :------------------: |
| 数据查询  |        SELECT        |
| 数据定义  |  CREATE，DROP，ALTER   |
| 数据操纵  | INSERT，UPDATE，DELETE |
| 数据控制  |     GRANT，REVOKE     |
![[Pasted image 20251029095446.png]]

## 二、数据定义

一个数据库->多个模式->一个模式有多个表、索引、视图

### 模式

- 创建：![[Pasted image 20251029095853.png]]
-  删除：![[Pasted image 20251029095936.png]]
	- CASCADE：把关系全部删除
	- RESTRICT：如果下面有对象就不给删除

### 表  

- 创建：![[Pasted image 20251029100153.png]]
	- [表级完整性约束](#三、关系完整性)：用于确保数据库中数据**准确性**和**一致性**：
		1. 实体完整性（Entity Integrity）
			- 实体完整性是关系模型的基本要求之一，关注如何唯一标识表中的记录
			- 约束名：**主键约束**
			- 关键字：
				- **PRIMARY KEY**
					- 作用：
						- 唯一性：约束列的值不能重复
						- 非空性：约束列的值不能为NULL
		2. 参照完整性（Referential Intergrity）
			- 参照完整性关注表与表之间的关系，确保表之间的引用是有效的
			- 约束名：**外键约束**
			- 关键字：
				- **FOREIGN KEY**
					- 作用：
						- 约束列的值必须是被参照表主键列中已存在的值，或者为NULL
				- **REFERENCES**
					- 作用：
						- 用于指定被参照的表和列
		3. 用户定义完整性（User-Defined Intergrity）
			- 用户可以根据具体的业务需求，对数据施加额外的约束
				- 约束名：
					- **唯一约束**
						- 关键字：**UNIQUE**
						- 作用：约束列的值不能重复，但可以接受NULL值
					- **非空约束**
						- 关键字：**NOT NULL**
						- 作用：约束列的值**必须**有数据，不能接受NULL值
					- **检查约束**
						- 关键字：**CHECK** 
						- 作用：约束列的值必须满足指定的条件表达式
					- **默认值**
						- 关键字：**DEFAULT**
						- 作用：在插入新记录时，如果未指定该列的值，则自动使用此默认值
	- 数据类型
		- 定义表的属性需要指明其**数据类型及长度**
		- 选用那种数据类型要先明确数据的取值范围和要做的运算
		- ![[Pasted image 20251029100416.png]]
- 修改：![[Pasted image 20251029100543.png]]
- 删除：![[Pasted image 20251029102828.png]]

### 索引  

![[Screenshot 2025-10-29 at 11.27.56.png]]

默认是**升序**的ASE，**降序**为DESC

- 建立索引：![[Pasted image 20251029103238.png]]
	- 局促（聚簇）索引：是一种特殊的索引，决定了表中数据行在磁盘上的物理存储顺序，会在后面介绍
- 删除索引：![[Pasted image 20251029103341.png]]

### 数据查询  

#### 1、单表查询

就是选择表中的若干列，进行投影运算
![[Pasted image 20251029103458.png]]
查询全部列
$$ SELECT * FROM Student $$
查询经过计算的值
![[Pasted image 20251029103710.png]]
>[!tip] 关于别名
>可以通过在列名后加空格和别名，来更改查询结果的列名，更形式化的是加个AS，但大多数的数据库，AS是可以省略。通过别名，你还可以在结果表中添加常数列，如SELECT 'HELLO' FROM TABLE, 或者 SELECT 'HELLO' AS WORLD FROM TABLE

##### 选择表中的若干元组

- 消除取值重复的行：投影后的某些行可能相同，可以用DISTINCT消除，如果没有DISTINCT则为默认的ALL
	- ![[Pasted image 20251029110055.png]]
- 查询满足条件的元组WHERE：查询条件，加在WHERE后面
	- ![[Pasted image 20251029110410.png]]
	- 比较大小
		- ![[Pasted image 20251029110814.png]]
	- 确定范围
		- ![[Pasted image 20251029110830.png]]
	- 确定集合
		- ![[Pasted image 20251029110842.png]]
	- 字符匹配（使用LIKE进行匹配）
		- %是任意长度的字符床
		- \_是表示单个字符
		- ![[Pasted image 20251029110854.png]]
			- 注意：数据库字符集为ASCII时一个汉字需要两个\_\_，但字符集为GBK时，只需要一个
		- 如果要查询的东西，带有 \_%这些特殊符号的
		- 这是就要使用 ESCAPE '<换码字符>' 短语对通配符进行转义了
		- ![[Pasted image 20251029111451.png]]
	- 涉及空值的查询
		- ![[Pasted image 20251029111718.png]]
			- 这里的IS不能用等号代替
	- 多重条件查询
		- 使用逻辑运算符AND和OR用来连接多个查询条件。AND的优先级高于OR，但用户可以用括号改变优先级
		- ![[Pasted image 20251029111914.png]]

##### ORDER BY子句

用户可以用ORDER BY子句对查询结果按照一个或多个属性列的升序（ASC）或降序（DESC）排列

![[Pasted image 20251029113505.png]]

##### 聚集函数

就是求某一列的总的性质
使用DISTINCT取消重复值
![[Pasted image 20251029113603.png]]

>[!warning] 注意
>WHERE子句中是不能用聚集函数作为条件表达式的，聚集函数只能用于SELECT子句和GROUP BY中的HAVING子句

##### GROUP BY分组

给结果分组，用于将查询结果某一列或多列的值分组，值相等的为一组
对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果
![[Pasted image 20251029113356.png]]

如果分组后还要求按一定的条件对这些组进行筛选，最终只输出满足指定条件的组，则可以使用HAVING短语条件
![[Pasted image 20251029115205.png]]

>[!tip] HAVING和WHERE的区别
>两者的区别在于作用的对象不同。WHERE作用于基本表或视图，从中选择满足条件的元组。HAVING短语作用于组，从中选择满足条件的组

#### 2、连接查询