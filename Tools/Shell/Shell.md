# ShellNotes

## 目录    

- [基础](#基础)
- [脚本](#脚本)
- [数据整理](#数据整理)
- [系统调试](#系统调试)
- [命令行](#命令行)
- [工具](#工具)

## 基础

在操作系统层面,Shell是用户和操作系统内核之间的接口,它接收用户的输入,解释输入给内核,然后处理底层操作系统的输出来管理用户和系统的交互.      

大多数操作系统的Shell分为两类
- 命令行
- 图形用户界面

>这里采用前者       

使用CLI的Shell首先需要打开终端.       

打开之后,最早映入眼帘的是终端提示符,如     
`icecandy@icecandy:~$`         
上面所示从左到右分别为用户名@主机名:工作目录,是否为root用户.      

如上面所说一般,输入命令 `date` Shell便会输出当前的时间和日期. 输入 `echo hello` 便会输出hello, `echo` 命令负责将后面跟的字符串输出出来.    

>如果字符串包含空格,那么需要用单引号或者双引号包裹起来,或者用转义字符 `\` 处理,因为Shell是基于空格分割命令并进行解析的,把除了第一个之外的当作第一个的参数进行处理. 在这里对 `echo` 并没有什么影响,对 `mkdir` 有.        

Shell通过**环境变量**来去寻找需要执行的指令.        

>是的,变量,因为有一千个读者就有一千个哈姆雷特,所以是变量.         

### 路径    

在Linux和macOS上使用 `/` ,而Windows上使用 `\` . 路径 `/` 代表系统的根目录.windows用盘符.        
如果某个路径以 `/` 开头,那么它是一个绝对路径,其他的都是相对路径.相对路径指的是相对于当前工作目录的路径.相对路径使用了两个特殊的目录：     
- `.` ：表示当前目录
- `..` ：表示上级目录

>一般来说,当我们运行一个程序,如果我们没有指定路径,则该程序会在当前目录下执行.    

### 标记和选项   

就是给予命令的参数,都是以 `-` 开,并可以改变程序的行为.    

>选项就是带有值的标记     

当用 `ls -l` 获取了一个详细的目录以及文件信息如：    
`drwxr-xr-x 4 icecandy icecandy 4096 Sep 28 12:57 temC`     
前面的十个字符中的第一个代表了文件类型,剩下九个以三个为一组分别代表文件所有者,用户组,其他所有人具有的权限,其中 `-` 表示该没有对应的权限, `r` 表示可读, `w` 表示可写, `x` 表示可执行,之后是文件所有者 用户 大小 最后更新时间 文件名.     

>没错,目录可以看成是一个特殊的文件.         

>注意,如果是root账户,可以发动让我看看(.jpg)     

### 文件拓展名展开     

通配符： `?` , `*` 来匹配一个或多个字符.     

花括号 `{}` ：将里面的公共子串展开,花括号有时在一些选项里表示占位符,表示将结果作为参数写到花括号这里.多个括号采用笛卡尔积.           

### 重定向    

打开一个程序会产生三个流：标准输入流,标准输出流,标准错误流,以文件标识符存在,标准输入流的文件标志符为0,标准输出流的文件标识符为1,标准错误流的文件标识符为2,它们会从输入流中进行读取,当打印信息时,会将信息输出到输出流中.        

通过 `<` 和 `>` 来重定向流,前者重定向输入流,后者重定向输出流,还可以用 `>>` 来向一个文件追加内容.

重定向标准输出和标准错误, `2>&1` 标准错误流重定向到标准输出流, `1>&2` 标准输出流重定向到标准错误流.      

例： `command > file 2>&1` 或 `command &> file` , `&>` 表示将标准输入和标准输出同时重定向到文件,通常,为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上,在命令后面添加 `</dev/null` 是个好习惯

`|` 管道,将一个程序的输出和另外一个程序的输入连接起来.       

>这里不得不提Unix哲学,让一个程序专注于做好一件事并且做好,然后通过管道将简单程序组合起来完成复杂的功能.      

### here documents   

Bash中的"here documents", 如输入 `cat << delimiter` 后,会让你输入多行文本直到你输入 `delimiter` 结束,大大简化了多行文本的处理      


### su,sudo    

>不要用root账户乱搞,root账户很危险.                 

以其他用户的身份执行命令,使用 `sudo` 默认以root用户身份执行,使用 `-u` 来指定其他用户, `-i` 来以该用户登录

将Shell切换为其他用户,使用 `su username` 或者 `su - username` 加入 `-` 会使得切换后的环境与使用该用户登录后的环境相同,省略用户名则默认为root用户.    

> `sudo` 命令只对一个命令生效,无法通过管道传递.      

###  一些快捷键   

- `Tab` 键补齐
- `Ctrl+w` 删除键入的最后一个单词
- `Ctrl+u` 删除行内光标所在位置之前的内容
- `Ctrl+a` 将光标移至行首
- `Ctrl+e` 将光标移至行为
- `Alt+b/f` 以单词为单位移动光标
- `Ctrl+l` 清屏
- `Alt+.` 循环地向前一个参数,相当于上箭头
- `Alt+*` 展开通配符,如输入 `ls` 在按下这个快捷键,就会将匹配的文件自动输入到参数里
- `set -o vi/emacs` 使用vi/emacs风格的快捷键
- `Ctrl+x Ctrl+e` emacs风格,打开一个编辑器输入命令,这会创建一个临时文件
- `escape+v` vi风格,打开一个编辑器输入命令
- `!$` 上次键入的参数, `!!` 指代上次键入的命令
- `cd ~/-` 进入到home/上一次的工作路径的目录
- `Alt+#` 在行首添加 `#` 把它当作注释再按下回车执行,或 `Ctrl+a #,enter` 这样做的话,借助命令行历史记录,可以很方便恢复你刚才输入到一半的命令   

## 脚本     

大多数Shell都有自己的一套脚本语言,包括变量,控制流和自己的语法.Shell脚本与其他脚本语言不同之处在于,Shell脚本针对Shell所从事的相关工具进行了优化,因此,创建命令流程,将结果保存到文件,从标准输入中读取,这些都是Shell脚本中的原生操作,这让它比通用的脚本语言更易用.     

Shell函数和脚本有如下一些不同点：    
- 函数只能与Shell使用相同的语言,脚本可以使用任意语言.因此 `shebang` 是很重要的
- 函数仅在定义时被加载,脚本会在每次被执行时加载.这让函数的加载比脚本略快一些,但每次修改函数定义,都要重新加载一次
- 函数会在当前的Shell环境中执行,脚本会在单独的进程中执行,因此,函数可以对环境变量进行更改,脚本则不行,脚本需要使用 `export` 将环境变量导出,并将值传递给环境变量,这里是因为函数对环境变量的修改只体现在了进程内
- 与其他程序语言一样,函数可以提高代码模块性,代码复用性并创建清晰性的结构,Shell脚本中往往也会包含它们自己的函数定义

>用 [shellcheck](https://github.com/koalaman/shellcheck) 帮助你定位Shell脚本中的错误.     

>利用 `shebang` ,来用不同的编程语言写脚本.     
>`shebang` 是脚本开头的字符序列 `#!` ,后面跟着解释器的路径,程序加载器会执行指定的解释器程序,并将尝试运行脚本时最初使用的路径作为参数传递给它.解释器通常会忽略 `shebang` 行,应为 `#` 在许多脚本语言中是注释标记.通过 `shebang` 本质上是开了个子Shell执行,为了在自己的Shell执行可以用 `source scriptname` 或 `. scriptname` .    
>使用 `#/user/bin/env <解释器>` 可以提高移植性.      
>名字的由来 `#` 称为sharp或hash, `!` 称为bang.        

 >当变量和文件名中包含空格的时候要格外小心,Bash变量要用引号括起来,如 `"$PS1"` .    
 >尽量使用 `-0` 或 `-print0` 选项以便用NULL来分隔文件名,例如 `locate -0 pattern | xargs -0 ls -al` 或 `find / -print0 -type d | xargs -0 ls -al`.       
 >如果for循环中循环访问的文件名含有空字符,只需要用 `IFS=$'\n'` 把内部字段分隔符设为换行符.      


### 变量    

在Bash中为变量赋值的语法为    
`A=B`      
访问语法为     
`$A`       

> [!warning]
> 不要用空格隔开,解释器会把它们解释为参数.     

在Bash中的字符串通过 `'` , `"` 分隔符来定义,区别为前者定义的字符串为原义字符串,其中的变量不会被转义,而后者会将定义字符串中的变量值进行替换.           

同样的,Bash也支持 `if` , `case` , `while` , `for` 这种控制流关键字,也支持函数.可以接受参数并基于这些参数进行操作.      

Bash使用了很多特殊的变量来表示参数,错误代码和相关变量.如：      
- `$0` ：脚本名
- `$[1-9]` ：脚本的参数
- `$@` ：所有参数
- `$*` ：类似 `$@` ,但不带有空格,如 `123 312` 变为 `123` , `321`
- `$#` ：参数个数
- `$?` ：前一个命令的返回值
- `$$` ：当前脚本的进程识别码
- `$!` ：最后一次运行后台程序的PID
- `!!` ：完整的上一条命令
- `$_` ：上一条命令的最后一个参数
- `IFS` ：内置分隔符

>完整的[参数列表](https://www.tldp.org/LDP/abs/html/special-chars.html)      

使用 `shift` 命令可以将参数的位置向左移动

命令通常使用 `STDOUT` 来返回输出值,使用 `STDERR` 来返回错误及错误码,返回码或退出状态是脚本/命令之间交流执行状态的方式.返回码为0表示正常执行,其他所有非0的返回值都表示有错误发生.      

退出码可以搭配 `&&` 和 `||` 使用,用来进行条件判断,决定是否执行其他程序.它们都是"短路"运算符,同一行的多个命令可以用 `;` 分隔.       

另一个常见的模式是以变量的形式获取一个命令的输出,这可以通过**命令替换**实现.      

如用 `$(ls)` 把 `ls` 的输出结果替换掉 `$(ls)` ,还有一个冷门的类似特性是**进程替换**，用 `<(CMD)` 会先执行命令并将结果输出到一个临时文件中,并将 `<(CMD)` 替换成临时文件名.使用 `Escape` 键可以达到 `$(CMD)` 的效果.       

在Bash中,变量有 许多扩展方式：     
- `${variable:=value}` 若variable未定义则使用该值
- `${name:-default}` 变量为空时使用默认值      
- `${name:?error message}` 检查 `name` 变量是否为空,为空则输出 `error message`   
- `$( (数学表达式) )` 表示数学表达式,其必须再用一个括号包括
- `${var%2123}` `${var#123}` `%/#` 的作用表示截断

> 这里特别注意当变量里含有空格使用双引号把变量括起来,因为被替换后的空格会被识别为另一个参数.     

### 循环

**For循环**

For循环会在一组值循环,直至列表耗尽,在这也可以使用花括号来简化参数列表,同时 `{1..9}` 的格式表示从1到9, `{1..9..2}` 表示从1到9增量为2.也可以使用C风格的方式写for循环.      

```bash for
for variable_name in value1 value2 ... valuen;
do
	command1
	command2
	command3
done

for (( assignment;condition;next )) # C style
do
	command
done 
```


**While和Until**    

当条件为真时继续循环.     

```bash while
while [ condition ] # 用:表示无限循环
do
	command
done
```

当条件为假时继续循环.     

```bash until
until [ condition ]
do
	command
done
```

>Bash脚本也是有 `continue` 与 `break` .     

### Test [ ]     

Test是一个实在的程序,**所以使用时在周围要用空格**.     

对于字符串匹配用 `=` ,整型数用 `-eq`     
Test通常是伴随着 `if` and `while` 使用的,加入你的脚本叫做test,那么你如果调试时有麻烦.是因为它要调用的是bash内置程序,而不是你的.

>一般更建议使用 `[[` 而不是 `[` .     

### 分支控制语句    

**if**    

```bash if
if [[ condition ]]
then
	command
elif [[ condition ]];then # 如果将then和test放一行则要加分号 
	command
else
	command
fi
```

**case**    

```bash case
case variable_name in
	value1)
		command1
		;;
	value2|value3) # 用 | 分隔匹配多个值
		command2
		;;
	*)
		command3
		;;
esac
```

上面的 `;;` 表示break的效果,也可以用 `;&` 和 `;;&` 有不同的效果. `*` 表示都不匹配时所执行的操作.

>case的 `;;` 我觉得设计的比较好,可以放在循环里用break退出循环.     

### 外部程序   

通常用反引号来指示将所包含的文本作为命令执行.     

### 函数    

关于应该将Shell函数称为**过程**还是**函数**,可能会引起一些混淆;**函数的传统定义是返回单个值,不输出任何内容.而过程则不返回值,但可能会产生输出**.Shell函数可以不做任何事,也可以做其中一件事,或者两者兼而有之.在Shell脚本中,人们普遍认为它们被称为函数.    

函数可以采用以下不同方式返回值
- 改变一个或多个变量的状态
- 使用exit命令结束Shell脚本
- 使用return命令结束函数,并将提供的值返回给Shell脚本的调用部分
- echo输出到stdout,被调用者捕获

```bash
. function.lib # 调用其他库,原理是将脚本加载到当前Shell

function(){
	command
	if [[ $1 = "bye" ]]
	then 
		exit
	else
		function()	# 作为函数呢,递归也是很正常的吧!     
	fi
	return 0 # 都说了,作为一个函数,有返回值很正常吧
}

function arg1 arg2 arg3 ...
echo $? # 检查返回值
```

>bash脚本除了那些保留变量外($1,2,3那些)没有作用域一说,因此在函数里更改就是更改了. 若使用管道和其他命令一起执行,则会启动一个子Shell.所以不会影响到父Shell的变量.      

### 调试   

Bash本身提供了调试方法：     
- 命令行中：`$ bash -x script.sh`
- 脚本开头：`#!/bin/bash -x`
- 在脚本中用 set 命令调整( `set -x` 启用, `set +x` 禁用)

>注意避免几种调试选项混用.    

>在Bash脚本中,使用 `set -x` 去调试输出,或使用它的变体 `set -v` ,它会记录原始输入,包括多余的参数和注释.    
>尽可能使用严格模式：使用 `set -e` 令脚本在发生错误时退出而不是继续运行,使用 `set -u` 来检查是否使用了未赋值的变量.     
>试试 `set -o pipefail` ,可以监测管道中的错误,当牵扯到很多脚本时,使用 `trap` 来检测ERR和EXIT.    
>一个好的习惯是在脚本文件开头这样写,这会使它能够检测一些错误,并在错误发生时中断程序并输出信息.    

### 一些例子

对文本文件做集合运算

```bash
sort a b | uniq > c # a并b
sort a b | uniq -d > c # a交b -d只打印重复的行
sort a b b | uniq -u > c # a补b -u只打印单独的行
```

查阅当前目录下所有文件的内容

```bash
grep . *
head -100 *
```

Fork炸弹(任何情况下不要执行)    

```bash
:(){
	:|: & # 递归调用
};
: # 初始调用
# 快速消耗大量系统资源,拖慢系统运行速度    
# 限制一个用户能够拥有的进程数多少,可以有效防范
```

## 数据整理    

将某种格式存储的数据转换成另外一种格式,即为数据整理.     

`sed` ：基于 `ed` 构建的"流编辑器".可以利用一些简短的命令来修改文件,而不是直接操作文件的内容.      

`sed` 在使用正则表达式需要在符号前加 `\` 才能使其具有特殊含义.或者加 `-E` 参数.     

`uniq -c` ,把连续出现的行折叠为一行并使用出现次数作为前缀.      

`sort -n` ,按照数字顺序对输入进行排序, `-kn` 仅基于空格分割的第n列进行排序.      

`xargs/parallel` 将输入作为参数传给后面的命令,并且可以控制每行参数个数(-L)和最大并行数(-P).如果你不确定它们是否按你想的那样工作,使用 `xargs echo` 查看一下,还可以用 `-I{}` 参数指定输入的参数位置.    

### 正则表达式    

正则在不同的实现上会有些区别,跟Makedown文档一样,不过基本的相同. 通常一 `/` 开始结束,注意并不是一定以 `/` 结束. 常见的模式有：         
- `.` ：除换行符之外的任意字符
- `*` ：匹配前面的字符零次或多次
- `+` ：匹配前面的字符一次或多次
- `[abc]` ：匹配 `a` `b` `c` 中任意一个
- `[^abc]` ：除 `a` `b` `c` 中任意一个
- `(RX1|RX2)` ：任何能够匹配 `RX1` 或 `RX2` 的结果,也会将结果捕获下来供后向引用
- `^` ：行首
- `$` ：行尾
- `?` ：前面的字符可以出现也可以不出现
- `\d/D` ：全部数字/除数字之外
- `\.` ：.号
- `\w/w` ：任意字母表字符/除字母表字符之外
- `{n}` ：匹配前面的字符n次
- `{n,m}` ：匹配前面的字符n到m次
- `\s/S` ：匹配空格/除空格之外
- `\b` ：匹配单词边界,如字符串 `hello123` ,则 `\bhello\b` 不会匹配到 `hello123` 

>使用 `*` `+` 的时候默认是贪婪模式,即尽可能匹配更多的子表达式.在 `*` `+` 之后加上 `?` 变为懒惰模式,即尽可能匹配更少的子表达式.

>正则中的圆括号内匹配的文本会被捕获下来,用 `\1` , `\2` , `\3` 这样子调用

>零宽断言用于查找某些内容进行定位,但内容并不放入匹配结果     
>(?=exp) 匹配exp前面的位置,(?<=exp) 匹配exp后面的位置

>[Regex101](https://regex101.com/) 网站集成了常见编程语言正则表达式的解析工具,在编写正则时可以作为一个不错的参考.     

**基本/拓展正则表达式**    

基本正则表达式(Basic Regular Expressions,BRE)和扩展正则表达式(Extended Regular Expressions,ERE)是两种POSIX正则表达式风格.      

BRE可能是如今最老的正则风格了,对于部分特殊字符(如 `+`, `?`, `|`, `{`)需要加上转义符 `\` 才能表达其特殊含义.      

ERE与如今的现代正则风格较为一致,相比BRE,上述特殊字符默认发挥特殊作用,加上 `\` 之后表达普通含义.      

### awk    

是一种编程语言,善于处理文本.       

`awk` 程序接受一个模式串以及一个代码块,指定当模式匹配时应该做何种操作,默认当模式串即匹配所有行在代码块中, **`$0` 表示整行内容, `$1-n` 为一行中的n个区域**,基于 `awk` 的分隔符来分隔,默认为空格,可以用 `-F` 来修改.     

**若在其中使用了正则表达式最好用单引号引起来**.     

也可这样：

```awk
BEGIN {初始化}
command {匹配到一行执行}
END {结束执行}
```

### 使用技巧   

- 将HTML转为文本： `lynx -dump -stdin`
- Markdown,HTML,以及所有文档之间的转换, `pandoc`
- XML, `xmlstarlet`
- JSON, `jq` 
- YAML, `shyaml`
- Excel,CSV, `in2csv/csvcut/csvjoin/csvgrep`
- Amazon S3, `s[34]cmd/aws/saws`
- `cut/paste/join` 更改文件
- `wc` 计算行数 `-l` 字符数 `-m` 单词数 `-w` 字节数 `-c`
- `tee` 将标准输入流复制到文件
- `datamash` 进行复杂计算,如分组,逆序,和一些其他的统计分析
- 语言设置对许多命令行工具有一些微妙的影响,如排序的顺序和性能
- 可以单独指定某一条命令的环境,只需要在调用时把环境变量设定放在命令的前面
- `repren` 来批量重命名,或多个文件中搜索替换内容
- `perl` 替换一个或多个文件中出现的字符串
- `rsync` 是一个快速且灵活的文件复制工具,也可以删除大量文件
- `pv/pycp/progress/rsync --progree` 在复制文件时获取当前进度,若为block块拷贝,可以使用 `dd status=progress` 
- `shuf` 以行为单位来打乱文件的内容或从一个文件中随机选取多行
- 可以 `Ctrl+v [Tab]` 或 键入 `$'\t'` 写入Tab制表符 
- 标准的源代码对比及合并工具 `diff` 和 `patch` 使用 `diffstat` 查看变更的总览数据. `vimdiff` 用于比对并二进制编辑
- `strings` 可以帮助在二进制文件中查找特定比特
- 制作二进制差分文件, `xdelta3` 采用Delta压缩
- `iconv` 更改文本编码, `uconv` 支持一些高级的 Unicode 功能
- 拆分文件 `split` 按大小拆分 `csplit` 按模式拆分
- 操作时间和日期表达式,可以用 `dateutils` 中的 `dateadd/datediff/strptime` 
- 使用 `zless/zmore/zcat/zgrep` 对压缩过的文件进行操作
- 使用 `chattr` 设置文件属性,文件属性比文件权限更加底层
- `getfacl/setfacl` 保存和恢复文件权限
- `truncate` 创建稀疏文件, `fallocate` 用于 ext4,xfs,btrf和ocfs2文件系统, `xfs_mkfile` 适用于几乎所有的文件系统,包含在xfsprogs包中, `mkfile` 用于类Unix操作系统,如Solaris和Mac OS

## 系统调试

- `curl` 和 `curl -I` 可以被轻松地应用于web调试, `wget\httpie` 也行
- `h?top/iostat/iotop`  获取CPU和硬盘的使用状态
- `netstat/ss` 查看网络连接的细节
- `dstat` 对系统的现状显示一个粗略信息, `glances` 提供一些系统级的数据
- `free/vmstat` 内存状态,其中的"cached"的值为Linux内核用来作为文件缓存的内存大小,而与空闲内存无关
- `mtr` 跟踪路由
- `ncdu` 来查看磁盘使用情况,它比寻常的命令更节省时间
- `iftop/nethogs` 查找正在使用带宽的套接字连接或进程
- `ab/siege` 用于简单/复杂的检查Web服务器的性能
- `wireshark/tshark/ngrep` 可用于复杂的网络调试
- `strace` 和 `ltrace` 用于追踪程序的运行
- `ldd` 检查共享库,[不要乱 `ldd` 陌生文件](http://www.catonmat.net/blog/ldd-arbitrary-code-execution/)
- `gdb` 调试程序
- `/proc` 是Linux系统的一个虚拟文件系统,提供了系统内核和进程的运行时信息,可以在调试的时候产生帮助
- `sar` 查看cpu,内存以及网络等历史数据
- `stap` , `perf` , `sysdig` 深层次的系统分析
- `uname` 或者 `lsb_release -a` 查看当前使用的系统
- `dmesg` 引导及系统错误信息
- `lsof | grep deleted | grep "filename-of-my-big-file"` 查看删除的文件是否被进程占用

## 命令行    

>命令行参数有128K限制,使用通配符匹配大量文件名时,常会遇到"Argument list too long"的错误,这种情况下换用 `find` 或 `xargs` 通常可以解决.      
>这个限制是因为execve()内核函数会在内存空间创建一个128K的缓冲区,并将新进程的命令行和环境复制到这里,如果无法将提供的参数列表和环境放入128K缓冲区时,会返回!E2BIG错误代码,从而导致出现"参数列表太长"错误消息.     

### 任务控制        

在现代操作系统中,进程是必不可少的概念.    

**进程标志符**(PID,Process Identifier),是一个数字,是进程唯一的标志.  

进程中,有**优先级**的概念.    


#### 结束进程

Shell使用UNIX提供的信号机制执行进程间的通信.当一个进程接收到信号时它会停止执行,处理该信号并基于信号传递的信息来改变其执行.就这一点而言,信号是一种**软件中断**.     

使用 `Ctrl+c` 传递的是 `SIGINT` 信号, `Ctrl+\` 传递的是 `SIGQUIT` 信号.      

尽管 `SIGINT` 和 `SIGQUIT` 都常常用来发出和终止程序相关的请求,但 `SIGTERM` 则是一个更加通用的,也更加优雅地退出信号.为了发出这个信号,我们需要 `kill` 命令, `kill -TERM <PID>` .     

#### 暂停和后台执行进程     

信号可以让进程做其他的事情,而不仅仅终止它们.    

`SIGSTOP` ,让进程暂停,通过 `Ctrl+z` 发出 `SIGTSTP` 即"Terminal Stop". 也可以 `kill -STOP [pid]` 停止一个进程

使用 `fg` , `bg` 来恢复暂停的工作,分别表示在前台继续或在后台继续.    

使用 `jobs` 列出当前终端会话中尚未完成的全部任务,可以使用pid引用这些任务,也可以用 `pgrep` 找出pid.更直觉的操作为使用 `%+任务编号` 来选取该任务.若要选择最近的任务用 `$!` 这一特殊参数.  

>在命令使用 `&` 后缀可以让命令直接在后台运行.     

关闭终端时会发送 `SIGHUP` 将后台进程也一并关闭,可以用 `nohup` 来忽略它,对于已经运行的程序可以使用 `disown` .    

`SIGKILL` 是一个特殊的信号,它不能被进程捕获并且他会马上结束该进程,不过这样做会有副作用,如留下孤儿进程.     

#### 查看进程    

`pstree -p`  以一种优雅的方式展示进程树      

pgrep/pkill` 根据名字查找进程/发送信号(-f参数通常有用)    

### 终端多路复用   

在一个终端中分割出多个终端窗口,便于同时与多个Shell会话交互.      

`screen/tmux` 来使用多份屏幕,当使用 `ssh` 时,如保存session信息,将尤为有用 `byobu/datch` 可以为它们提供更多的信息和易用的管理工具.     

见[Tmux](../Tmux/Tmux.md) .    

### 别名    

使用 `alias` 给命令设置别名如    
`alias up="cd .."`     

`unalias` 取消别名.    

将别名命令放在 `.bashrc` 下持续生效,因为开机加载.    

### 远端设备

使用 `ssh` 连接到其他服务器     

**执行命令**   

`ssh <remotename> command` 在远端执行命令,如果要执行多条命令需要有引号引起来.     

**SSH密钥**    

基于密钥的验证机制使用了密码学中的公钥,我们只需要向服务器证明客户端持有对应的私钥,而不需要公开其私钥.这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录,私钥(通常是 `~/.ssh/id_rsa` 或者 `~/.ssh/id_ed25519` )等效于您的密码,一定要好好保管.    

**密钥生成**    

使用 `ssh-keygen` 生成一对密钥,还可以为密钥设置密码,使用 `ssh-agent` 或 `gpg-agent` ,这样就不需要每次都输入该密码.     

**基于密钥的认证机制**    

`ssh` 会查询 `.ssh/authorized_keys` 来确认那些用户可以被允许登录.      

**通过SSH复制文件**    

- `ssh+tee` ： `cat localfile | ssh remote_server tee servearfile`   
- `scp` ：当需要拷贝大量文件或目录时,使用 `scp` 命令会更加方便,因为它可以方便的遍历相关路径.语法为 `scp path/to/local_file remote_host:path/to/remote_file`   
- `rsync` ：对 `scp` 进行了改进,它可以检测本地和远端的文件以防止重复拷贝.还可以提供一些诸如符号连接,权限管理等功能.甚至可以基于 `--partial` 标记实现断点续传.语法和 `scp` 类似

**端口转发**    

端口转发有两种,本地端口转发和远程端口转发.      

常见的情景是使用本地端口转发,即远端设备上的服务监听一个端口,如使用 `ssh -L 端口号:localhost:端口号 <remote>` 发送数据给本地端口,远端从远端端口接收.    

**SSH配置**    

使用 `~/.ssh/config` .

服务器端的配置文件通常放在 `etc/ssj/sshd_config` .

>最好不要公布到互联网上,如果你想被攻击.    

**杂项**  

`Mosh` 对 `ssh` 进行了改进,它允许连接漫游,间歇连接及智能本地回显.     

将远端文件夹挂在到本地会比较方便, `sshfs` 可以将远端服务器上的一个文件夹挂载到本地,然后您就可以使用本地的编辑器了.     

需要从一台远程服务器上访问web页面,可以去了解 `ssh` 使用 `-L/D` 参数
 
### 配置文件dot files    

很多程序的配置都是通过纯文本格式的被称为**点文件**的配置文件来完成的.    

>点文件的由来最早是UNIX系统的配置文件都以.开头,之后延续下来的.      

>把别名,Shell选项,常用函数保存在 `~/.bashrc`,把环境变量的设定以及登陆时要执行的命令保存在 `~/.bash_profile` .     
>而对于从图形界面启动的Shell和 `cron` 启动的Shell,则需要单独配置文件.    

在启动时,Shell程序会读取很多文件以加载其配置项,根据shell本身的不同,完成过程可能会有不同.   
对于 `bash` ,在大多数系统下,你可以编辑 `.bashrc` 或 `.bash_profile` 来进行配置.    

**管理**    

放在一个版本控制系统下的文件夹下,通过脚本将其符号链接到需要的地方,这么做可以：
- 安装简单：如果登录了一台新的设备,在这台设备上重新配置很快
- 可移植性
- 同步
- 变更追踪  

**可移植性**   

在脚本里使用分支控制语句来保证.    


## 工具    

### 基础    

- `man` ：查看手册
	- `man ascii/unicode/utf-8/latin1` 有助于去了解通用的编码信息
- `ls` ：查看指定目录下包含哪些文件
- `cp` ：拷贝文件
- `mkdir` ：新建文件夹
- `mv` ：移动以及重命名
- `cd` ：切换目录
- `echo` ：输出跟在后面的字符串
- `pwd` ：获取当前工作目录
- `touch` ：更新文件也可用于创建文件
- `chmod` ：给文件设置权限
- `find` ：查找文件或目录,可以通过文件名和一些文件属性查找
- `grep` ：文本匹配工具,有 `ack` , `ag` , `rg` 等替代品
- `history` ：查看Shell中输入的历史命令,通过 `!<num>` 来执行历史命令
- `su` ：主要用于切换到root账户
- `sudo` ：主要用来以root的权限执行命令
- `date` ：输出当前的日期和时间
- `head` ：显示头几行
- `tail` ：显示尾几行
- `jobs` ：列出当前终端会话中尚未完成的全部任务
- `fg` ：让任务在前端工作
- `bg` ：让任务在后端工作
- `kill` ：杀死进程
- `htop`：top 的加强版
- `nohup/disown` 使一个后台进程持续运行
- `sort` ：对输入的数据排序
- `uniq -c` ：对输入数据连续出现的行折叠为一行并使用出现次数作为前缀
- `alias` ：别名
- `unalias` ：取消别名
- `xargs` ：将输入作为参数传给后面的命令
- `uptime` 来查看系统已经运行多长时间
- `w`：查看处于登录状态的用户
- `id`：用户/组 ID 信息
- `source` ：执行一个文件中的命令
- `tree/broot/nnn/ranger` ：前两者用来概览目录结构,后两者文件管理器
- `watch` ：定期执行某个命令
- `seq`：打印数字
- `expr` ：计算表达式或正则匹配
- `m4`：简单的宏处理器
- `yes`：多次打印字符串
- `fd` ： `find` 的替代品,Ubuntu没有自带要安装
- `locate` ：跟 `updatedb` 达成联动来建立个查找数据库,只能查找文件名
- `updatedb` ：跟 `cron` 达成联动来更新数据库
- `cron` ：根据配置计划执行命令
- `fasd/autojump` ：查找最常用或最近使用的文件和目录
- `cal`：漂亮的日历
- `env`：执行一个命令（脚本文件中很有用）
- `printenv`：打印环境变量
- `type <命令>` ：判断这个命令是可执行文件,Shell内置命令还是别名
- `lockfile`：使文件只能通过 `rm -f` 移除
- `time`：执行命令,并计算执行时间
- `timeout`：在指定时长范围内执行命令，并在规定时间结束后停止进程

### 网络

- `netstat` ：查看网络状态
- `host` 和 `dig`：DNS 查找
- `nc`：网络调试及数据传输
- `socat`：套接字代理，与 `netcat` 类似
- [`slurm`](https://github.com/mattthias/slurm)：网络流量可视化
- [`mtr`](http://www.bitwizard.nl/mtr/)：更好的网络调试跟踪工具
- `ss`：套接字数据
- `ab` 或 [`wrk`](https://github.com/wg/wrk)：web 服务器性能分析
- [`wireshark`](https://wireshark.org/) 和 [`tshark`](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)：抓包和网络调试工具
- [`ngrep`](http://ngrep.sourceforge.net/)：网络层的 grep
- [`iftop`](http://www.ex-parrot.com/~pdw/iftop/) 或 [`nethogs`](https://github.com/raboof/nethogs)：套接字及进程的网络利用情况


### 远端相关         

- `ssh` ：远程登录
- `rsync`：通过 ssh 或本地文件系统同步文件和文件夹


### 系统性能相关以及调试   

- `iostat`：硬盘使用状态
- `mpstat`： CPU 使用状态
- `vmstat`： 内存使用状态
- `dmesg`：引导及系统错误信息
- `sysctl`： 在内核运行时动态地查看和修改内核的运行参数
- `hdparm`：SATA/ATA 磁盘更改及性能分析
- `lsblk`：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息
- `lshw`，`lscpu`，`lspci`，`lsusb` 和 `dmidecode`：查看硬件信息，包括CPU,BIOS,RAID,显卡,USB设备等
- `lsmod` 和 `modinfo`：列出内核模块，并显示其细节
- `strace`：调试系统调用
- `ldd`：动态库信息
- `lsof`：列出当前系统打开文件的工具以及查看端口信息,来查看开启的套接字和文件
- `dstat`：系统状态查看
- [`glances`](https://github.com/nicolargo/glances)：高层次的多子系统总览
- `toe`：terminfo 入口列表
- [`sar`](http://sebastien.godard.pagesperso-orange.fr/)：系统历史数据
- `last`：登入记录


### 数据整理   

- `awk` ：一种编程语言,善于处理文本
- `sed` ：流编辑器
- `fmt`：格式化文本段落
- `pr`：将文本格式化成页／列形式
- `cut` , `paste`  和 `join`：数据修改
- `fold`：包裹文本中的几行
- `column`：将文本格式化成多个对齐,定宽的列或表格
- `expand` 和 `unexpand`：制表符与空格之间转换
- `nl`：添加行号
- `iconv` 或 `uconv`：文本编码转换
- `split` 和 `csplit`：分割文件
- `fpp` ：可以与基于另一个命令输出的文件交互
- [`when-changed`](https://github.com/joh/when-changed)：当检测到文件更改时执行指定命令。参阅 `inotifywait` 和 `entr`。
- `tac`：反向输出文件
- `shuf`：文件中随机选取几行
- `comm`：一行一行的比较排序过的文件
- `strings`：从二进制文件中抽取文本
- `tr`：转换字母
- `look`：查找以特定字符串开头的单词或行
- `file`：确定文件类型
- `stat`：文件信息
- `dd`：文件或设备间传输数据
- `sponge`：在写入前读取所有输入
- `nm`：提取 obj 文件中的符号
### 终端复用   

- `tmux` ：终端复用器
### 数学相关   

- `factor`：分解因数
- `units`：将一种计量单位转换为另一种等效的计量单位
- `bc`：计算器

### 安全相关 

- `apg`：随机生成密码
- [`gpg`](https://gnupg.org/)：加密并签名文件

### 压缩   

- `logrotate`： 切换,压缩以及发送日志文件
- `xz`：高比例的文件压缩

### 未知  

- `cssh`：可视化的并发 shell


















> [!tip] 历史命令记录相关
> 对于大多数的Shell来说,可以使用 `Ctrl+R` 来对命令历史记录进行回溯搜索,可以配合 `fzf` 使用,它是一个通用的模糊搜索查找工具.      
> 还可以修改Shell history的行为,如：如果在命令的开头加上一个空格,就不会被加进历史记录中,通过在 `.bashrc` 文件中加上 `HISCTONTROL=ignorespace` .
> 用 `!` 加上一部分命令会自动在历史记录查找最近匹配的命令.     

> [!tip]
>有时看手册信息量太大,看看[TLDR](https://tldr.sh/).