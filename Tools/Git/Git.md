# GitNotes  

## 目录

- [关于版本控制](#关于版本控制)
- [Git简史](#Git简史)
- [Git介绍](#Git介绍)
- [Git配置](#Git配置)
- [Git基础](#Git基础)
- [命令](#命令)
- [获取帮助](#获取帮助)
- [QA](#QA)

## 关于版本控制  

版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
它有着以下阶段
- [本地版本控制系统](#本地版本控制系统)
- [集中化的版本控制系统](#集中化的版本控制系统)
- [分布式版本控制系统](#分布式的版本控制系统)

### 本地版本控制系统  

**起因**：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。  
**结果**：为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 [RCS](https://www.gnu.org/software/rcs/)的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。   
**缺点**：当本地机器损坏，又没有恰当的备份，你将丢失所有数据。

### 集中化的版本控制系统  

**起因**：人们又遇到一个问题，如何让在不同系统上的开发者协同工作？   
**结果**：于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS,Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。  
**缺点**：当中央服务器的单点故障，谁也无法提交更新，也就无法协同工作。如果中心数据库所在磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据--包括项目整个的变更历史，只剩下人们在各自机器上保留的单独快照。  

### 分布式版本控制系统  

**起因**：为了解决上面两者的缺点  
**结果**：分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。在这类系统中，像Git，Mercurial以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。  
**优点**：**任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。** 因为每一次的克隆操作，实际上都是对代码仓库的完整备份。**更进一步，许多这类系统都可以指定和若干不同的远端代码交互。** 籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流层，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。  

## Git简史  

**创建年代**：2005年    
**创建原因**：Linux内核开源项目有着为数众多的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002),到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权利。这就迫使Linux开源社区(特备是Linux的缔造者Linux Torvalds)基于使用BitKeeper时的经验教训，开发出自己的版本系统。他们对新的系统制定了若干目标：
- 速度
- 简单的设计
- 对非线性开发模式的强力支持(允许成千上万个并行开发的分支)
- 完全分布式
- 有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)   

**结果**：自诞生于2005年以来，Git日臻成熟完善，在高度易用的同时，仍然保留初期设定的目标。它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。  

>BitKeeper之所以不让社区继续使用的原因是有位开发者破解了它的协议被公司发现了于是停止了合作，据说Git的开发用了两周就写完了。  

## Git介绍  

>**注意！！！**：在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS，Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。  

### 直接记录快照，而非差异比较  

Git 和其它版本控制系统（包括 Subversion 和近似工具）的**主要差别在于 Git 对待数据的方式。**  

从**概念**上来说，**其它大部分系统**：以**文件变更列表**的方式存储信息，这类系统（CVS，Subversion，Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。

Git 不按照以上方式对待或保存数据。反之，**Git 更像是把数据看作是对小型文件系统的一系列快照。** 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 **为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。** Git 对待数据更像是一个 **快照流。**  

Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS工具。  

### 近乎所有操作都是本地执行  

在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。  

### Git 保持完整性  

**Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。** 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。

**Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。** 基于 Git 中文件的内容或目录结构计算出来。如：  `24b9da6552552987aa493b52f8696cd6d3b00373`  

**实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。**  

### Git一般只添加数据  

你执行的 Git 操作，几乎只往 Git 数据库中 **添加** 数据。 你很难使用 Git 从数据库中**删除**数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。

>真要在快照里删除数据也行。

### 三种状态   

**Git有三种状态**：
- 已提交(committed)：表示修改了文件，但还没保存到数据库中
- 已修改(modified)：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中
- 已暂存(staged)：表示数据已经安全地保存在了本地数据库中

**Git项目的三个区**：
- 工作区：是对**某个版本独立**提取出来的内容，放在磁盘上供你修改或使用
- 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。按照Git术语叫“索引”
- Git目录：是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，克隆就是复制这里的数据   

Git的工作流程：
1. 在工作区修改文件
2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区
3. 提交更新，找到暂存区文件，将快照永久性存储到Git目录  

## Git配置  

Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在：
1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 `git config` 时带上 `--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）
2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。 你可以传递 `--global` 选项让 Git 读写此文件，这会对你系统上 **所有** 的仓库生效
3. 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config` ）：针对该仓库。 你可以传递 `--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效）

>每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量。  

你可以通过以下命令查看所有的配置以及它们所在的文件：
```$ git config --list --show-origin```  

安装完Git之后，要做的第一件事就是设置你的用户名和邮件地址。它们会写入到你的每一次提交中，不可更改：
`$ git config --global user.name <username>` 写入到 `~/.gitconfig`   
`$ git config --global user.email <useremail>` 写入到 `~/.gitconfig`  
想针对特定的项目使用特定的用户名和邮箱，可以在那个项目下运行没有 `--global` 的选项命令来配置。 

接着需要配置文本编辑器  
`$ git config --global core.editor <editor>` 配置文本编辑器  

`git config --list` 检查配置信息  
>可能会有重复，因为会从不同文件读取同一个配置。    

`git config <key>` 检查Git的某一项配置   

`.gitignore` 忽略文件，格式规范如下：
- 所有空行或者以 `#` 开头的行都会被Git忽略
- 可以使用标准的glob模式匹配，它会递归地应用在整个工作区中
- 匹配模式可以以( `/` )开头防止递归
- 匹配模式可以以( `/` )结尾指定目录
- 要忽略指定模式以外的文件或目录，可以在模式前加个叹号( `!` )取反   
>**glob模式** 
>指shell所使用的简化了的正则表达式。星号( `*` )匹配零个或多个任意字符， `[abc]`  匹配任何一个列在方括号中的字符，问号( `?` )只匹配一个任意字符，如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配( `[0-9]` 表示匹配0到9的数字)。使用两个星号( `**` )表示匹配任意中间目录，如 `a/**/z` 可以匹配 `a/z` `a/b/z`等。  

[GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表](https://github.com/github/gitignore)

## Git基础  

### Git仓库
通常用两种获取Git项目仓库的方式：
1. 利用 `git init` 命令将尚未进行版本控制的本地目录转换为Git仓库
2. 利用 `git clone <url> <name>` 命令从其他服务器克隆一个已存在的Git仓库   

### 更新
工作目录下的每一个文件都不外乎这两种状态：
- 已跟踪：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是[未修改、已修改或已放入暂存区](#三种状态)，总之，它是Git已知道的文件。
- 未跟踪：除了已跟踪文件外就是未跟踪文件，既不存在于上次的快照记录中，也没有被放入暂存区。

可以用 `git status` 命令检查哪些文件都处于什么状态。
- 可以加 `-s\--short` 参数，用简洁的方式查看更改，简短会将状态变为两栏，左栏为暂存区的状态，右栏为工作区的状态。  

可以用 `git add <files>` 命令去跟踪一个文件，将文件添加至暂存区，把有冲突的文件标记为已解决状态。**已暂存的文件若修改，则需再次使用该命令，提交时只会提交最后一次使用该命令的文件版本。** 使用文件或目录的路径作为参数，如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。名字可以用通配符。  

可以用 `git diff` 命令查看已暂存和未暂存的修改。
- 不加参数，查看尚未暂存的文件更新了哪些部分
- 加 `--staged` 参数，这条命令将比对已暂存文件与最后一次提交的文件差异
- 使用 `git difftool --tool-help` 命令来看你的系统都支持哪些git diff插件
>**注意**，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 `git diff` 后却什么也没有，就是这个原因。  

可以用 `git commit` 命令去提交一个快照。
- 加 `-m` 参数，将提交信息与命令放在同一行
- 加 `-a` 参数，自动把所有已经更新过的文件暂存起来一并提交，从而跳过 `git add` 步骤

可以用 `git rm <files>` 命令去移除某个文件。
- 加 `-f` 参数，去强制删除之前修改过或已经放到暂存区的文件
- 加 `--cached` 参数，只从暂存区域中移除     

>`git rm` **命令后面可以列出文件或者目录的名字，也可以使用 `glob` 模式。比如**：
- `$ git rm log/\*.log`   
>**注意到星号 `*` 之前的反斜杠 `\`， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用shell 来帮忙展开。** 此命令删除 `log/` 目录下扩展名为 `.log` 的所有文件。 类似的比如：~    
- `$ git rm \*~`   
>该命令会删除所有名字以 `~` 结尾的文件。   

可以用 `git mv <source> <destination>` 命令来对文件改名。   
相当于   
```
mv <source> <destination>  
git rm <source>  
git add <destination>  
```

### 查看提交历史   

可以使用 `git log` 命令查看提交历史。   
- 没有参数的情况下，会按时间先后顺序列出所有的提交，最近的更新排在最上面
- 加 `-p\--patch` 参数，它会按补丁格式显示出每个提交所引入的差异
- 加 `-n` 参数，显示最近n次提交
- 加 `--stat` 参数，查看提交的简略统计信息
	- `--shortstat` 参数，只显示最后的行数修改统计
- 加 `--name-only` 仅在提交信息后显示以修改的文件清单
- 加 `--name-status` 显示新增、修改、删除的文件清单
- 加 `--abbrev-commit` 仅显示SHA-1校验和所有40个字符中的前几个字符
- 加 `--relative-date` 使用较短的相对时间而不是完整格式显示日期(如"2 weeks age")
- 加 `--pretty` 参数，可以使用不同的默认格式的方式展示提交历史
	- `--pretty=oneline` 将每个提交放在一行显示
	- `--pretty=short` 
	- `--pretty=full` 
	- `--pretty=fuller` 
	- `--pretty=format` 定制记录的显示格式
- 加 `--graph` 参数，在日志旁以ASCII图形显示分支与合并记录
- 加 `--since\--after` 参数，仅显示指定时间之后的提交
- 加 `--until\--before` 参数，仅显示指定时间之前的提交
- 加 `--committer` 参数，仅显示提交者匹配指定字符串的提交
- 加 `--author` 参数，显示指定作者匹配指定字符串的提交
- 加 `--grep` 参数，仅显示提交说明中包含指定字符出的提交 
- 加 `-S <string>` 参数，仅显示添加或删除内容匹配指定字符串的提交
- 加 `-- <path>` 参数，查找某些文件或目录的提交
- 加 `--no-merges` 选项，隐藏合并提交  

>你可以指定多个 `--author` 和 `--grep` 搜索条件，这样会只输出匹配 **任意** `--author` 模式和 **任意** `--grep` 模式的提交。然而，如果你添加了 `--all-match` 选项， 则只会输出匹配 **所有** `--grep` 模式的提交。

>**作者与提交者**  
>作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。  

>其实也并不是在任何情况下都是所有，但你用 `git reset --hard` 切换到旧记录，此时并不会显示所有提交，因为这时的master分支跑到了旧分支， `log` 按分支节点递归查找，所有会丢失后面的提交。QA1.  

表1. format常用格式

| 选项    | 说明                          |
| ----- | --------------------------- |
| `%H`  | 提交的完整哈希值                    |
| `%h`  | 提交的简写哈希值                    |
| `%T`  | 树的完整哈希值                     |
| `%t`  | 树的简写哈希值                     |
| `%P`  | 父提交的完整哈希值                   |
| `%p`  | 父提交的简写哈希值                   |
| `%an` | 作者名字                        |
| `%ae` | 作者的电子邮件地址                   |
| `%ad` | 作者修订日期（可以用 --date=选项 来定制格式） |
| `%ar` | 作者修订日期，按多久以前的方式显示           |
| `%cn` | 提交者的名字                      |
| `%ce` | 提交者的电子邮件地址                  |
| `%cd` | 提交日期                        |
| `%cr` | 提交日期（距今多长时间）                |
| `%s`  | 提交说明                        |



## 命令
### 基础命令  

- `git config --global user.name <username>` 刚安装时使用，进行用户签名
- `git config --global user.email <useremail>` 刚安装时使用，进行用户签名
- `git config --global core.editor <editor>` 配置文本编辑器
- `git init` 初始化本地仓库   
- `git status` 查看本地库状态  
- `git add <filename>` 添加到暂存区  
- `git commit <filename>` 提交到本地库
- `git help <command>` 获取git命令的帮助信息
- `git diff <filename>` 显示与暂存区文件的差异  
- `git diff <revision> <filename>` 显示某个文件两个版本之间的差异  

### 查看日志命令

- `git log` 显示历史日志  
  - `git log --all --graph --decorate` 可视化历史记录（有向无环图）  
- `git reflog` 查看reflog信息  

### 分支和合并

- `git branch` 显示分支  
- `git branch <name>` 创建分支  
- `git merge <revision>` 合并到当前分支  
- `git mergetool` 使用工具来处理冲突  
- `git rebase` 将一系列补丁变基为新的基线  
- `git checkout <revision>` 更新HEAD和目前的分支  
  - `git checkout -b <name>` 创建并切换分支
- `git reset --hard <revision>` 重置HEAD指针到指定的提交  

### 远端操作  

- `git remote` 列出远端  
- `git remote add <name> <url>` 添加一个远端  
- `git push <remote> <local branch>:<remote branch>` 将对象传送至远端并更新远端引用  
- `git branch --set-upstream-to <remote>/<remote branch>` 创建本地和远端分支的关联关系  
- `git fetch` 从远端获取对象/索引  
- `git pull` 相当于git fetch;git merge  
- `git clone <url>` 从远端下载仓库  

### 撤销

- `git commit --amend` 编辑提交的内容或信息  
- `git reset HEAD <filename>` 恢复暂存文件  
- `git checkout -- <filename>` 丢弃修改  
- `git restore` git2.32 版本后取代 git reset 进行许多撤销操作  

### 高级操作  

- `git config` Git 是一个高度可定制的工具  
- `git clone --depth=1` 浅克隆(shallow clone)，不包括完整的版本历史信息  
- `git add -p` 交互式暂存  
- `git rebase -i` 交互式变基  
- `git blame` 查看最后修改某行的人  
- `git stash` 暂时移除工作目录下的修改内容  
- `git bisect` 通过二分查找搜索历史记录  
- `.gitignore` 指定故意不追踪的文件(不是命令，是dot file)  

## 获取帮助  

有三种方式可以找到Git命令的综合手册：
- `$ git help <verb>`  
- `$ git <verb> --help`
- `$ man git-<verb>`

你可以尝试在 [Freenode IRC](https://freenode.net/) 服务器上的 `#git` 或 `#github` 频道寻求帮助。  

此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 `-h` 选项获得更简明的手册

## QA  

>**1. `log` 与 `reflog` 的区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`log` 显示当前HEAD及其祖先。也就是说，它会打印HEAD指向的提交，然后是其父级、其父级的父级...。它会通过递归查找每个提交的父级来遍历存储库的祖先。`reflog` 不会遍历HEAD的祖先，它是HEAD指向的提交的有序列表，是存储库的撤销历史记录，它不是存储库本身的一部分（它与提交本身分开存储），也不包含在推送，提取或克隆中，它纯粹是本地的。  
>另外：了解 `reflog` 意味着一旦提交，就不会真正丢失在存储库里的数据。如果不小心重置为较旧的版本，或错误的重新设置了基数，或任何其他直观地“删除”操作，都可以使用 `reflog` 查看之前的位置，然后通过 `git reset --hard <hashkey>` 返回该引用以恢复之前的状态。引用不止意味着提交，也意味着背后整个的历史记录，但reflog条目并不会永久保留，但错误至少在两周内会是安全的。  

>**2. `checkout` 与 `reset --hard` 的区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者只去更新HEAD指针，列如，在使用时，从主线切换到其他地方，只有HEAD指针去移动，而后者，则将主线指针也一并带了过来，为此可能会出现丢失数据的情况，就要用到 `reflog` 了。  

>**3. `checkout -- <filename>` 与 `reset HEAD <filename>` 区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者如果文件没有添加到缓存区，那么将最近一次提交的版本替换工作目录中的文件，丢弃本地的修改，后者仅将文件从暂存区中移除。  




