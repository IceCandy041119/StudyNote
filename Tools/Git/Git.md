# GitNotes  

## 目录

- [关于版本控制](#关于版本控制)
- [Git简史](#Git简史)
- [Git介绍](#Git介绍)
- [Git配置](#Git配置)
- [命令](#命令)
- [QA](#QA)

## 关于版本控制  

版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
它有着以下阶段
- [本地版本控制系统](#本地版本控制系统)
- [集中化的版本控制系统](#集中化的版本控制系统)
- [分布式版本控制系统](#分布式的版本控制系统)

### 本地版本控制系统  

**起因**：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。  
**结果**：为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 [RCS](https://www.gnu.org/software/rcs/)的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。
**缺点**：当本地机器损坏，又没有恰当的备份，你将丢失所有数据

### 集中化的版本控制系统  

**起因**：人们又遇到一个问题，如何让在不同系统上的开发者协同工作？  
**结果**：于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS,Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。  
**缺点**：当中央服务器的单点故障，谁也无法提交更新，也就无法协同工作。如果中心数据库所在磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据--包括项目整个的变更历史，只剩下人们在各自机器上保留的单独快照。  

### 分布式版本控制系统  

**起因**：为了解决上面两者的缺点  
**结果**：分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。在这类系统中，像Git，Mercurial以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。  
**优点**：**任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。** 因为每一次的克隆操作，实际上都是对代码仓库的完整备份。**更进一步，许多这类系统都可以指定和若干不同的远端代码交互。** 籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流层，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。  

## Git简史  

**创建年代**：2005年
**创建原因**：Linux内核开源项目有着为数众多的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002),到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权利。这就迫使Linux开源社区(特备是Linux的缔造者Linux Torvalds)基于使用BitKeeper时的经验教训，开发出自己的版本系统。他们对新的系统制定了若干目标：
- 速度
- 简单的设计
- 对非线性开发模式的强力支持(允许成千上万个并行开发的分支)
- 完全分布式
- 有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)   

**结果**：自诞生于2005年以来，Git日臻成熟完善，在高度易用的同时，仍然保留初期设定的目标。它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统  

>BitKeeper之所以不让社区继续使用的原因是有位开发者破解了它的协议被公司发现了于是停止了合作，据说Git的开发用了两周就写完了。  

## Git介绍  

>**注意！！！**：在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS，Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。  

### 直接记录快照，而非差异比较  

Git 和其它版本控制系统（包括 Subversion 和近似工具）的**主要差别在于 Git 对待数据的方式。**  

从**概念**上来说，**其它大部分系统**：以**文件变更列表**的方式存储信息，这类系统（CVS，Subversion，Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。

Git 不按照以上方式对待或保存数据。反之，**Git 更像是把数据看作是对小型文件系统的一系列快照。** 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 **为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。** Git 对待数据更像是一个 **快照流。**  

Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS工具。  

### 近乎所有操作都是本地执行  

在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。  

### Git 保持完整性  

**Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。** 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。

**Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。** 基于 Git 中文件的内容或目录结构计算出来。如：  `24b9da6552552987aa493b52f8696cd6d3b00373`  

**实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。**  

### Git一般只添加数据  

你执行的 Git 操作，几乎只往 Git 数据库中 **添加** 数据。 你很难使用 Git 从数据库中**删除**数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。

>真要在快照里删除数据也行。

### 三种状态   

**Git有三种状态**：
- 已提交(committed)：表示修改了文件，但还没保存到数据库中。
- 已修改(modified)：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。
- 已暂存(staged)：表示数据已经安全地保存在了本地数据库中。

**Git项目的三个区**：
- 工作区：是对**某个版本独立**提取出来的内容，放在磁盘上供你修改或使用。
- 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。按照Git术语叫“索引”。
- Git目录：是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，克隆就是复制这里的数据。  

Git的工作流程：
1. 在工作区修改文件。
2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。
3. 提交更新，找到暂存区文件，将快照永久性存储到Git目录  

## Git配置  

Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在：
1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 `git config` 时带上 `--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）
2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。 你可以传递 `--global` 选项让 Git 读写此文件，这会对你系统上 **所有** 的仓库生效。
3. 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config` ）：针对该仓库。 你可以传递 `--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）

>每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量。  

你可以通过以下命令查看所有的配置以及它们所在的文件：
```$ git config --list --show-origin```  

安装完Git之后，要做的第一件事就是设置你的用户名和邮件地址。它们会写入到你的每一次提交中，不可更改：
`$ git config --global user.name <username>` 写入到 `~/.gitconfig`   
`$ git config --global user.email <useremail>` 写入到 `~/.gitconfig`  
想针对特定的项目使用特定的用户名和邮箱，可以在那个项目下运行没有 `--global` 的选项命令来配置。 

接着需要配置文本编辑器  
`$ git config --global core.editor <editor>` 配置文本编辑器  

`git config --list` 检查配置信息  
>可能会有重复，因为会从不同文件读取同一个配置。    

`git config <key>` 检查Git的某一项配置

## 获取帮助  

有三种方式可以找到Git命令的综合手册：
- `$ git help <verb>`  
- `$ git <verb> --help`
- `$ man git-<verb>`

你可以尝试在 [Freenode IRC](https://freenode.net/) 服务器上的 `#git` 或 `#github` 频道寻求帮助。  

此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 `-h` 选项获得更简明的手册

## 命令
### 基础命令  

- `git config --global user.name <username>` 刚安装时使用，进行用户签名
- `git config --global user.email <useremail>` 刚安装时使用，进行用户签名
- `git config --global core.editor <editor>` 配置文本编辑器
- `git init` 初始化本地仓库   
- `git status` 查看本地库状态  
- `git add <filename>` 添加到暂存区  
- `git commit <filename>` 提交到本地库
- `git help <command>` 获取git命令的帮助信息
- `git diff <filename>` 显示与暂存区文件的差异  
- `git diff <revision> <filename>` 显示某个文件两个版本之间的差异  

### 查看日志命令

- `git log` 显示历史日志  
  - `git log --all --graph --decorate` 可视化历史记录（有向无环图）  
- `git reflog` 查看reflog信息  

### 分支和合并

- `git branch` 显示分支  
- `git branch <name>` 创建分支  
- `git merge <revision>` 合并到当前分支  
- `git mergetool` 使用工具来处理冲突  
- `git rebase` 将一系列补丁变基为新的基线  
- `git checkout <revision>` 更新HEAD和目前的分支  
  - `git checkout -b <name>` 创建并切换分支
- `git reset --hard <revision>` 重置HEAD指针到指定的提交  

### 远端操作  

- `git remote` 列出远端  
- `git remote add <name> <url>` 添加一个远端  
- `git push <remote> <local branch>:<remote branch>` 将对象传送至远端并更新远端引用  
- `git branch --set-upstream-to <remote>/<remote branch>` 创建本地和远端分支的关联关系  
- `git fetch` 从远端获取对象/索引  
- `git pull` 相当于git fetch;git merge  
- `git clone <url>` 从远端下载仓库  

### 撤销

- `git commit --amend` 编辑提交的内容或信息  
- `git reset HEAD <filename>` 恢复暂存文件  
- `git checkout -- <filename>` 丢弃修改  
- `git restore` git2.32 版本后取代 git reset 进行许多撤销操作  

### 高级操作  

- `git config` Git 是一个高度可定制的工具  
- `git clone --depth=1` 浅克隆(shallow clone)，不包括完整的版本历史信息  
- `git add -p` 交互式暂存  
- `git rebase -i` 交互式变基  
- `git blame` 查看最后修改某行的人  
- `git stash` 暂时移除工作目录下的修改内容  
- `git bisect` 通过二分查找搜索历史记录  
- `.gitignore` 指定故意不追踪的文件(不是命令，是dot file)  

## QA  

>**1. `log` 与 `reflog` 的区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`log` 显示当前HEAD及其祖先。也就是说，它会打印HEAD指向的提交，然后是其父级、其父级的父级...。它会通过递归查找每个提交的父级来遍历存储库的祖先。`reflog` 不会遍历HEAD的祖先，它是HEAD指向的提交的有序列表，是存储库的撤销历史记录，它不是存储库本身的一部分（它与提交本身分开存储），也不包含在推送，提取或克隆中，它纯粹是本地的。  
>另外：了解 `reflog` 意味着一旦提交，就不会真正丢失在存储库里的数据。如果不小心重置为较旧的版本，或错误的重新设置了基数，或任何其他直观地“删除”操作，都可以使用 `reflog` 查看之前的位置，然后通过 `git reset --hard <hashkey>` 返回该引用以恢复之前的状态。引用不止意味着提交，也意味着背后整个的历史记录，但reflog条目并不会永久保留，但错误至少在两周内会是安全的  

>**2. `checkout` 与 `reset --hard` 的区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者只去更新HEAD指针，列如，在使用时，从主线切换到其他地方，只有HEAD指针去移动，而后者，则将主线指针也一并带了过来，为此可能会出现丢失数据的情况，就要用到 `reflog` 了  

>**3. `checkout -- <filename>` 与 `reset HEAD <filename>` 区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者如果文件没有添加到缓存区，那么将最近一次提交的版本替换工作目录中的文件，丢弃本地的修改，后者仅将文件从暂存区中移除  




