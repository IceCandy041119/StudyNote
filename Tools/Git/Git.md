# GitNotes  

## 目录

- [关于版本控制](#关于版本控制)
- [Git简史](#Git简史)
- [Git介绍](#Git介绍)
- [Git配置](#Git配置)
- [Git基础](#Git基础)
- [Git分支](#Git分支)
- [服务器上的Git](#服务器上的Git)
- [分布式Git](#分布式Git)
- [命令](#命令)
- [获取帮助](#获取帮助)
- [QA](#QA)

## 关于版本控制  

版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
它有着以下阶段
- [本地版本控制系统](#本地版本控制系统)
- [集中化的版本控制系统](#集中化的版本控制系统)
- [分布式版本控制系统](#分布式的版本控制系统)

### 本地版本控制系统  

**起因**：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。  
**结果**：为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 [RCS](https://www.gnu.org/software/rcs/)的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。   
**缺点**：当本地机器损坏，又没有恰当的备份，你将丢失所有数据。

### 集中化的版本控制系统  

**起因**：人们又遇到一个问题，如何让在不同系统上的开发者协同工作？   
**结果**：于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS,Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。  
**缺点**：当中央服务器的单点故障，谁也无法提交更新，也就无法协同工作。如果中心数据库所在磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据--包括项目整个的变更历史，只剩下人们在各自机器上保留的单独快照。  

### 分布式版本控制系统  

**起因**：为了解决上面两者的缺点  
**结果**：分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。在这类系统中，像Git，Mercurial以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。  
**优点**：**任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。** 因为每一次的克隆操作，实际上都是对代码仓库的完整备份。**更进一步，许多这类系统都可以指定和若干不同的远端代码交互。** 籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流层，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。  

## Git简史  

**创建年代**：2005年    
**创建原因**：Linux内核开源项目有着为数众多的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002),到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权利。这就迫使Linux开源社区(特备是Linux的缔造者Linux Torvalds)基于使用BitKeeper时的经验教训，开发出自己的版本系统。他们对新的系统制定了若干目标：
- 速度
- 简单的设计
- 对非线性开发模式的强力支持(允许成千上万个并行开发的分支)
- 完全分布式
- 有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)   

**结果**：自诞生于2005年以来，Git日臻成熟完善，在高度易用的同时，仍然保留初期设定的目标。它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。  

>BitKeeper之所以不让社区继续使用的原因是有位开发者破解了它的协议被公司发现了于是停止了合作，据说Git的开发用了两周就写完了。  

## Git介绍  

>**注意！！！**：在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS，Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。  

### 直接记录快照，而非差异比较  

Git 和其它版本控制系统（包括 Subversion 和近似工具）的**主要差别在于 Git 对待数据的方式。**  

从**概念**上来说，**其它大部分系统**：以**文件变更列表**的方式存储信息，这类系统（CVS，Subversion，Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。

Git 不按照以上方式对待或保存数据。反之，**Git 更像是把数据看作是对小型文件系统的一系列快照。** 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 **为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。** Git 对待数据更像是一个 **快照流。**  

Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS工具。  

### 近乎所有操作都是本地执行  

在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。  

### Git 保持完整性  

**Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。** 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。

**Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。** 基于 Git 中文件的内容或目录结构计算出来。如：  `24b9da6552552987aa493b52f8696cd6d3b00373`  

**实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。**  

### Git一般只添加数据  

你执行的 Git 操作，几乎只往 Git 数据库中**添加**数据。 你很难使用 Git 从数据库中**删除**数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。

>真要在快照里删除数据也行。

### 三种状态   

**Git有三种状态**：
- 已提交(committed)：表示修改了文件，但还没保存到数据库中
- 已修改(modified)：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中
- 已暂存(staged)：表示数据已经安全地保存在了本地数据库中

**Git项目的三个区**：
- 工作区：是对**某个版本独立**提取出来的内容，放在磁盘上供你修改或使用
- 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。按照Git术语叫“索引”
- Git目录：是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，克隆就是复制这里的数据   

Git的工作流程：
1. 在工作区修改文件
2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区
3. 提交更新，找到暂存区文件，将快照永久性存储到Git目录  

## Git配置  

### 初次运行Git 

Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在：
1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 `git config` 时带上 `--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）
2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。 你可以传递 `--global` 选项让 Git 读写此文件，这会对你系统上**所有**的仓库生效
3. 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config` ）：针对该仓库。 你可以传递 `--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效）

>每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量。  

你可以通过以下命令查看所有的配置以及它们所在的文件：
```$ git config --list --show-origin```  

安装完Git之后，要做的第一件事就是设置你的用户名和邮件地址。它们会写入到你的每一次提交中，不可更改：
`$ git config --global user.name <username>` 写入到 `~/.gitconfig`   
`$ git config --global user.email <useremail>` 写入到 `~/.gitconfig`  
想针对特定的项目使用特定的用户名和邮箱，可以在那个项目下运行没有 `--global` 的选项命令来配置。 

接着需要配置文本编辑器  
`$ git config --global core.editor <editor>` 配置文本编辑器  

`git config --list` 检查配置信息  

>可能会有重复，因为会从不同文件读取同一个配置。    

`git config <key>` 检查Git的某一项配置     
如 `git config user.name`    
### .gitignore

`.gitignore` 忽略文件，格式规范如下：
- 所有空行或者以 `#` 开头的行都会被Git忽略
- 可以使用标准的glob模式匹配，它会递归地应用在整个工作区中
- 匹配模式可以以( `/` )开头防止递归
- 匹配模式可以以( `/` )结尾指定目录
- 要忽略指定模式以外的文件或目录，可以在模式前加个叹号( `!` )取反   
>**glob模式**      
>指shell所使用的简化了的正则表达式。星号( `*` )匹配零个或多个任意字符， `[abc]`  匹配任何一个列在方括号中的字符，问号( `?` )只匹配一个任意字符，如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配( `[0-9]` 表示匹配0到9的数字)。使用两个星号( `**` )表示匹配任意中间目录，如 `a/**/z` 可以匹配 `a/z` `a/b/z`等。  

[GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表](https://github.com/github/gitignore)  

### Git别名  

可以用 `git config --global alias.<alias> <command>` 来设置别名。   

在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：

```console
$ git config --global alias.unstage 'reset HEAD --'
```

可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 `!` 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 `git visual` 定义为 `gitk` 的别名：

```console
$ git config --global alias.visual '!gitk'
```


## Git基础  

### Git仓库
通常用两种获取Git项目仓库的方式：
1. 利用 `git init` 命令将尚未进行版本控制的本地目录转换为Git仓库
2. 利用 `git clone <url> <name>` 命令从其他服务器克隆一个已存在的Git仓库   

### 更新
工作目录下的每一个文件都不外乎这两种状态：
- 已跟踪：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是[未修改、已修改或已放入暂存区](#三种状态)，总之，它是Git已知道的文件。
- 未跟踪：除了已跟踪文件外就是未跟踪文件，既不存在于上次的快照记录中，也没有被放入暂存区。

可以用 `git status` 命令检查哪些文件都处于什么状态。
- 可以加 `-s\--short` 参数，用简洁的方式查看更改，简短会将状态变为两栏，左栏为暂存区的状态，右栏为工作区的状态。  

可以用 `git add <files>` 命令去跟踪一个文件，将文件添加至暂存区，把有冲突的文件标记为已解决状态。**已暂存的文件若修改，则需再次使用该命令，提交时只会提交最后一次使用该命令的文件版本。** 使用文件或目录的路径作为参数，如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。名字可以用通配符。  

可以用 `git diff` 命令查看已暂存和未暂存的修改。
- 不加参数，查看尚未暂存的文件更新了哪些部分
- 加 `--staged` 参数，这条命令将比对已暂存文件与最后一次提交的文件差异
- 使用 `git difftool --tool-help` 命令来看你的系统都支持哪些git diff插件   

>**注意**，`git diff` 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 `git diff` 后却什么也没有，就是这个原因。  

可以用 `git commit` 命令去提交一个快照。
- 加 `-m` 参数，将提交信息与命令放在同一行
- 加 `-a` 参数，自动把所有已经更新过的文件暂存起来一并提交，从而跳过 `git add` 步骤

可以用 `git rm <files>` 命令去移除某个文件。
- 加 `-f` 参数，去强制删除之前修改过或已经放到暂存区的文件
- 加 `--cached` 参数，只从暂存区域中移除     

>`git rm` **命令后面可以列出文件或者目录的名字，也可以使用 `glob` 模式。比如**：
>`$ git rm log/\*.log`   
>**注意到星号 `*` 之前的反斜杠 `\`， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用shell 来帮忙展开。** 此命令删除 `log/` 目录下扩展名为 `.log` 的所有文件。 类似的比如：~  
>`$ git rm \*~`   
>该命令会删除所有名字以 `~` 结尾的文件。   

可以用 `git mv <source> <destination>` 命令来对文件改名。   
相当于   
```
mv <source> <destination>  
git rm <source>  
git add <destination>  
```

### 查看提交历史   

可以使用 `git log` 命令查看提交历史。   
- 没有参数的情况下，会按时间先后顺序列出所有的提交，最近的更新排在最上面
- 加 `-p\--patch` 参数，它会按补丁格式显示出每个提交所引入的差异
- 加 `-n` 参数，显示最近n次提交
- 加 `--stat` 参数，查看提交的简略统计信息
	- `--shortstat` 参数，只显示最后的行数修改统计
- 加 `--name-only` 仅在提交信息后显示以修改的文件清单
- 加 `--name-status` 显示新增、修改、删除的文件清单
- 加 `--abbrev-commit` 仅显示SHA-1校验和所有40个字符中的前几个字符
- 加 `--relative-date` 使用较短的相对时间而不是完整格式显示日期(如"2 weeks age")
- 加 `--pretty` 参数，可以使用不同的默认格式的方式展示提交历史
	- `--pretty=oneline` 将每个提交放在一行显示
	- `--pretty=short` 
	- `--pretty=full` 
	- `--pretty=fuller` 
	- `--pretty=format` 定制记录的显示格式
- 加 `--graph` 参数，在日志旁以ASCII图形显示分支与合并记录
- 加 `--since\--after` 参数，仅显示指定时间之后的提交
- 加 `--until\--before` 参数，仅显示指定时间之前的提交
- 加 `--committer` 参数，仅显示提交者匹配指定字符串的提交
- 加 `--author` 参数，显示指定作者匹配指定字符串的提交
- 加 `--grep` 参数，仅显示提交说明中包含指定字符出的提交 
- 加 `-S <string>` 参数，仅显示添加或删除内容匹配指定字符串的提交
- 加 `-- <path>` 参数，查找某些文件或目录的提交
- 加 `--no-merges` 选项，隐藏合并提交
- 加 `--decorate` 查看各个分支当前所指的对象   

>你可以指定多个 `--author` 和 `--grep` 搜索条件，这样会只输出匹配**任意** `--author` 模式和**任意** `--grep` 模式的提交。然而，如果你添加了 `--all-match` 选项， 则只会输出匹配**所有** `--grep` 模式的提交。

>**作者与提交者**  
>作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。  

>其实也并不是在任何情况下都是所有，但你用 `git reset --hard` 切换到旧记录，此时并不会显示所有提交，因为这时的master分支跑到了旧分支， `log` 按分支节点递归查找，所有会丢失后面的提交。 

表1. format常用格式

| 选项    | 说明                          |
| ----- | --------------------------- |
| `%H`  | 提交的完整哈希值                    |
| `%h`  | 提交的简写哈希值                    |
| `%T`  | 树的完整哈希值                     |
| `%t`  | 树的简写哈希值                     |
| `%P`  | 父提交的完整哈希值                   |
| `%p`  | 父提交的简写哈希值                   |
| `%an` | 作者名字                        |
| `%ae` | 作者的电子邮件地址                   |
| `%ad` | 作者修订日期（可以用 --date=选项 来定制格式） |
| `%ar` | 作者修订日期，按多久以前的方式显示           |
| `%cn` | 提交者的名字                      |
| `%ce` | 提交者的电子邮件地址                  |
| `%cd` | 提交日期                        |
| `%cr` | 提交日期（距今多长时间）                |
| `%s`  | 提交说明                        |

### 撤销

>**注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。**   

可以用 `git commit --amend` 命令覆盖上一次的提交。

>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。   

可以用 `git reset HEAD <file>` 命令来取消暂存。  

>`git reset` 确实是个危险的命令，如果加上了 `--hard` 选项则更是如此。然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。   

可以用 `git checkout -- <file>` 命令来撤销文件的修改。  

>请务必记得 `git checkout — <file>` 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。   

>记住，在 Git 中任何**已提交**的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 `--amend` 选项覆盖的提交也可以恢复。然而，任何你未提交的东西丢失后很可能再也找不到了。    

### 远程仓库   

**介绍**：远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 **管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪**等等。   

>**远程仓库可以在你的本地主机上**   
>你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。

可以用 `git remote` 命令去查看你已经配置的远程仓库服务器。
- 加 `-v` 参数，会显示需要读写远程仓库使用的简写与其对应的URL  

可以用 `git remote add <shortname> <url>` 命令添加一个新的远程Git仓库。同时指定一个方便的简写。   

可以用 `git fetch <remote>` 命令从远程仓库中获得数据，这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。  

>必须注意 `git fetch` 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。   

可以用 `git pull` 命令来自动抓取后台合并该远程分支到当前分支。     

>前提是你的当前分支设置了跟踪远程分支，默认情况下，`git clone` 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 `master` 分支（或其它名字的默认分支）。    

可以用 `git push` 命令将本地进度推送到上游。    

>必须要有写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。   

可以用 `git remote show <remote>` 命令去查看一个远程仓库的更多信息。 

可以用 `git remote <rename>` 命令修改一个远程仓库的简写名。   

可以用 `git remote remove <remotename>` 命令可以去移除一个远程仓库。   

### 标签  

可以用 `git tag -l\--list` 命令以字母顺序列出已有的标签。  

>默认的 `git tag` 给出的就是完整的标签列表，要用通配符的话，需要有 `-l\--list` 参数。   

标签有两种：
- 轻量标签：很像一个不会改变的分支——它只是某个特定提交的引用。  
- 附注标签：是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard (GPG)签名并验证。   

>通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。  

#### 附注标签  

可以用 `git tag -a <tag> -m <message>` 创建， `-m` 指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会启动编辑器要求你输入信息。

可以用 `git show <tagname>` 命令查看标签信息与和与之对应的提交信息。  

#### 轻量标签   

轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。   

创建轻量标签，不需要使用 `-a`，`-s` 或 `-m` 选项，只需要提供标签名字。如   
`git tag v1.1`   

这时用 `git show <tagname>` 只会显示提交提交信息。    

#### 后期打标签  

可以用 `git tag -a <tagname> <hashkey>` 给特定的记录打上标签。  

#### 共享标签  

默认情况下，`git push` 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。   
可以用 `git push <remotename> <tagname>` 进行推送。
- 加 `-tags` 参数，把所有不在远程仓库服务器上的标签全部传送到那里。   

>使用 `git push <remote> --tags` 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。  

#### 删除标签   

可以用 `git tag -d <tagname>` 删除本地仓库上的标签。

>上述命令并不会从任何远程仓库中移除这个标签。

可以用 `git push <remote> :refs/tags/<tagname>` 或者 `git push <remote> --delete <tagname>` 命令，去删除远程仓库的标签。   

>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。   

#### 检出标签  

可以用 `git checkout <tagname>` 去查看某个标签所指向的文件版本。

>这会使你的仓库处于“**分离头指针（detached HEAD）**”的状态——这个状态有些不好的副作用：**在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。**  

## Git分支   

### 分支简介  

有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。     

在进行提交操作时，Git 会保存一个**提交对象（commit object）**。 知道了 Git 保存数据的方式，我们可以很自然的想到——该**提交对象会包含一个指向暂存内容快照的指针**。但不仅仅是这样，该提交对象**还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。**   

>**首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。**  

暂存操作会为每一个文件计算校验和(SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 (Git 使用 **blob 对象**来保存它们) 。   

当使用 `git commit` 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为**树对象**。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。   

**blob对象**：保存着文件快照。
**树对象**：记录着目录结构和blob 对象索引。 
**提交对象**：包含着指向前述树对象的指针和所有提交信息。

**Git 的分支，其实本质上仅仅是指向提交对象的可变指针。** Git 的默认分支名字是 `master`。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 `master` 分支。 `master` 分支会在每次提交时自动向前移动。

>Git 的 `master` 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 `git init` 命令默认创建它，并且大多数人都懒得去改动它。

**Git有一个名为 `HEAD` 的特殊指针。** 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 `HEAD` 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支。

>`HEAD` 会如同你的影子一般跟随你   
>PS：一次就好，我带你去看天荒地老～   

由于 Git 的分支实质上仅是包含所指对象校验和(长度为 40 的 SHA-1 值字符串)的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节(40 个字符和 1 个换行符），如此的简单能不快吗?      

### 分支的创建与合并   

可以用 `git branch <branchname>` 创建分支。   
- 加 `-d` 参数，可以删除分支
- 加 `-D` 参数，可以强制删除分支  

可以用 `git checkout -b` 创建分支并切换过去。    

可以用 `git merge` 命令合并分支。    

>合并时使用三方合并——两个分支所指的快照以及这两个分支的公共祖先。

>当合并时，要合并的分支是当前分支的直接后继，那么Git会直接将指针向前移动。因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。     

>当合并分支时，不同的分支都涉及了对同一个文件的同一个部分进行了不同的修改，那么合并时会产生合并冲突。**任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记**，这样你可以打开这些包含冲突的文件然后手动解决冲突。   

### 分支管理    

可以用 `git branch` 命令查看分支列表。    
- 加 `-v` 参数，查看每一个分支的最后一次提交
- 加 `--merged` 参数，查看已经合并的分支   
- 加 `--no-merged` 参数，查看尚未合并的分支  

>上面描述的选项 `--merged` 和 `--no-merged` 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 **当前** 分支的分支。你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。   

### 远程分支      

#### 远程跟踪分支   

**远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用**。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。它们以 `<remote>/<branch>` 的形式命名。     

可以用 `git push <remote> <branch>` 命令将本地的分支推送到远端分支。
- `git push <remote> <branch>:<remotebranch>` 命令将本地的分支推送到远端 `<remotebranch>` 上

可以用 `git ls-remote <remote>` 命令来显式地获得远程引用的完整列表。   

> [!tip] 抓取远程分支时    
> 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 `serverfix` 分支——只有一个不可以修改的 `origin/serverfix` 指针。
#### 跟踪分支  

从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”(它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 `git pull`，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。

可以用 `git checkout --track <remotebranch>` 命令跟踪远端分支。   
- `git checkout -b <branch> <remote>/<branch>` 创建一个分支跟踪远端分支  

> [!tip]
> 如果你尝试检出的本地分支不存在且远端分支刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支。

> [!tip] 上游快捷方式    
>当设置好跟踪分支后，可以通过简写 `@{upstream}` 或 `@{u}` 来引用它的上游分支。 所以在 `master` 分支时并且它正在跟踪 `origin/master` 时，如果愿意的话可以使用 `git merge @{u}` 来取代 `git merge origin/master`。

可以用 `git branch -vv` 命令根据本地数据查看所有跟踪分支以及进度。

> [!tip] 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：    
>
>```console
>$ git fetch --all; git branch -vv
>```

#### 拉取  

当 `git fetch` 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。    

有一个命令叫作 `git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令。   

>由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些。   

#### 删除远端分支  

可以用 `git push <remote> --delete <remotename>` 删除一个远端分支。

### 变基    

在 Git 中整合来自不同分支的修改主要有两种方法：
- `merge` 合并：详见[分支的创建与合并](#分支的创建与合并)
- `rebase` 变基：将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。  

> [!tip] 原理    
> 首先找到这两个分支的最近共同祖先，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底，最后以此将之前另存为临时文件的修改依序应用。

`git rebase --onto <目标基底分支> <旧的基底分支> <要移动的分支>` 将要移动的分支从旧的基底分支分离出来变基到目标基底分支。   

`git rebase <basebranch> <topicbranch>` 命令可以直接将主题分支变基到目标分支上。   

变基完成后，进行合并。     

> [!warning] 奇妙的变基也并非完美无缺，要用它得遵守一条准则      
> 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。

**变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。**  

> [!tip] 如果你在多人协作的仓库上使用了变基--用变基解决变基     
> 实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 "patch-id"。如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。  
> 举个例子，如果遇到前面提到的有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交那种情境，如果我们不是执行合并，而是执行 `git rebase <remote>/<branch>`, Git 将会：
> - 检查哪些提交是我们的分支上独有的
> - 检查其中哪些提交不是合并操作的结果
> - 检查哪些提交在对方覆盖更新时并没有被纳入目标分支
> - 把查到的这些提交应用在远程分支上面     
> 
>也可以用 `git pull --rebase` 命令，代替 `git fetch;git rebase` 命令。

> [!tip] 变基 vs. 合并      
> 变基会该改变提交的记录，合并不会，为此，根据自己的需求选择合适的方式。
> > [!warning] 但记住      
> > 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。

## 服务器上的Git   

一个远程仓库通常只是一个裸仓库(bare repository)——即一个没有当前工作目录的仓库。因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照；存放的只有Git的资料。即只有 `.git` 子目录的内容，不包含其他资料。    

一般的做法里，会同时提供SSH或者HTTPS协议的访问服务，只让少数几个开发者有推送(写)权限，其他人通过 `git://` 访问只有读权限。

### 协议   

Git可以使用四种不同的协议来传输资料：
- 本地协议(Local protocol)
- HTTP协议
- SSH协议(Secure Shell)
- Git协议

#### 本地协议(Local protocol)    

最基本的就是本地协议，其中的远程版本库就是同一主机上的另一个目录。这常见于团队每一个成员都对一个共享的文件系统(例如一个挂载的NFS)拥有访问权，或者比较少见的多人共用同一台电脑的情况。后者并不理想，因为你的所有代码版本库如果长存于同一台电脑，更可能发生灾难性的损失。     

如果你使用共享文件系统，就可以从本地版本库克隆(clone）、推送(push)以及拉取(pull）。 像这样去克隆一个版本库或者增加一个远程到现有的项目中，**使用版本库路径作为 URL**。 例如，克隆一个本地版本库，可以执行如下的命令：    
`$ git clone /srv/git/project.git`     
或你可以执行这个命令：  
`$ git clone file:///srv/git/project.git`     

> [!tip]    
>如果在 URL 开头明确的指定 `file://`，那么 Git 的行为会略有不同。   
>如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。  
>如果指定 `file://`，Git 会触发平时用于网路传输资料的进程，那样传输效率会更低。  
>指定 `file://` 的主要目的是取得一个没有外部参考(extraneous references)或对象(object)的干净版本库副本——通常是在从其他版本控制系统导入后或一些类似情况需要这么做      

要增加一个本地版本库到现有的 Git 项目，可以执行如下的命令：     
`$ git remote add local_proj /srv/git/project.git`       

**优点**   
- 简单
- 直接使用了现有的文件权限和网络访问权限    

**缺点**      
- 通常共享文件系统比较难配置
- 比起基本的网络连接访问，这不方便从多个位置访问
- 相比网络连接的访问方式，配置不方便，速度也慢
- 不保护仓库避免意外的损失，每一个用户都有完整的权限，没有方法可以阻止他们修改或删除Git内部文件和损坏仓库

#### HTTP协议  

**Git 通过 HTTP 通信有两种模式**。在 Git 1.6.6 版本之前只有一个方式可用，十分简单并且通常是只读模式的。Git 1.6.6 版本引入了一种新的、更智能的协议，让 Git 可以像通过 SSH 那样智能的协商和传输数据。 之后几年，这个新的 HTTP 协议因为其简单、智能变的十分流行。 新版本的 HTTP 协议一般被称为**智能**HTTP 协议，旧版本的一般被称为**哑**HTTP 协议。   

**智能HTTP协议**    
智能HTTP的运行方式和SSH及Git协议类似，只是运行在标准的HTTP/S端口上并且可以使用各种HTTP验证机制， 这意味着使用起来会比SSH协议简单的多，比如可以使用HTTP协议的用户名/密码授权，免去设置SSH公钥。     
智能HTTP协议或许已经是最流行的使用Git的方式了，它既支持像 `git://` 协议一样设置匿名服务， 也可以像SSH协议一样提供传输时的授权和加密。而且只用一个URL就可以都做到，省去了为不同的需求设置不同的URL。如果你要推送到一个需要授权的服务器上(一般来讲都需要），服务器会提示你输入用户名和密码。 从服务器获取数据时也一样。

**哑HTTP协议**   
如果服务器没有提供智能HTTP协议的服务，Git 客户端会尝试使用更简单的“哑”HTTP协议。 哑HTTP协议里web服务器仅把裸版本库当作普通文件来对待，提供文件服务。哑HTTP协议的优美之处在于设置起来简单。基本上，只需要把一个裸版本库放在HTTP根目录，设置一个叫做 `post-update` 的挂钩就可以了。    

通常的，会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个。 极少会将二者混合提供服务。   

**优点——我们将只关注智能 HTTP 协议的优点**     
- 不同的访问方式只需要一个URL以及服务器只在需要授权时提示输入授权信息，这两个简便性让终端用户使用Git变得非常简单
- 相比SSH协议，可以使用用户名／密码授权是一个很大的优势，这样用户就不必须在使用Git之前先在本地生成SSH密钥对再把公钥上传到服务器。 对非资深的使用者，或者系统上缺少SSH相关程序的使用者，HTTP协议的可用性是主要的优势。
- 与SSH协议类似，HTTP协议也非常快和高效
- 你也可以在HTTPS协议上提供只读版本库的服务，如此你在传输数据的时候就可以加密数据；或者，你甚至可以让客户端使用指定的 SSL 证书
- HTTPS协议被广泛使用，一般的企业防火墙都会允许这些端口的数据通过

**缺点**    
- 在一些服务器上，架设HTTPS协议的服务端会比SSH协议的棘手一些。除了这一点，用其他协议提供Git服务与智能HTTP协议相比就几乎没有优势了
- 如果你在HTTP上使用需授权的推送，管理凭证会比使用SSH密钥认证麻烦一些。 然而，你可以选择使用凭证存储工具，比如macOS的Keychain或者Windows的凭证管理器   

#### SSH协议

架设Git服务器时常用SSH协议作为传输协议。 因为大多数环境下服务器已经支持通过SSH访问 —— 即使没有也很容易架设。SSH协议也是一个验证授权的网络协议；并且，因为其普遍性，架设和使用都很容易。

通过SSH协议克隆版本库，你可以指定一个 `ssh://` 的URL：
`$ git clone ssh://[user@]server/project.git`     
或者使用一个简短的scp式的写法：   
`$ git clone [user@]server:project.git`    
在上面两种情况中，如果你不指定可选的用户名，那么 Git 会使用当前登录的用户的名字。      

**优点**    
- SSH 架设相对简单 —— SSH 守护进程很常见，多数管理员都有使用经验，并且多数操作系统都包含了它及相关的管理工具
- 通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密
- 与 HTTPS 协议、Git 协议及本地协议一样，SSH 协议很高效，在传输前也会尽量压缩数据

**缺点**   
- 在于它不支持匿名访问 Git 仓库   

#### Git协议     

这是包含在Git里的一个特殊的守护进程；它监听在一个特定的端口(9418），类似于SSH服务，但是访问无需任何授权。要让版本库支持Git协议，需要先创建一个 `git-daemon-export-ok` 文件——它是Git协议守护进程为这个版本库提供服务的必要条件——但是除此之外没有任何安全措施。 要么谁都可以克隆这个版本库，要么谁也不能。    

**优点**   
- Git 协议是 Git 使用的网络传输协议里最快的
- 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销

**缺点**  
- 缺乏授权机制
-  Git 协议也许也是最难架设的，它要求有自己的守护进程，这就要配置 `xinetd`、`systemd` 或者其他的程序，这些工作并不简单。 它还要求防火墙开放 9418 端口，但是企业防火墙一般不会开放这个非标准端口。 而大型的企业防火墙通常会封锁这个端口。

### 在服务器上搭建Git   

在开始架设Git服务器前，需要把现有仓库导出为裸仓库——即一个不包含当前工作目录的仓库。 这通常是很简单的。 为了通过克隆你的仓库来创建一个新的裸仓库，你需要在克隆命令后加上 `--bare` 选项。按照惯例，裸仓库的目录名以 .git 结尾   

整体上效果大致相当于 `$ cp -Rf my_project/.git my_project.git`   

虽然在配置文件中有若干不同，但是对于你的目的来说，这两种方式都是一样的。 它只取出 Git 仓库自身，不要工作目录，然后特别为它单独创建一个目录。 

既然你有了裸仓库的副本，剩下要做的就是把裸仓库放到服务器上并设置你的协议。    

>如果一个用户，通过使用 SSH 连接到一个服务器，并且其对 `/srv/git/my_project.git` 目录拥有可写权限，那么他将自动拥有推送权限。 

如果只是和几个人在一个私有项目上合作的话,仅仅是一个SSH服务器和裸仓库就足够了。   

**小型安装**    
如果设备较少或者你只想在小型开发团队里尝试 Git ，那么一切都很简单。 架设 Git 服务最复杂的地方在于用户管理。 如果需要仓库对特定的用户可读，而给另一部分用户读写权限，那么访问和许可安排就会比较困难。   

**SSH连接**    
如果需要团队里的每个人都对仓库有写权限，又不能给每个人在服务器上建立账户，那么提供 SSH 连接就是唯一的选择了。 我们假设用来共享仓库的服务器已经安装了 SSH 服务，而且你通过它访问服务器。   
有几个方法可以使你给团队每个成员提供访问权：
1. 就是给团队里的每个人创建账号，这种方法很直接但也很麻烦。 或许你不会想要为每个人运行一次 `adduser`(或者 `useradd` )并且设置临时密码。
2. 是在主机上建立一个 'git' 账户，让每个需要写权限的人发送一个SSH公钥， 然后将其加入git账户的 `~/.ssh/authorized_keys` 文件。 这样一来，所有人都将通过 'git' 账户访问主机。 这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息。
3. 让SSH服务器通过某个LDAP服务，或者其他已经设定好的集中授权机制，来进行授权。 只要每个用户可以获得主机的shell访问权限，任何SSH授权机制你都可视为是有效的。   

### 生成SSH公钥   

如前所述，许多Git服务器都使用SSH公钥进行认证。 为了向Git服务器提供SSH公钥，如果某系统用户尚未拥有密钥，必须事先为其生成一份。 这个过程在所有操作系统上都是相似的。 首先，你需要确认自己是否已经拥有密钥。 默认情况下，用户的 SSH 密钥存储在其 `~/.ssh` 目录下。   

我们需要寻找一对以 `id_dsa` 或 `id_rsa` 命名的文件，其中一个带有 `.pub` 扩展名。 `.pub` 文件是你的公钥，另一个则是与之对应的私钥。 如果找不到这样的文件（或者根本没有 `.ssh` 目录），你可以通过运行 `ssh-keygen` 程序来创建它们。     

首先 `ssh-keygen` 会确认密钥的存储位置（默认是 `.ssh/id_rsa`），然后它会要求你输入两次密钥口令。 如果你不想在使用密钥时输入口令，将其留空即可。 然而，如果你使用了密码，那么请确保添加了 `-o` 选项，它会以比默认格式更能抗暴力破解的格式保存私钥。 你也可以用 `ssh-agent` 工具来避免每次都要输入密码。      

现在，进行了上述操作的用户需要将各自的公钥发送给任意一个Git服务器管理员 （假设服务器正在使用基于公钥的SSH验证设置）。 他们所要做的就是复制各自的 `.pub` 文件内容，并将其通过邮件发送。

### 配置服务器    

> [!note]
> 以下操作可通过 `ssh-copy-id` 命令自动完成，这样就不必手动复制并安装公钥了。  

首先，创建一个操作系统用户 `git`，并为其建立一个 `.ssh` 目录。    

接着，我们需要为系统用户 `git` 的 `authorized_keys` 文件添加一些开发者 SSH 公钥。 假设我们已经获得了若干受信任的公钥，并将它们保存在临时文件中。   

将这些公钥加入系统用户 `git` 的 `.ssh` 目录下 `authorized_keys` 文件的末尾。

现在我们来为开发者新建一个空仓库。可以借助带 `--bare` 选项的 `git init` 命令来做到这一点，该命令在初始化仓库时不会创建工作目录。

请注意，每添加一个新项目，都需要有人登录服务器取得shell，并创建一个裸仓库。    

需要注意的是，目前所有（获得授权的）开发者用户都能以系统用户 `git` 的身份登录服务器从而获得一个普通shell。 如果你想对此加以限制，则需要修改 `/etc/passwd` 文件中(`git` 用户所对应)的shell值。

借助一个名为 `git-shell` 的受限shell工具，你可以方便地将用户 `git` 的活动限制在与 Git 相关的范围内。 该工具随Git软件包一同提供。如果将 `git-shell` 设置为用户 `git` 的登录shell(login shell)， 那么该用户便不能获得此服务器的普通 shell 访问权限。 若要使用 `git-shell`，需要用它替换掉bash或csh，使其成为该用户的登录 shell。 为进行上述操作，首先你必须确保 `git-shell` 的完整路径名已存在于 `/etc/shells` 文件中。    
现在你可以使用 `chsh <username> -s <shell>` 命令修改任一系统用户的shell。这样，用户 `git` 就只能利用SSH连接对Git仓库进行推送和拉取操作，而不能登录机器并取得普通shell。 如果试图登录，你会发现尝试被拒绝。   

此时，用户仍可通过 SSH 端口转发来访问任何可达的 git 服务器。 如果你想要避免它，可编辑 `authorized_keys` 文件并在所有想要限制的公钥之前添加以下选项：     
```console
no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty
```

现在，网络相关的 Git 命令依然能够正常工作，但是开发者用户已经无法得到一个普通 shell 了。 正如输出信息所提示的，你也可以在 `git` 用户的主目录下建立一个目录，来对 `git-shell` 命令进行一定程度的自定义。 比如，你可以限制掉某些本应被服务器接受的 Git 命令，或者对刚才的 SSH 拒绝登录信息进行自定义，这样，当有开发者用户以类似方式尝试登录时，便会看到你的信息。 要了解更多有关自定义 shell 的信息，请运行 `git help shell`。     

### Git守护进程   

>请注意，因为其不包含授权服务，任何通过该协议管理的内容将在其网络上公开。     

如果运行在防火墙之外的服务器上，它应该只对那些公开的只读项目服务。 如果运行在防火墙之内的服务器上，它可用于支撑大量参与人员或自动系统 （用于持续集成或编译的主机）只读访问的项目，这样可以省去逐一配置 SSH 公钥的麻烦。   

无论何时，该 Git 协议都是相对容易设定的。 通常，你只需要以守护进程的形式运行该命令：

```console
$ git daemon --reuseaddr --base-path=/srv/git/ /srv/git/
```

`--reuseaddr` 选项允许服务器在无需等待旧连接超时的情况下重启，而 `--base-path` 选项允许用户在未完全指定路径的条件下克隆项目， 结尾的路径将告诉Git守护进程从何处寻找仓库来导出。 如果有防火墙正在运行，你需要开放端口9418的通信权限。    

由于在现代的Linux发行版中，`systemd` 是最常见的初始化系统，因此你可以用它来达到此目的。 只要在 `/etc/systemd/system/git-daemon.service` 中放一个文件即可，其内容如下：

```console
[Unit]
Description=Start Git Daemon

[Service]
ExecStart=/usr/bin/git daemon --reuseaddr --base-path=/srv/git/ /srv/git/

Restart=always
RestartSec=500ms

StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=git-daemon

User=git
Group=git

[Install]
WantedBy=multi-user.target
```

你可能会注意这里以 `git` 启动的Git驻留程序同时使用了Group和User权限。按需修改它并确保提供的用户在此系统上。此外，请确保Git二进制文件位于 `/usr/bin/git`，必要时可修改此路径。最后，你需要运行 `systemctl enable git-daemon` 以让它在系统启动时自动运行， 这样也能让它通过 `systemctl start git-daemon` 启动，通过 `systemctl stop git-daemon` 停止。     

在其他系统中，你可以使用 `sysvinit` 系统中的 `xinetd` 脚本，或者另外的方式来实现——只要你能够将其命令守护进程化并实现监控。    

接下来，你需要告诉 Git 哪些仓库允许基于服务器的无授权访问。 你可以在每个仓库下创建一个名为 `git-daemon-export-ok` 的文件来实现。    

```console
$ cd /path/to/project.git
$ touch git-daemon-export-ok
```

该文件将允许Git提供无需授权的项目访问服务。     

### Smart HTTP 

我们一般通过SSH进行授权访问，通过git:// 进行无授权访问，但是还有一种协议可以同时实现以上两种方式的访问。 设置Smart HTTP一般只需要在服务器上启用一个Git自带的名为 `git-http-backend` 的CGI脚本。 该CGI脚本将会读取由 `git fetch` 或 `git push` 命令向 HTTP URL发送的请求路径和头部信息， 来判断该客户端是否支持HTTP通信（不低于 1.6.6 版本的客户端支持此特性）。 如果CGI发现该客户端支持智能(Smart)模式，它将会以智能模式与它进行通信， 否则它将会回落到哑(Dumb)模式下(因此它可以对某些老的客户端实现向下兼容）。      

在完成以上简单的安装步骤后， 我们将用Apache来作为CGI服务器。 如果你没有安装 Apache，你可以在Linux环境下执行如下或类似的命令来安装：   

```console
$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env
```

该操作将会启用 `mod_cgi`， `mod_alias` 和 `mod_env` 等Apache模块， 这些模块都是使该功能正常工作所必须的。    

你还需要将 `/srv/git` 的Unix用户组设置为 `www-data`，这样 Web 服务器才能读写该仓库， 因为运行CGI脚本的Apache实例默认会以该用户的权限运行：     

```console
$ chgrp -R www-data /srv/git
```

接下来我们要向Apache配置文件添加一些内容，来让 `git-http-backend` 作为Web服务器对 `/git` 路径请求的处理器。     

```console
SetEnv GIT_PROJECT_ROOT /srv/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/
```

如果留空 `GIT_HTTP_EXPORT_ALL` 这个环境变量，Git将只对无授权客户端提供带 `git-daemon-export-ok` 文件的版本库，就像Git守护进程一样。     

最后，如果想让 Apache 允许 `git-http-backend` 请求并实现写入操作的授权验证，使用如下授权屏蔽配置即可：    

```console
<Files "git-http-backend">
    AuthType Basic
    AuthName "Git Access"
    AuthUserFile /srv/git/.htpasswd
    Require expr !(%{QUERY_STRING} -strmatch '*service=git-receive-pack*' || %{REQUEST_URI} =~ m#/git-receive-pack$#)
    Require valid-user
</Files>
```

这需要你创建一个包含所有合法用户密码的 `.htpasswd` 文件。 以下是一个添加 “schacon” 用户到此文件的例子：   

```console
$ htpasswd -c /srv/git/.htpasswd schacon
```

你可以通过许多方式添加Apache授权用户，选择使用其中一种方式即可。 以上仅仅只是我们可以找到的最简单的一个例子。 如果愿意的话，你也可以通过SSL运行它，以保证所有数据是在加密状态下进行传输的。   

>Apache的主要原理是使用一个Git附带的，名为 `git-http-backend` 的CGI。它被引用来处理协商通过HTTP发送和接收的数据。 它本身并不包含任何授权功能，但是授权功能可以在Web服务器层引用它时被轻松实现。 你可以在任何所有可以处理CGI的Web服务器上办到这点，所以随便挑一个你最熟悉的 Web 服务器试手吧。    

### GitWeb

如果你对项目有读写权限或只读权限，你可能需要建立起一个基于网页的简易查看器。 Git提供了一个叫做GitWeb的CGI脚本来做这项工作。     

如果你想要查看GitWeb如何展示你的项目，并且在服务器上安装了轻量级Web服务器比如 `lighttpd` 或 `webrick` ，Git提供了一个命令来让你启动一个临时的服务器。 在Linux系统的电脑上，`lighttpd` 通常已经安装了，所以你只需要在项目目录里执行 `git instaweb` 命令即可。 如果你使用Mac系统，Mac OS X Leopard系统已经预安装了Ruby，所以 `webrick` 或许是你最好的选择。 如果不想使用lighttpd启动 `instaweb` 命令，你需要在执行时加入 `--httpd` 参数。    

这个命令启动了一个监听1234端口的HTTP服务器，并且自动打开了浏览器。 这对你来说十分方便。 当你已经完成了工作并想关闭这个服务器，你可以执行同一个命令，并加上 `--stop` 选项。     

如果你现在想为你的团队或你托管的开源项目持续的运行这个页面，你需要通过普通的Web服务器来设置CGI脚本。 一些Linux发行版的软件库有 `gitweb` 包，可以通过 `apt` 或 `dnf` 来安装，你可以先试试。 接下来我们来快速的了解一下如何手动安装GitWeb。      

首先，你需要获得Git的源代码，它包含了GitWeb，并可以生成自定义的CGI脚本   
```console
$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/
$ make GITWEB_PROJECTROOT="/srv/git" prefix=/usr gitweb
    SUBDIR gitweb
    SUBDIR ../
make[2]: `GIT-VERSION-FILE' is up to date.
    GEN gitweb.cgi
    GEN static/gitweb.js
$ sudo cp -Rf gitweb /var/www/
```

>需要注意的是，你需要在命令中指定 `GITWEB_PROJECTROOT` 变量来让程序知道你的 Git 版本库的位置。   

现在，你需要在 Apache 中使用这个CGI脚本，你需要为此添加一个虚拟主机：

```console
<VirtualHost *:80>
    ServerName gitserver
    DocumentRoot /var/www/gitweb
    <Directory /var/www/gitweb>
        Options +ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
        AllowOverride All
        order allow,deny
        Allow from all
        AddHandler cgi-script cgi
        DirectoryIndex gitweb.cgi
    </Directory>
</VirtualHost>
```

### GitLab

GitLab是一个数据库支持的 web 应用，所以相比于其他 git 服务器，它的安装过程涉及到更多的东西。 幸运的是，这个过程有非常详细的文档说明和支持。   

**下载**：    
- 下载虚拟机镜像
- [bitnami获取一键安装包](https://bitnami.com/stack/gitlab) 同时调整配置使之符合你特定的环境。Bitnami的一个优点在于它的登录界面(通过alt+->键)，会告诉你安装好的GitLab的IP地址以及默认的用户名和密码

无论如何，跟着[GitLab社区版的readme](https://gitlab.com/gitlab-org/gitlab-ce/tree/master)文件一步步来，在这里你将会在主菜单中找到安装GitLab的帮助，一个可以在Digital Ocean上运行的虚拟机，以及RPM和DEB包（都是测试版）。 这里还有 “非官方” 的引导让GitLab运行在非标准的操作系统和数据库上，一个全手动的安装脚本，以及许多其他的话题。     

**管理**：    
GitLab 的管理界面是通过网络进入的。 将你的浏览器转到已经安装 GitLab 的 主机名或 IP 地址，然后以管理员身份登录即可。 默认的用户名是 `admin@local.host`，默认的密码是 `5iveL!fe`（你会得到类似 请登录后尽快更换密码 的提示）。 登录后，点击主栏上方靠右位置的 “Admin area” 图标进行管理。     

## 分布式Git 

### 工作流程    

#### 集中式工作流

通常使用的是单点协作模型。一个中心仓库，可以接受代码，所有人将自己的工作与之同步。   

这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。 第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。 这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。    

#### 集成管理者工作流

Git 允许多个远程仓库存在，使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限。 这种情形下通常会有个代表“官方”项目的权威的仓库。 要为这个项目做贡献，你需要从该项目克隆出一个自己的公开仓库，然后将自己的修改推送上去。 接着你可以请求官方仓库的维护者拉取更新合并到主项目。 维护者可以将你的仓库作为远程仓库添加进来，在本地测试你的变更，将其合并入他们的分支并推送回官方仓库。即：
1. 项目维护者推送到主仓库
2. 贡献者克隆此仓库，做出修改
3. 贡献将数据推送到自己的公开仓库
4. 贡献者给维护者发送邮件，请求拉取自己的更新，即PR(Pull request)   
5. 维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改
6. 维护者将合并后的修改推送到主仓库

#### 主管与副主管工作流   
 
这其实是多仓库工作流程的变种。 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式，例如著名的 Linux 内核项目。    

副主管负责集成项目中的特定部分，所有这些副主管的头上有一位主管负责统筹，主管维护的仓库作为参考仓库，为所有协作者提供他们需要拉取的项目代码。即：   
1. 普通开发者在自己的主题分支上工作，并根据 `master` 分支进行变基。这里的 `master` 分支为主管推送的参考仓库的 `master` 分支
2. 副主管将普通开发者的主题分支合并到自己的 `master` 分支中
3. 主管将所有副主管的 `master` 分支并入自己的 `master` 分支中
4. 最后，主管将集成后的 `master` 分支推送到参考仓库中，以便所有其他开发者以此为基础进行变基

### 向一个项目贡献

#### 提交准则   

在我们开始查看特定的用例前，这里有一个关于提交信息的快速说明。 有一个好的创建提交的准则并且坚持使用会让与 Git 工作和与其他人协作更容易。 Git 项目提供了一个文档，其中列举了关于创建提交到提交补丁的若干好的提示——可以在 Git 源代码中的`Documentation/SubmittingPatches` 文件中阅读它。     

首先，你的提交不应该包含任何空白错误。 Git 提供了一个简单的方式来检查这点——在提交前，运行 `git diff --check`，它将会找到可能的空白错误并将它们为你列出来。     

接下来，尝试让每一个提交成为一个逻辑上的独立变更集。如果可以，尝试让改动可以理解——不要在整个周末编码解决五个问题，然后在周一时将它们提交为一个巨大的提交。   

最后一件要牢记的事是提交信息。 有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多。 一般情况下，信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更，接着是一个空白行，再接着是一个更详细的解释。Git 项目要求一个更详细的解释，包括做改动的动机和它的实现与之前行为的对比——这是一个值得遵循的好规则。 使用指令式的语气来编写提交信息，比如使用“Fix bug”而非“Fixed bug”或“Fixes bug”。  这里是一份[最初由 Tim Pope 写的模板](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)：   

>Git 项目有一个良好格式化的提交信息——尝试在那儿运行 `git log --no-merges` 来看看漂亮的格式化的项目提交历史像什么样。  

#### 私有小型团队   

[集中式工作流](#集中式工作流)   

#### 私有管理团队    

[主管与副主管工作流](#主管与副主管工作流)  

#### 派生的公开项目    

[集成管理者工作流](#集成管理者工作流)    

#### 通过邮件的公开项目  

与上者相似，区别为生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表，而不是派生项目然后推送到你自己的可写版本。  
可以用 `git format-patch` 命令来生成可以邮寄到列表的mbox格式文件——它将每一个提交转换为一封电子邮件，提交信息的第一行作为主题，剩余信息与提交引入的补丁作为正文。它有一个好处是使用 `format-patch` 生成的一封电子邮件应用的提交正确地保留了所有的提交信息。       

### 维护项目   

#### 在分支中工作    

如果你想向项目中整合一些新东西，最好将这些尝试局限在**主题分支**——一种通常用来尝试新东西的临时分支中。 这样便于单独调整补丁，如果遇到无法正常工作的情况，可以先不用管，等到有时间的时候再来处理。        

#### 应用来自邮件的补丁   

如果你通过电子邮件收到了一个需要整合进入项目的补丁，你需要将其应用到主题分支中进行评估。有两种应用该种补丁的方法：      
- `git apply`
- `git am` 

**apply**：      
如果你收到了一个使用 `git diff` 或 Unix `diff` 命令的变体（不推荐使用这种方式，具体见下一节） 创建的补丁，可以使用 `git apply` 命令来应用。    

这会修改工作目录中的文件。 它与运行 `patch -p1` 命令来应用补丁几乎是等效的，但是这种方式更加严格，相对于 patch 来说，它能够接受的模糊匹配更少。    

与 `patch` 对比：
- 它也能够处理 `git diff` 格式文件所描述的文件添加、删除和重命名操作，而 `patch` 则不会。
- 最后，`git apply` 命令采用了一种“全部应用，否则就全部撤销(apply all or abort all）”的模型， 即补丁只有全部内容都被应用和完全不被应用两个状态，而 `patch` 可能会导致补丁文件被部分应用， 最后使你的工作目录保持在一个比较奇怪的状态。
- 总体来看，`git apply` 命令要比 `patch` 谨慎得多。 并且，它不会为你创建提交——在运行之后，你需要手动暂存并提交补丁所引入的更改。 

在实际应用补丁前，你还可以使用 git apply 来检查补丁是否可以顺利应用——即对补丁运行 `git apply --check` 命令,如果没有产生输出，则该补丁可以顺利应用。 如果检查失败了，该命令还会以一个非零的状态退出，所以需要时你也可以在脚本中使用它。    

**am**：    
要应用一个由 `format-patch` 命令生成的补丁，你应该使用 `git am` 命令(该命令的名字 `am` 表示它“应用(Apply)一系列来自邮箱(Mailbox)的补丁”）。 从技术的角度看，`git am` 是为了读取mbox文件而构建的。

>mbox是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式。    

如果你所使用的邮件客户端能够同时将多封邮件保存为mbox格式的文件， 你甚至能够将一系列补丁打包为单个mbox文件，并利用 `git am` 命令将它们一次性全部应用。    

如果贡献者将 `git format-patch` 生成的补丁文件上传到工单系统或类似的任务处理系统， 你可以先将其保存到本地，之后通过 `git am` 来应用补丁。    

你会看到补丁被顺利地应用，并且为你自动创建了一个新的提交。    

但是，有时候无法顺利地应用补丁。 这也许是因为你的主分支和创建补丁的分支相差较多，也有可能是因为这个补丁依赖于其他你尚未应用的补丁。 这种情况下，`git am` 进程将会报错并且询问你要做什么。**该命令将会在所有出现问题的文件内加入冲突标记，就和发生冲突的合并或变基操作一样**。 而你解决问题的手段很大程度上也是一样的——即手动编辑那些文件来解决冲突，暂存新的文件， 之后运行 `git am --resolved` 继续应用下一个补丁 。    

如果你希望 Git 能够尝试以更加智能的方式解决冲突，你可以对其传递 `-3` 选项来使 Git 尝试进行三方合并。 该选项默认并没有打开，因为如果用于创建补丁的提交并不在你的版本库内的话，这样做是没有用处的。 而如果你确实有那个提交的话——比如补丁是基于某个公共提交的——那么通常 `-3` 选项对于应用有冲突的补丁是更加明智的选择。      

当与你的特性相关的所有补丁都被应用并提交到分支中之后，你就可以选择是否以及如何将其整合到更长期的分支中去了。   

#### 检出远程分支   

如果你的贡献者建立了自己的版本库，并且向其中推送了若干修改， 之后将版本库的 URL 和包含更改的远程分支发送给你，那么你可以将其添加为一个远程分支，并且在本地进行合并。   

这对于与他人长期合作工作来说很有用。 而对于提交补丁频率较小的贡献者，相对于每个人维护自己的服务器，不断增删远程分支的做法，使用电子邮件来接收可能会比较省时。 况且你也不会想要加入数百个只提供一两个补丁的远程分支。 然而，脚本和托管服务在一定程度上可以简化这些工作——这很大程度上依赖于你和你的贡献者开发的方式。   

这种方式的另一种优点是你可以同时得到提交历史。 虽然代码合并中可能会出现问题，但是你能获知他人的工作是基于你的历史中的具体哪一个位置；所以 Git 会默认进行三方合并，不需要提供 `-3` 选项，你也不需要担心补丁是基于某个你无法访问的提交生成的。      

对于非持续性的合作，如果你依然想要以这种方式拉取数据的话，你可以对远程版本库的 URL 调用 `git pull` 命令。 这会执行一个一次性的抓取，而不会将该 URL 存为远程引用。    

#### 确定引入了哪些东西    

一般来说，你应该对该分支中所有 `master` 分支尚未包含的提交进行检查。 通过在分支名称前加入 `--not` 选项，你可以排除 `master` 分支中的提交。     

如果要查看每次提交所引入的具体修改，你应该记得可以给 `git log` 命令传递 `-p` 选项，这样它会在每次提交后面附加对应的差异（diff）。    

Git 提供了一种比较便捷的方式：三点语法。 对于 `git diff` 命令来说，你可以通过把 `…​` 置于另一个分支名后来对该分支的最新提交与两个分支的共同祖先进行比较：    

```console
$ git diff master...contrib
```

**该命令仅会显示自当前主题分支与 `master` 分支的共同祖先起，该分支中的工作。 这个语法很有用，应该牢记。**     

#### 将贡献的工作整合进来     

当主题分支中所有的工作都已经准备好整合进入更靠近主线的分支时，接下来的问题就是如何进行整合了。 此外，还有一个问题是，你想使用怎样的总体工作流来维护你的项目？     

##### 合并工作流   

一种基本的工作流就是将所有的工作直接合并到 `master` 分支。 在这种情况下，`master` 分支包含的代码是基本稳定的。 当你完成某个主题分支的工作，或审核通过了其他人所贡献的工作时，你会将其合并进入 `master` 分支，之后将主题分支删除，如此反复。    

如果你的项目非常重要，你可能会使用两阶段合并循环。 在这种情况下，你会维护两个长期分支，分别是 `master` 和 `develop`，`master` 分支只会在一个非常稳定的版本发布时才会更新，而所有的新代码会首先整合进入 `develop` 分支。 你定期将这两个分支推送到公共版本库中。每次需要合并新的主题分支时，你都应该合并进入 `develop` 分支，当打标签发布的时候，你会将 `master` 分支快进到已经稳定的 `develop` 分支。    

你也可以扩展这个概念，维护一个将所有工作合并到一起的整合分支。 当该分支的代码稳定并通过测试之后，将其合并进入 `develop` 分支； 经过一段时间，确认其稳定之后，将其以快进的形式并入 `master` 分支。   

##### 大项目合并工作流    

Git 项目包含四个长期分支：`master`,`next`，用于新工作的 `pu`（proposed updates）和用于维护性向后移植工作（maintenance backports）的 `maint` 分支。之后对主题分支进行测试评估，检查其是否已经能够合并，或者仍需要更多工作。 安全的主题分支会被合并入 `next` 分支，之后该分支会被推送使得所有人都可以尝试整合到一起的特性。如果主题分支需要更多工作，它则会被并入 `pu` 分支。 当它们完全稳定之后，会被再次并入 `master` 分支。 这意味着 `master` 分支始终在进行快进，`next` 分支偶尔会被变基，而 `pu` 分支的变基比较频繁。Git 项目还有一个从上一次发布中派生出来的 `maint` 分支来提供向后移植过来的补丁以供发布维护更新。       

##### 变基与拣选工作流

为了保持线性的提交历史，有些维护者更喜欢在 `master` 分支上对贡献过来的工作进行变基和拣选，而不是直接将其合并。 当你完成了某个主题分支中的工作，并且决定要将其整合的时候，你可以在该分支中运行变基命令， 在当前 `master` 分支（或者是 `develop` 等分支）的基础上重新构造修改。 如果结果理想的话，你可以快进 `master` 分支，最后得到一个线性的项目提交历史。    

Git 中的拣选类似于对特定的某次提交的变基。 它会提取该提交的补丁，之后尝试将其重新应用到当前分支上。 这种方式在你只想引入主题分支中的某个提交，或者主题分支中只有一个提交，而你不想运行变基时很有用。    

`git cherry-pick <hashkey>` 拣选命令。     

##### Rerere   

如果你在进行大量的合并或变基，或维护一个长期的主题分支，Git 提供的一个叫做“rerere”的功能会有一些帮助。    

Rerere是“重用已记录的冲突解决方案（reuse recorded resolution）”的意思——它是一种简化冲突解决的方法。 当启用rerere时，Git将会维护一些成功合并之前和之后的镜像，当Git发现之前已经修复过类似的冲突时， 便会使用之前的修复方案，而不需要你的干预。    

这个功能包含两个部分：    
- 一个配置选项
- 一个命令

其中的配置选项是 `rerere.enabled`，把它放在全局配置中就可以了：       

```console
$ git config --global rerere.enabled true
```

现在每当你进行一次需要解决冲突的合并时，解决方案都会被记录在缓存中，以备之后使用。   

如果你需要和 rerere 的缓存交互，你可以使用 `git rerere` 命令。 当单独调用它时，Git 会检查解决方案数据库，尝试寻找一个和当前任一冲突相关的匹配项并解决冲突(尽管当 `rerere.enabled` 被设置为 `true` 时会自动进行）。 它也有若干子命令，可用来查看记录项，删除特定解决方案和清除缓存全部内容等。      

##### 为发布打标签    

当你决定进行一次发布时，你可能想要打一个标签，这样在之后的任何一个提交点都可以重新创建该发布。    

如果你为标签签名了，你可能会遇到分发用来签名的 PGP 公钥的问题。 Git 项目的维护者已经解决了这一问题，其方法是在版本库中以 blob 对象的形式包含他们的公钥，并添加一个直接指向该内容的标签。   
1. 要完成这一任务，首先你可以通过运行 `gpg --list-keys` 找出你所想要的key.        
2. 之后你可以通过导出 key 并通过管道传递给 `git hash-object` 来直接将 key 导入到 Git 的数据库中，`git hash-object` 命令会向 Git 中写入一个包含其内容的新 blob 对象，并向你返回该 blob 对象的SHA-1值。      
3. 既然 Git 中已经包含你的 key 的内容了，你就可以通过指定由 `hash-object` 命令给出的新SHA-1值来创建一个直接指向它的标签。如果你运行 `git push --tags` 命令，那么标签将会被共享给所有人。 需要校验标签的人可以通过从数据库中直接拉取 blob 对象并导入到 GPG 中来导入PGP key.   
人们可以使用这个 key 来校验所有由你签名的标签。 另外，如果你在标签信息中包含了一些操作说明，用户可以通过运行 `git show <tag>` 来获取更多关于标签校验的说明。      

##### 生成一个构建号   

Git中不存在随每次提交递增的“v123”之类的数字序列，如果你想要为提交附上一个可读的名称， 可以对其运行 `git describe` 命令。作为回应，Git将会生成一个字符串， 它由最近的标签名、自该标签之后的提交数目和你所描述的提交的部分SHA-1值(前缀的 `g` 表示Git)构成。   

这样你在导出一个快照或构建时，可以给出一个便于人们理解的命名。 实际上，如果你的Git是从Git自己的版本库克隆下来并构建的，那么 `git --version` 命令给出的结果是与此类似的。 **如果你所描述的提交自身就有一个标签，那么它将只会输出标签名，没有后面两项信息。**    

**默认情况下， `git describe` 命令需要有注解的标签（即使用 `-a` 或 `-s` 选项创建的标签）**； 如果你想使用轻量标签（无注解的标签），请在命令后添加 `--tags` 选项。 你也可以使用这个字符串来调用 `git checkout` 或 `git show` 命令， 但是这依赖于其末尾的简短SHA-1值，因此不一定一直有效。 比如，最近Linux内核为了保证SHA-1值对象的唯一性，将其位数由8位扩展到了10位， 导致以前的 `git describe` 输出全部失效。

##### 准备一次发布  

现在你可以发布一个构建了。 其中一件事情就是为那些不使用 Git 的可怜包们创建一个最新的快照归档。 使用 `git archive` 命令完成此工作。   

如果有人将这个压缩包解压，他就可以在一个 `project` 目录中得到你项目的最新快照。 你也可以以类似的方式创建一个zip压缩包，但此时你应该向 `git archive` 命令传递 `--format=zip` 选项。    

##### 制作提交简报     

使用 `git shortlog` 命令可以快速生成一份包含从上次发布之后项目新增内容的修改日志(changelog)类文档。 它会对你给定范围内的所有提交进行总结。   

这份整洁的总结包括了自上一次版本以来的所有提交，并且已经按照作者分好组，你可以通过电子邮件将其直接发送到列表中。      



## 命令
### 基础命令  

- `git config --global user.name <username>` 刚安装时使用，进行用户签名
- `git config --global user.email <useremail>` 刚安装时使用，进行用户签名
- `git config --global core.editor <editor>` 配置文本编辑器
- `git init` 初始化本地仓库   
- `git status` 查看本地库状态  
- `git show` 查看目标信息
- `git add <filename>` 添加到暂存区  
- `git commit <filename>` 提交到本地库
- `git help <command>` 获取git命令的帮助信息
- `git tag` 创建标签  
- `git diff <filename>` 显示与暂存区文件的差异  
- `git diff <revision> <filename>` 显示某个文件两个版本之间的差异  

### 查看日志命令

- `git log` 显示历史日志  
  - `git log --all --graph --decorate` 可视化历史记录（有向无环图）  
- `git reflog` 查看reflog信息  

### 分支和合并

- `git branch` 显示分支  
- `git branch <name>` 创建分支  
- `git merge <revision>` 合并到当前分支  
- `git mergetool` 使用工具来处理冲突  
- `git rebase` 将一系列补丁变基为新的基线  
- `git checkout <revision>` 更新HEAD和目前的分支  
  - `git checkout -b <name>` 创建并切换分支
- `git reset --hard <revision>` 重置HEAD指针到指定的提交  
- `git rebase` 变基

### 远端操作  

- `git remote` 列出远端  
- `git remote add <name> <url>` 添加一个远端  
- `git push <remote> <local branch>:<remote branch>` 将对象传送至远端并更新远端引用  
- `git branch --set-upstream-to <remote>/<remote branch>` 创建本地和远端分支的关联关系  
- `git fetch` 从远端获取对象/索引  
- `git pull` 相当于git fetch;git merge  
- `git clone <url>` 从远端下载仓库  

### 撤销

- `git commit --amend` 编辑提交的内容或信息  
- `git reset HEAD <filename>` 恢复暂存文件  
- `git checkout -- <filename>` 丢弃修改  
- `git restore` git2.32 版本后取代 git reset 进行许多撤销操作  

### 高级操作  

- `git config` Git 是一个高度可定制的工具  
- `git clone --depth=1` 浅克隆(shallow clone)，不包括完整的版本历史信息  
- `git add -p` 交互式暂存  
- `git rebase -i` 交互式变基  
- `git blame` 查看最后修改某行的人  
- `git stash` 暂时移除工作目录下的修改内容  
- `git bisect` 通过二分查找搜索历史记录  
- `.gitignore` 指定故意不追踪的文件(不是命令，是dot file)  
- `git format-patch` 生成补丁
- `git am/apply` 应用补丁
- `git cherry-pick <hashkey>` 拣选命令
- `git rerere` 重用已记录的冲突解决方案
- `git describe` 生成一个构建号
- `git archive` 创建一个最新快照归档
- `git shortlog` 制作简报

## 获取帮助  

有三种方式可以找到Git命令的综合手册：
- `$ git help <verb>`  
- `$ git <verb> --help`
- `$ man git-<verb>`

你可以尝试在 [Freenode IRC](https://freenode.net/) 服务器上的 `#git` 或 `#github` 频道寻求帮助。  

此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 `-h` 选项获得更简明的手册

## QA  

> [!faq] **1. `log` 与 `reflog` 的区别**  
>`log` 显示当前HEAD及其祖先。也就是说，它会打印HEAD指向的提交，然后是其父级、其父级的父级...。它会通过递归查找每个提交的父级来遍历存储库的祖先。`reflog` 不会遍历HEAD的祖先，它是HEAD指向的提交的有序列表，是存储库的撤销历史记录，它不是存储库本身的一部分（它与提交本身分开存储），也不包含在推送，提取或克隆中，它纯粹是本地的。  
>另外：了解 `reflog` 意味着一旦提交，就不会真正丢失在存储库里的数据。如果不小心重置为较旧的版本，或错误的重新设置了基数，或任何其他直观地“删除”操作，都可以使用 `reflog` 查看之前的位置，然后通过 `git reset --hard <hashkey>` 返回该引用以恢复之前的状态。引用不止意味着提交，也意味着背后整个的历史记录，但reflog条目并不会永久保留，但错误至少在两周内会是安全的。  

> [!question] **2. `checkout` 与 `reset --hard` 的区别**  
>前者只去更新HEAD指针，列如，在使用时，从主线切换到其他地方，只有HEAD指针去移动，而后者，则将主线指针也一并带了过来，为此可能会出现丢失数据的情况，就要用到 `reflog` 了。  

> [!faq] **3. `checkout -- <filename>` 与 `reset HEAD <filename>` 区别**  
>前者如果文件没有添加到缓存区，那么将最近一次提交的版本替换工作目录中的文件，丢弃本地的修改，后者仅将文件从暂存区中移除。  

> [!question] ORIG_HEAD是什么
> 是上次执行 `git reset/pull/merge` 命令前指针所在的位置。




