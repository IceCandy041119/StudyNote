# GitNotes  

## 目录

- [关于版本控制](#关于版本控制)
- [Git简史](#Git简史)
- [Git介绍](#Git介绍)
- [Git配置](#Git配置)
- [Git基础](#Git基础)
- [Git分支](#Git分支)
- [命令](#命令)
- [获取帮助](#获取帮助)
- [QA](#QA)

## 关于版本控制  

版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
它有着以下阶段
- [本地版本控制系统](#本地版本控制系统)
- [集中化的版本控制系统](#集中化的版本控制系统)
- [分布式版本控制系统](#分布式的版本控制系统)

### 本地版本控制系统  

**起因**：许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 这么做唯一的好处就是简单，但是特别容易犯错。 有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。  
**结果**：为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 [RCS](https://www.gnu.org/software/rcs/)的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。   
**缺点**：当本地机器损坏，又没有恰当的备份，你将丢失所有数据。

### 集中化的版本控制系统  

**起因**：人们又遇到一个问题，如何让在不同系统上的开发者协同工作？   
**结果**：于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS,Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。  
**缺点**：当中央服务器的单点故障，谁也无法提交更新，也就无法协同工作。如果中心数据库所在磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据--包括项目整个的变更历史，只剩下人们在各自机器上保留的单独快照。  

### 分布式版本控制系统  

**起因**：为了解决上面两者的缺点  
**结果**：分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。在这类系统中，像Git，Mercurial以及Darcs等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。  
**优点**：**任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。** 因为每一次的克隆操作，实际上都是对代码仓库的完整备份。**更进一步，许多这类系统都可以指定和若干不同的远端代码交互。** 籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流层，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。  

## Git简史  

**创建年代**：2005年    
**创建原因**：Linux内核开源项目有着为数众多的参与者。绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002),到2002年，整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码。2005年，开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费使用BitKeeper的权利。这就迫使Linux开源社区(特备是Linux的缔造者Linux Torvalds)基于使用BitKeeper时的经验教训，开发出自己的版本系统。他们对新的系统制定了若干目标：
- 速度
- 简单的设计
- 对非线性开发模式的强力支持(允许成千上万个并行开发的分支)
- 完全分布式
- 有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)   

**结果**：自诞生于2005年以来，Git日臻成熟完善，在高度易用的同时，仍然保留初期设定的目标。它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。  

>BitKeeper之所以不让社区继续使用的原因是有位开发者破解了它的协议被公司发现了于是停止了合作，据说Git的开发用了两周就写完了。  

## Git介绍  

>**注意！！！**：在学习 Git 时，请尽量理清你对其它版本管理系统已有的认识，如 CVS，Subversion 或 Perforce， 这样能帮助你使用工具时避免发生混淆。尽管 Git 用起来与其它的版本控制系统非常相似， 但它在对信息的存储和认知方式上却有很大差异，理解这些差异将有助于避免使用中的困惑。  

### 直接记录快照，而非差异比较  

Git 和其它版本控制系统（包括 Subversion 和近似工具）的**主要差别在于 Git 对待数据的方式。**  

从**概念**上来说，**其它大部分系统**：以**文件变更列表**的方式存储信息，这类系统（CVS，Subversion，Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）。

Git 不按照以上方式对待或保存数据。反之，**Git 更像是把数据看作是对小型文件系统的一系列快照。** 在 Git 中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。 **为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。** Git 对待数据更像是一个 **快照流。**  

Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具，而不只是一个简单的VCS工具。  

### 近乎所有操作都是本地执行  

在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。因为你在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。  

### Git 保持完整性  

**Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。** 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。

**Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。** 基于 Git 中文件的内容或目录结构计算出来。如：  `24b9da6552552987aa493b52f8696cd6d3b00373`  

**实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。**  

### Git一般只添加数据  

你执行的 Git 操作，几乎只往 Git 数据库中**添加**数据。 你很难使用 Git 从数据库中**删除**数据，也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作。

>真要在快照里删除数据也行。

### 三种状态   

**Git有三种状态**：
- 已提交(committed)：表示修改了文件，但还没保存到数据库中
- 已修改(modified)：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中
- 已暂存(staged)：表示数据已经安全地保存在了本地数据库中

**Git项目的三个区**：
- 工作区：是对**某个版本独立**提取出来的内容，放在磁盘上供你修改或使用
- 暂存区：是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。按照Git术语叫“索引”
- Git目录：是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，克隆就是复制这里的数据   

Git的工作流程：
1. 在工作区修改文件
2. 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区
3. 提交更新，找到暂存区文件，将快照永久性存储到Git目录  

## Git配置  

### 初次运行Git 

Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量。这些变量存储在：
1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 `git config` 时带上 `--system` 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它）
2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户。 你可以传递 `--global` 选项让 Git 读写此文件，这会对你系统上**所有**的仓库生效
3. 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config` ）：针对该仓库。 你可以传递 `--local` 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。 （当然，你需要进入某个 Git 仓库中才能让该选项生效）

>每一个级别会覆盖上一级别的配置，所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量。  

你可以通过以下命令查看所有的配置以及它们所在的文件：
```$ git config --list --show-origin```  

安装完Git之后，要做的第一件事就是设置你的用户名和邮件地址。它们会写入到你的每一次提交中，不可更改：
`$ git config --global user.name <username>` 写入到 `~/.gitconfig`   
`$ git config --global user.email <useremail>` 写入到 `~/.gitconfig`  
想针对特定的项目使用特定的用户名和邮箱，可以在那个项目下运行没有 `--global` 的选项命令来配置。 

接着需要配置文本编辑器  
`$ git config --global core.editor <editor>` 配置文本编辑器  

`git config --list` 检查配置信息  

>可能会有重复，因为会从不同文件读取同一个配置。    

`git config <key>` 检查Git的某一项配置     
如 `git config user.name`    
### .gitignore

`.gitignore` 忽略文件，格式规范如下：
- 所有空行或者以 `#` 开头的行都会被Git忽略
- 可以使用标准的glob模式匹配，它会递归地应用在整个工作区中
- 匹配模式可以以( `/` )开头防止递归
- 匹配模式可以以( `/` )结尾指定目录
- 要忽略指定模式以外的文件或目录，可以在模式前加个叹号( `!` )取反   
>**glob模式**      
>指shell所使用的简化了的正则表达式。星号( `*` )匹配零个或多个任意字符， `[abc]`  匹配任何一个列在方括号中的字符，问号( `?` )只匹配一个任意字符，如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配( `[0-9]` 表示匹配0到9的数字)。使用两个星号( `**` )表示匹配任意中间目录，如 `a/**/z` 可以匹配 `a/z` `a/b/z`等。  

[GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表](https://github.com/github/gitignore)  

### Git别名  

可以用 `git config --global alias.<alias> <command>` 来设置别名   

在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：

```console
$ git config --global alias.unstage 'reset HEAD --'
```

可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 `!` 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 `git visual` 定义为 `gitk` 的别名：

```console
$ git config --global alias.visual '!gitk'
```


## Git基础  

### Git仓库
通常用两种获取Git项目仓库的方式：
1. 利用 `git init` 命令将尚未进行版本控制的本地目录转换为Git仓库
2. 利用 `git clone <url> <name>` 命令从其他服务器克隆一个已存在的Git仓库   

### 更新
工作目录下的每一个文件都不外乎这两种状态：
- 已跟踪：指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是[未修改、已修改或已放入暂存区](#三种状态)，总之，它是Git已知道的文件。
- 未跟踪：除了已跟踪文件外就是未跟踪文件，既不存在于上次的快照记录中，也没有被放入暂存区。

可以用 `git status` 命令检查哪些文件都处于什么状态。
- 可以加 `-s\--short` 参数，用简洁的方式查看更改，简短会将状态变为两栏，左栏为暂存区的状态，右栏为工作区的状态。  

可以用 `git add <files>` 命令去跟踪一个文件，将文件添加至暂存区，把有冲突的文件标记为已解决状态。**已暂存的文件若修改，则需再次使用该命令，提交时只会提交最后一次使用该命令的文件版本。** 使用文件或目录的路径作为参数，如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。名字可以用通配符。  

可以用 `git diff` 命令查看已暂存和未暂存的修改。
- 不加参数，查看尚未暂存的文件更新了哪些部分
- 加 `--staged` 参数，这条命令将比对已暂存文件与最后一次提交的文件差异
- 使用 `git difftool --tool-help` 命令来看你的系统都支持哪些git diff插件   

>**注意**，`git diff` 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 `git diff` 后却什么也没有，就是这个原因。  

可以用 `git commit` 命令去提交一个快照。
- 加 `-m` 参数，将提交信息与命令放在同一行
- 加 `-a` 参数，自动把所有已经更新过的文件暂存起来一并提交，从而跳过 `git add` 步骤

可以用 `git rm <files>` 命令去移除某个文件。
- 加 `-f` 参数，去强制删除之前修改过或已经放到暂存区的文件
- 加 `--cached` 参数，只从暂存区域中移除     

>`git rm` **命令后面可以列出文件或者目录的名字，也可以使用 `glob` 模式。比如**：
>`$ git rm log/\*.log`   
>**注意到星号 `*` 之前的反斜杠 `\`， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用shell 来帮忙展开。** 此命令删除 `log/` 目录下扩展名为 `.log` 的所有文件。 类似的比如：~  
>`$ git rm \*~`   
>该命令会删除所有名字以 `~` 结尾的文件。   

可以用 `git mv <source> <destination>` 命令来对文件改名。   
相当于   
```
mv <source> <destination>  
git rm <source>  
git add <destination>  
```

### 查看提交历史   

可以使用 `git log` 命令查看提交历史。   
- 没有参数的情况下，会按时间先后顺序列出所有的提交，最近的更新排在最上面
- 加 `-p\--patch` 参数，它会按补丁格式显示出每个提交所引入的差异
- 加 `-n` 参数，显示最近n次提交
- 加 `--stat` 参数，查看提交的简略统计信息
	- `--shortstat` 参数，只显示最后的行数修改统计
- 加 `--name-only` 仅在提交信息后显示以修改的文件清单
- 加 `--name-status` 显示新增、修改、删除的文件清单
- 加 `--abbrev-commit` 仅显示SHA-1校验和所有40个字符中的前几个字符
- 加 `--relative-date` 使用较短的相对时间而不是完整格式显示日期(如"2 weeks age")
- 加 `--pretty` 参数，可以使用不同的默认格式的方式展示提交历史
	- `--pretty=oneline` 将每个提交放在一行显示
	- `--pretty=short` 
	- `--pretty=full` 
	- `--pretty=fuller` 
	- `--pretty=format` 定制记录的显示格式
- 加 `--graph` 参数，在日志旁以ASCII图形显示分支与合并记录
- 加 `--since\--after` 参数，仅显示指定时间之后的提交
- 加 `--until\--before` 参数，仅显示指定时间之前的提交
- 加 `--committer` 参数，仅显示提交者匹配指定字符串的提交
- 加 `--author` 参数，显示指定作者匹配指定字符串的提交
- 加 `--grep` 参数，仅显示提交说明中包含指定字符出的提交 
- 加 `-S <string>` 参数，仅显示添加或删除内容匹配指定字符串的提交
- 加 `-- <path>` 参数，查找某些文件或目录的提交
- 加 `--no-merges` 选项，隐藏合并提交
- 加 `--decorate` 查看各个分支当前所指的对象   

>你可以指定多个 `--author` 和 `--grep` 搜索条件，这样会只输出匹配**任意** `--author` 模式和**任意** `--grep` 模式的提交。然而，如果你添加了 `--all-match` 选项， 则只会输出匹配**所有** `--grep` 模式的提交。

>**作者与提交者**  
>作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。  

>其实也并不是在任何情况下都是所有，但你用 `git reset --hard` 切换到旧记录，此时并不会显示所有提交，因为这时的master分支跑到了旧分支， `log` 按分支节点递归查找，所有会丢失后面的提交。 

表1. format常用格式

| 选项    | 说明                          |
| ----- | --------------------------- |
| `%H`  | 提交的完整哈希值                    |
| `%h`  | 提交的简写哈希值                    |
| `%T`  | 树的完整哈希值                     |
| `%t`  | 树的简写哈希值                     |
| `%P`  | 父提交的完整哈希值                   |
| `%p`  | 父提交的简写哈希值                   |
| `%an` | 作者名字                        |
| `%ae` | 作者的电子邮件地址                   |
| `%ad` | 作者修订日期（可以用 --date=选项 来定制格式） |
| `%ar` | 作者修订日期，按多久以前的方式显示           |
| `%cn` | 提交者的名字                      |
| `%ce` | 提交者的电子邮件地址                  |
| `%cd` | 提交日期                        |
| `%cr` | 提交日期（距今多长时间）                |
| `%s`  | 提交说明                        |

### 撤销

>**注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。**   

可以用 `git commit --amend` 命令覆盖上一次的提交。

>修补提交最明显的价值是可以稍微改进你最后的提交，而不会让“啊，忘了添加一个文件”或者 “小修补，修正笔误”这种提交信息弄乱你的仓库历史。   

可以用 `git reset HEAD <file>` 命令来取消暂存。  

>`git reset` 确实是个危险的命令，如果加上了 `--hard` 选项则更是如此。然而在上述场景中，工作目录中的文件尚未修改，因此相对安全一些。   

可以用 `git checkout -- <file>` 命令来撤销文件的修改。  

>请务必记得 `git checkout — <file>` 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。   

>记住，在 Git 中任何**已提交**的东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 `--amend` 选项覆盖的提交也可以恢复。然而，任何你未提交的东西丢失后很可能再也找不到了。    

### 远程仓库   

**介绍**：远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 **管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪**等等。   

>**远程仓库可以在你的本地主机上**   
>你完全可以在一个“远程”仓库上工作，而实际上它在你本地的主机上。 词语“远程”未必表示仓库在网络或互联网上的其它位置，而只是表示它在别处。 在这样的远程仓库上工作，仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作。

可以用 `git remote` 命令去查看你已经配置的远程仓库服务器。
- 加 `-v` 参数，会显示需要读写远程仓库使用的简写与其对应的URL  

可以用 `git remote add <shortname> <url>` 命令添加一个新的远程Git仓库。同时指定一个方便的简写。   

可以用 `git fetch <remote>` 命令从远程仓库中获得数据，这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。  

>必须注意 `git fetch` 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。   

可以用 `git pull` 命令来自动抓取后台合并该远程分支到当前分支。     

>前提是你的当前分支设置了跟踪远程分支，默认情况下，`git clone` 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 `master` 分支（或其它名字的默认分支）。    

可以用 `git push` 命令将本地进度推送到上游。    

>必须要有写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。   

可以用 `git remote show <remote>` 命令去查看一个远程仓库的更多信息。 

可以用 `git remote <rename>` 命令修改一个远程仓库的简写名。   

可以用 `git remote remove <remotename>` 命令可以去移除一个远程仓库。   

### 标签  

可以用 `git tag -l\--list` 命令以字母顺序列出已有的标签。  

>默认的 `git tag` 给出的就是完整的标签列表，要用通配符的话，需要有 `-l\--list` 参数。   

标签有两种：
- 轻量标签：很像一个不会改变的分支——它只是某个特定提交的引用。  
- 附注标签：是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard (GPG)签名并验证。   

>通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。  

#### 附注标签  

可以用 `git tag -a <tag> -m <message>` 创建， `-m` 指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会启动编辑器要求你输入信息。

可以用 `git show <tagname>` 命令查看标签信息与和与之对应的提交信息  

#### 轻量标签   

轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。   

创建轻量标签，不需要使用 `-a`、`-s` 或 `-m` 选项，只需要提供标签名字。如   
`git tag v1.1`   

这时用 `git show <tagname>` 只会显示提交提交信息    

#### 后期打标签  

可以用 `git tag -a <tagname> <hashkey>` 给特定的记录打上标签。  

#### 共享标签  

默认情况下，`git push` 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。   
可以用 `git push <remotename> <tagname>` 进行推送。
- 加 `-tags` 参数，把所有不在远程仓库服务器上的标签全部传送到那里。   

>使用 `git push <remote> --tags` 推送标签并不会区分轻量标签和附注标签， 没有简单的选项能够让你只选择推送一种标签。  

#### 删除标签   

可以用 `git tag -d <tagname>` 删除本地仓库上的标签。

>上述命令并不会从任何远程仓库中移除这个标签。

可以用 `git push <remote> :refs/tags/<tagname>` 或者 `git push <remote> --delete <tagname>` 命令，去删除远程仓库的标签。   

>上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。   

#### 检出标签  

可以用 `git checkout <tagname>` 去查看某个标签所指向的文件版本。

>这会使你的仓库处于“**分离头指针（detached HEAD）**”的状态——这个状态有些不好的副作用：**在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。**  

## Git分支   

### 分支简介  

有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。     

在进行提交操作时，Git 会保存一个**提交对象（commit object）**。 知道了 Git 保存数据的方式，我们可以很自然的想到——该**提交对象会包含一个指向暂存内容快照的指针**。但不仅仅是这样，该提交对象**还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。**   

>**首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。**  

暂存操作会为每一个文件计算校验和(SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 (Git 使用 **blob 对象**来保存它们) 。   

当使用 `git commit` 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为**树对象**。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。   

**blob对象**：保存着文件快照。
**树对象**：记录着目录结构和blob 对象索引。 
**提交对象**：包含着指向前述树对象的指针和所有提交信息。

**Git 的分支，其实本质上仅仅是指向提交对象的可变指针。** Git 的默认分支名字是 `master`。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 `master` 分支。 `master` 分支会在每次提交时自动向前移动。

>Git 的 `master` 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 `git init` 命令默认创建它，并且大多数人都懒得去改动它。

**Git有一个名为 `HEAD` 的特殊指针。** 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 `HEAD` 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支。

>`HEAD` 会如同你的影子一般跟随你   
>PS：一次就好，我带你去看天荒地老～   

由于 Git 的分支实质上仅是包含所指对象校验和(长度为 40 的 SHA-1 值字符串)的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节(40 个字符和 1 个换行符），如此的简单能不快吗?      

### 分支的创建与合并   

可以用 `git branch <branchname>` 创建分支   
- 加 `-d` 参数，可以删除分支
- 加 `-D` 参数，可以强制删除分支  

可以用 `git checkout -b` 创建分支并切换过去    

可以用 `git merge` 命令合并分支    

>合并时使用三方合并——两个分支所指的快照以及这两个分支的公共祖先。

>当合并时，要合并的分支是当前分支的直接后继，那么Git会直接将指针向前移动。因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。     

>当合并分支时，不同的分支都涉及了对同一个文件的同一个部分进行了不同的修改，那么合并时会产生合并冲突。**任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记**，这样你可以打开这些包含冲突的文件然后手动解决冲突。   

### 分支管理    

可以用 `git branch` 命令查看分支列表    
- 加 `-v` 参数，查看每一个分支的最后一次提交
- 加 `--merged` 参数，查看已经合并的分支   
- 加 `--no-merged` 参数，查看尚未合并的分支  

>上面描述的选项 `--merged` 和 `--no-merged` 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 **当前** 分支的分支。你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。   

### 远程分支      

#### 远程跟踪分支   

**远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用**。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。它们以 `<remote>/<branch>` 的形式命名。     

可以用 `git push <remote> <branch>` 命令将本地的分支推送到远端分支。
- `git push <remote> <branch>:<remotebranch>` 命令将本地的分支推送到远端 `<remotebranch>` 上

可以用 `git ls-remote <remote>` 命令来显式地获得远程引用的完整列表。   

> [!tip] 抓取远程分支时
> 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 `serverfix` 分支——只有一个不可以修改的 `origin/serverfix` 指针。
#### 跟踪分支  

从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”(它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 `git pull`，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。

可以用 `git checkout --track <remotebranch>` 命令跟踪远端分支。   
- `git checkout -b <branch> <remote>/<branch>` 创建一个分支跟踪远端分支  

> [!tip]
> 如果你尝试检出的本地分支不存在且远端分支刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支。

> [!tip] 上游快捷方式
>当设置好跟踪分支后，可以通过简写 `@{upstream}` 或 `@{u}` 来引用它的上游分支。 所以在 `master` 分支时并且它正在跟踪 `origin/master` 时，如果愿意的话可以使用 `git merge @{u}` 来取代 `git merge origin/master`。

可以用 `git branch -vv` 命令根据本地数据查看所有跟踪分支以及进度。

> [!tip] 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：
>
>```console
>$ git fetch --all; git branch -vv
>```

#### 拉取  

当 `git fetch` 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。    

有一个命令叫作 `git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令。   

>由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些。   

#### 删除远端分支  

可以用 `git push <remote> --delete <remotename>` 删除一个远端分支

### 变基    

在 Git 中整合来自不同分支的修改主要有两种方法
- `merge` 合并：详见[分支的创建与合并](#分支的创建与合并)
- `rebase` 变基：将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。  

> [!tip] 原理
> 首先找到这两个分支的最近共同祖先，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底，最后以此将之前另存为临时文件的修改依序应用。

`git rebase --onto <目标基底分支> <旧的基底分支> <要移动的分支>` 将要移动的分支从旧的基底分支分离出来变基到目标基底分支。   

`git rebase <basebranch> <topicbranch>` 命令可以直接将主题分支变基到目标分支上。   

变基完成后，进行合并。     

> [!warning] 奇妙的变基也并非完美无缺，要用它得遵守一条准则
> 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。

**变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。**  

> [!tip] 如果你在多人协作的仓库上使用了变基--用变基解决变基
> 实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 "patch-id"。如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。  
> 举个例子，如果遇到前面提到的有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交那种情境，如果我们不是执行合并，而是执行 `git rebase <remote>/<branch>`, Git 将会：
> - 检查哪些提交是我们的分支上独有的
> - 检查其中哪些提交不是合并操作的结果
> - 检查哪些提交在对方覆盖更新时并没有被纳入目标分支
> - 把查到的这些提交应用在远程分支上面     
> 
>也可以用 `git pull --rebase` 命令，代替 `git fetch;git rebase` 命令。

> [!tip] 变基 vs. 合并 
> 变基会该改变提交的记录，合并不会，为此，根据自己的需求选择合适的方式。
> > [!warning] 但记住
> > 总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。





## 命令
### 基础命令  

- `git config --global user.name <username>` 刚安装时使用，进行用户签名
- `git config --global user.email <useremail>` 刚安装时使用，进行用户签名
- `git config --global core.editor <editor>` 配置文本编辑器
- `git init` 初始化本地仓库   
- `git status` 查看本地库状态  
- `git show` 查看目标信息
- `git add <filename>` 添加到暂存区  
- `git commit <filename>` 提交到本地库
- `git help <command>` 获取git命令的帮助信息
- `git tag` 创建标签  
- `git diff <filename>` 显示与暂存区文件的差异  
- `git diff <revision> <filename>` 显示某个文件两个版本之间的差异  

### 查看日志命令

- `git log` 显示历史日志  
  - `git log --all --graph --decorate` 可视化历史记录（有向无环图）  
- `git reflog` 查看reflog信息  

### 分支和合并

- `git branch` 显示分支  
- `git branch <name>` 创建分支  
- `git merge <revision>` 合并到当前分支  
- `git mergetool` 使用工具来处理冲突  
- `git rebase` 将一系列补丁变基为新的基线  
- `git checkout <revision>` 更新HEAD和目前的分支  
  - `git checkout -b <name>` 创建并切换分支
- `git reset --hard <revision>` 重置HEAD指针到指定的提交  
- `git rebase` 变基

### 远端操作  

- `git remote` 列出远端  
- `git remote add <name> <url>` 添加一个远端  
- `git push <remote> <local branch>:<remote branch>` 将对象传送至远端并更新远端引用  
- `git branch --set-upstream-to <remote>/<remote branch>` 创建本地和远端分支的关联关系  
- `git fetch` 从远端获取对象/索引  
- `git pull` 相当于git fetch;git merge  
- `git clone <url>` 从远端下载仓库  

### 撤销

- `git commit --amend` 编辑提交的内容或信息  
- `git reset HEAD <filename>` 恢复暂存文件  
- `git checkout -- <filename>` 丢弃修改  
- `git restore` git2.32 版本后取代 git reset 进行许多撤销操作  

### 高级操作  

- `git config` Git 是一个高度可定制的工具  
- `git clone --depth=1` 浅克隆(shallow clone)，不包括完整的版本历史信息  
- `git add -p` 交互式暂存  
- `git rebase -i` 交互式变基  
- `git blame` 查看最后修改某行的人  
- `git stash` 暂时移除工作目录下的修改内容  
- `git bisect` 通过二分查找搜索历史记录  
- `.gitignore` 指定故意不追踪的文件(不是命令，是dot file)  

## 获取帮助  

有三种方式可以找到Git命令的综合手册：
- `$ git help <verb>`  
- `$ git <verb> --help`
- `$ man git-<verb>`

你可以尝试在 [Freenode IRC](https://freenode.net/) 服务器上的 `#git` 或 `#github` 频道寻求帮助。  

此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 `-h` 选项获得更简明的手册

## QA  

> [!faq] **1. `log` 与 `reflog` 的区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`log` 显示当前HEAD及其祖先。也就是说，它会打印HEAD指向的提交，然后是其父级、其父级的父级...。它会通过递归查找每个提交的父级来遍历存储库的祖先。`reflog` 不会遍历HEAD的祖先，它是HEAD指向的提交的有序列表，是存储库的撤销历史记录，它不是存储库本身的一部分（它与提交本身分开存储），也不包含在推送，提取或克隆中，它纯粹是本地的。  
>另外：了解 `reflog` 意味着一旦提交，就不会真正丢失在存储库里的数据。如果不小心重置为较旧的版本，或错误的重新设置了基数，或任何其他直观地“删除”操作，都可以使用 `reflog` 查看之前的位置，然后通过 `git reset --hard <hashkey>` 返回该引用以恢复之前的状态。引用不止意味着提交，也意味着背后整个的历史记录，但reflog条目并不会永久保留，但错误至少在两周内会是安全的。  

> [!question] **2. `checkout` 与 `reset --hard` 的区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者只去更新HEAD指针，列如，在使用时，从主线切换到其他地方，只有HEAD指针去移动，而后者，则将主线指针也一并带了过来，为此可能会出现丢失数据的情况，就要用到 `reflog` 了。  

> [!faq] **3. `checkout -- <filename>` 与 `reset HEAD <filename>` 区别**  
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前者如果文件没有添加到缓存区，那么将最近一次提交的版本替换工作目录中的文件，丢弃本地的修改，后者仅将文件从暂存区中移除。  

> [!question] ORIG_HEAD是什么
> 是上次执行 `git reset/pull/merge` 命令前指针所在的位置。




