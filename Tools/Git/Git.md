# GitNotes  

## 目录

- [关于版本控制](#关于版本控制)
- [Git简史](#Git简史)
- [Git介绍](#Git介绍)
- [Git配置](#Git配置)
- [Git基础](#Git基础)
- [Git分支](#Git分支)
- [服务器上的Git](#服务器上的Git)
- [分布式Git](#分布式Git)
- [Git高级操作](#Git高级操作)
- [Git内部原理](#Git内部原理)
- [命令](#命令)
- [获取帮助](#获取帮助)
- [QA](#QA)

## 关于版本控制  

版本控制是一种记录一个或若干文件内容变化,以便将来查阅特定版本修订情况的系统.
它有着以下阶段
- [本地版本控制系统](#本地版本控制系统)
- [集中化的版本控制系统](#集中化的版本控制系统)
- [分布式版本控制系统](#分布式的版本控制系统)

### 本地版本控制系统  

**起因**：许多人习惯用复制整个项目目录的方式来保存不同的版本,或许还会改名加上备份时间以示区别. 这么做唯一的好处就是简单,但是特别容易犯错. 有时候会混淆所在的工作目录,一不小心会写错文件或者覆盖意想外的文件.  
**结果**：为了解决这个问题,人们很久以前就开发了许多种本地版本控制系统,大多都是采用某种简单的数据库来记录文件的历次更新差异.其中最流行的一种叫做 RCS,现今许多计算机系统上都还看得到它的踪影. [RCS](https://www.gnu.org/software/rcs/)的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁,可以重新计算出各个版本的文件内容.   
**缺点**：当本地机器损坏,又没有恰当的备份,你将丢失所有数据.

### 集中化的版本控制系统  

**起因**：人们又遇到一个问题,如何让在不同系统上的开发者协同工作？   
**结果**：于是,集中化的版本控制系统（Centralized Version Control Systems,简称 CVCS）应运而生. 这类系统,诸如 CVS,Subversion 以及 Perforce 等,都有一个单一的集中管理的服务器,保存所有文件的修订版本,而协同工作的人们都通过客户端连到这台服务器,取出最新的文件或者提交更新. 多年以来,这已成为版本控制系统的标准做法.  
**缺点**：当中央服务器的单点故障,谁也无法提交更新,也就无法协同工作.如果中心数据库所在磁盘发生损坏,又没有做恰当备份,毫无疑问你将丢失所有数据--包括项目整个的变更历史,只剩下人们在各自机器上保留的单独快照.  

### 分布式版本控制系统  

**起因**：为了解决上面两者的缺点  
**结果**：分布式版本控制系统（Distributed Version Control System,简称 DVCS）面世了.在这类系统中,像Git,Mercurial以及Darcs等,客户端并不只提取最新版本的文件快照,而是把代码仓库完整地镜像下来,包括完整的历史记录.  
**优点**：**任何一处协同工作用的服务器发生故障,事后都可以用任何一个镜像出来的本地仓库恢复.** 因为每一次的克隆操作,实际上都是对代码仓库的完整备份.**更进一步,许多这类系统都可以指定和若干不同的远端代码交互.** 籍此,你就可以在同一个项目中,分别和不同工作小组的人相互协作.你可以根据需要设定不同的协作流层,比如层次模型式的工作流,而这在以前的集中式系统中是无法实现的.  

## Git简史  

**创建年代**：2005年    
**创建原因**：Linux内核开源项目有着为数众多的参与者.绝大多数的Linux内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991-2002),到2002年,整个项目组开始启用一个专有的分布式版本控制系统BitKeeper来管理和维护代码.2005年,开发BitKeeper的商业公司同Linux内核开源社区的合作关系结束,他们收回了Linux内核社区免费使用BitKeeper的权利.这就迫使Linux开源社区(特备是Linux的缔造者Linux Torvalds)基于使用BitKeeper时的经验教训,开发出自己的版本系统.他们对新的系统制定了若干目标：
- 速度
- 简单的设计
- 对非线性开发模式的强力支持(允许成千上万个并行开发的分支)
- 完全分布式
- 有能力高效管理类似Linux内核一样的超大规模项目(速度和数据量)   

**结果**：自诞生于2005年以来,Git日臻成熟完善,在高度易用的同时,仍然保留初期设定的目标.它的速度飞快,极其适合管理大项目,有着令人难以置信的非线性分支管理系统.  

>BitKeeper之所以不让社区继续使用的原因是有位开发者破解了它的协议被公司发现了于是停止了合作,据说Git的开发用了两周就写完了.  

## Git介绍  

>**注意！！！**：在学习 Git 时,请尽量理清你对其它版本管理系统已有的认识,如 CVS,Subversion 或 Perforce, 这样能帮助你使用工具时避免发生混淆.尽管 Git 用起来与其它的版本控制系统非常相似, 但它在对信息的存储和认知方式上却有很大差异,理解这些差异将有助于避免使用中的困惑.  

### 直接记录快照,而非差异比较  

Git 和其它版本控制系统（包括 Subversion 和近似工具）的**主要差别在于 Git 对待数据的方式.**  

从**概念**上来说,**其它大部分系统**：以**文件变更列表**的方式存储信息,这类系统（CVS,Subversion,Perforce 等等） 将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 （它们通常称作 **基于差异（delta-based）** 的版本控制）.

Git 不按照以上方式对待或保存数据.反之,**Git 更像是把数据看作是对小型文件系统的一系列快照.** 在 Git 中,每当你提交更新或保存项目状态时,它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引. **为了效率,如果文件没有修改,Git 不再重新存储该文件,而是只保留一个链接指向之前存储的文件.** Git 对待数据更像是一个 **快照流.**  

Git 更像是一个小型的文件系统,提供了许多以此为基础构建的超强工具,而不只是一个简单的VCS工具.  

### 近乎所有操作都是本地执行  

在 Git 中的绝大多数操作都只需要访问本地文件和资源,一般不需要来自网络上其它计算机的信息.因为你在本地磁盘上就有项目的完整历史,所以大部分操作看起来瞬间完成.  

### Git 保持完整性  

**Git 中所有的数据在存储前都计算校验和,然后以校验和来引用.** 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容.

**Git 用以计算校验和的机制叫做 SHA-1 散列（hash,哈希）.** 基于 Git 中文件的内容或目录结构计算出来.如：  `24b9da6552552987aa493b52f8696cd6d3b00373`  

**实际上,Git 数据库中保存的信息都是以文件内容的哈希值来索引,而不是文件名.**  

### Git一般只添加数据  

你执行的 Git 操作,几乎只往 Git 数据库中**添加**数据. 你很难使用 Git 从数据库中**删除**数据,也就是说 Git 几乎不会执行任何可能导致文件不可恢复的操作.

>真要在快照里删除数据也行.

### 三种状态   

**Git有三种状态**：
- 已提交(committed)：表示修改了文件,但还没保存到数据库中
- 已修改(modified)：表示对一个已修改文件的当前版本做了标记,使之包含在下次提交的快照中
- 已暂存(staged)：表示数据已经安全地保存在了本地数据库中

**Git项目的三个区**：
- 工作区：是对**某个版本独立**提取出来的内容,放在磁盘上供你修改或使用
- 暂存区：是一个文件,保存了下次将要提交的文件列表信息,一般在Git仓库目录中.按照Git术语叫“索引”
- Git目录：是Git用来保存项目的元数据和对象数据库的地方.这是Git中最重要的部分,克隆就是复制这里的数据   

Git的工作流程：
1. 在工作区修改文件
2. 将你想要下次提交的更改选择性地暂存,这样只会将更改的部分添加到暂存区
3. 提交更新,找到暂存区文件,将快照永久性存储到Git目录  

## Git配置  


Git 自带一个 `git config` 的工具来帮助设置控制 Git 外观和行为的配置变量.这些变量存储在：
1. `/etc/gitconfig` 文件: 包含系统上每一个用户及他们仓库的通用配置. 如果在执行 `git config` 时带上 `--system` 选项,那么它就会读写该文件中的配置变量. （由于它是系统配置文件,因此你需要管理员或超级用户权限来修改它）
2. `~/.gitconfig` 或 `~/.config/git/config` 文件：只针对当前用户. 你可以传递 `--global` 选项让 Git 读写此文件,这会对你系统上**所有**的仓库生效
3. 当前使用仓库的 Git 目录中的 `config` 文件（即 `.git/config` ）：针对该仓库. 你可以传递 `--local` 选项让 Git 强制读写此文件,虽然默认情况下用的就是它. （当然,你需要进入某个 Git 仓库中才能让该选项生效）

>每一个级别会覆盖上一级别的配置,所以 `.git/config` 的配置变量会覆盖 `/etc/gitconfig` 中的配置变量.  

你可以通过以下命令查看所有的配置以及它们所在的文件：
```$ git config --list --show-origin```  

Git能够识别的配置项分为两大类：
- 客户端
- 服务器端

可以使用 `man git-config` 查阅支持的配置.      



### 初次运行Git 

安装完Git之后,要做的第一件事就是设置你的用户名和邮件地址.它们会写入到你的每一次提交中,不可更改：
`$ git config --global user.name <username>` 写入到 `~/.gitconfig`   
`$ git config --global user.email <useremail>` 写入到 `~/.gitconfig`  
想针对特定的项目使用特定的用户名和邮箱,可以在那个项目下运行没有 `--global` 的选项命令来配置. 

接着需要配置文本编辑器  
`$ git config --global core.editor <editor>` 配置文本编辑器  

`git config --list` 检查配置信息  

>可能会有重复,因为会从不同文件读取同一个配置.    

`git config <key>` 检查Git的某一项配置     
如 `git config user.name`     

### 客户端配置    

**commit.template**     

如果把此项指定为你的系统上某个文件的路径,当你提交的时候, Git 会使用该文件的内容作为提交的默认初始化信息.

**core.pager**    

该配置项指定 Git 运行诸如 `log` 和 `diff` 等命令所使用的分页器.(default：less)    

**user.signingkey**     

如果你要创建经签署的含附注的标签,那么把你的GPG签署密钥设置为配置项会更好.

**core.excludesfile**    

这个配置允许你设置类似于全局生效的 `.gitignore` 文件.       

**help.autochorrect**    

自动纠错.      

**color.ui**     

Git 会自动着色大部分输出内容,但如果你不喜欢花花绿绿,也可以关掉.       

**core.autocrlf**    

转换换行.     

**core.whitespace**    

空白字符配置.    

### 服务器端配置    

**receive.fsck0bjects**    

设置是否确认每个对象的有效性以及SHA-1检验和是否保持一致.

**receive.denyNonFastForwards**    

是否禁用强制更新推送.       

**receive.denyDeletes**     

是否禁止推送删除分支和标签.

### Git属性    

你也可以针对特定的路径配置某些设置项,这样 Git 就只对特定的子目录或子文件集运用它们. 这些基于路径的设置项被称为 Git 属性,可以在你的目录下的 `.gitattributes` 文件内进行设置（通常是你的项目的根目录）.如果不想让这些属性文件与其它文件一同提交,你也可以在 `.git/info/attributes` 文件中进行设置.     

通过使用属性,你可以对项目中的文件或目录单独定义不同的合并策略,让 Git 知道怎样比较非文本文件,或者让 Git 在提交或检出前过滤内容.     

可以做：
- 识别二进制文件 
- 比较二进制文件
- 关键字展开
- 导出版本库
- 合并策略

### Git钩子   

和其它版本控制系统一样,Git 能在特定的重要动作发生时触发自定义脚本.有两组这样的钩子：  
- 客户端的：客户端钩子由诸如提交和合并这样的操作所调用  
	- 提交工作流钩子    
	- 电子邮件工作流钩子
	- 其他钩子
- 服务器端的：服务器端钩子作用于诸如接收被推送的提交这样的联网操作


### 安装一个钩子    

钩子都被存储在 Git 目录下的 `hooks` 子目录中.      

当你用 `git init` 初始化一个新版本库时,Git 默认会在这个目录中放置一些示例脚本. 这些脚本除了本身可以被调用外,它们还透露了被触发时所传入的参数. 所有的示例都是 shell 脚本,其中一些还混杂了 Perl 代码,不过,任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python,或任何你熟悉的语言编写它们. 这些示例的名字都是以 `.sample` 结尾,如果你想启用它们,得先移除这个后缀.   

把一个正确命名（不带扩展名）且可执行的文件放入 `.git` 目录下的 `hooks` 子目录中,即可激活该钩子脚本. 这样一来,它就能被 Git 调用.     


### .gitignore

`.gitignore` 忽略文件,格式规范如下：
- 所有空行或者以 `#` 开头的行都会被Git忽略
- 可以使用标准的glob模式匹配,它会递归地应用在整个工作区中
- 匹配模式可以以( `/` )开头防止递归
- 匹配模式可以以( `/` )结尾指定目录
- 要忽略指定模式以外的文件或目录,可以在模式前加个叹号( `!` )取反   
>**glob模式**      
>指shell所使用的简化了的正则表达式.星号( `*` )匹配零个或多个任意字符, `[abc]`  匹配任何一个列在方括号中的字符,问号( `?` )只匹配一个任意字符,如果在方括号中使用短划线分隔两个字符,表示所有在这两个字符范围内的都可以匹配( `[0-9]` 表示匹配0到9的数字).使用两个星号( `**` )表示匹配任意中间目录,如 `a/**/z` 可以匹配 `a/z` `a/b/z`等.  

[GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表](https://github.com/github/gitignore)  

### Git别名  

可以用 `git config --global alias.<alias> <command>` 来设置别名.   

在创建你认为应该存在的命令时这个技术会很有用. 例如,为了解决取消暂存文件的易用性问题,可以向 Git 中添加你自己的取消暂存别名：

```console
$ git config --global alias.unstage 'reset HEAD --'
```

可以看出,Git 只是简单地将别名替换为对应的命令. 然而,你可能想要执行外部命令,而不是一个 Git 子命令. 如果是那样的话,可以在命令前面加入 `!` 符号. 如果你自己要写一些与 Git 仓库协作的工具的话,那会很有用. 我们现在演示将 `git visual` 定义为 `gitk` 的别名：

```console
$ git config --global alias.visual '!gitk'
```


## Git基础  

### Git仓库
通常用两种获取Git项目仓库的方式：
1. 利用 `git init` 命令将尚未进行版本控制的本地目录转换为Git仓库
2. 利用 `git clone <url> <name>` 命令从其他服务器克隆一个已存在的Git仓库   

### 更新
工作目录下的每一个文件都不外乎这两种状态：
- 已跟踪：指那些被纳入了版本控制的文件,在上一次快照中有它们的记录,在工作一段时间后,它们的状态可能是[未修改、已修改或已放入暂存区](#三种状态),总之,它是Git已知道的文件.
- 未跟踪：除了已跟踪文件外就是未跟踪文件,既不存在于上次的快照记录中,也没有被放入暂存区.

可以用 `git status` 命令检查哪些文件都处于什么状态.
- 可以加 `-s\--short` 参数,用简洁的方式查看更改,简短会将状态变为两栏,左栏为暂存区的状态,右栏为工作区的状态.  

可以用 `git add <files>` 命令去跟踪一个文件,将文件添加至暂存区,把有冲突的文件标记为已解决状态.**已暂存的文件若修改,则需再次使用该命令,提交时只会提交最后一次使用该命令的文件版本.** 使用文件或目录的路径作为参数,如果参数是目录的路径,该命令将递归地跟踪该目录下的所有文件.名字可以用通配符.  

可以用 `git diff` 命令查看已暂存和未暂存的修改.
- 不加参数,查看尚未暂存的文件更新了哪些部分
- 加 `--staged` 参数,这条命令将比对已暂存文件与最后一次提交的文件差异
- 使用 `git difftool --tool-help` 命令来看你的系统都支持哪些git diff插件   

>**注意**,`git diff` 本身只显示尚未暂存的改动,而不是自上次提交以来所做的所有改动. 所以有时候你一下子暂存了所有更新过的文件,运行 `git diff` 后却什么也没有,就是这个原因.  

可以用 `git commit` 命令去提交一个快照.
- 加 `-m` 参数,将提交信息与命令放在同一行
- 加 `-a` 参数,自动把所有已经更新过的文件暂存起来一并提交,从而跳过 `git add` 步骤

可以用 `git rm <files>` 命令去移除某个文件.
- 加 `-f` 参数,去强制删除之前修改过或已经放到暂存区的文件
- 加 `--cached` 参数,只从暂存区域中移除     

>`git rm` **命令后面可以列出文件或者目录的名字,也可以使用 `glob` 模式.比如**：
>`$ git rm log/\*.log`   
>**注意到星号 `*` 之前的反斜杠 `\`, 因为 Git 有它自己的文件模式扩展匹配方式,所以我们不用shell 来帮忙展开.** 此命令删除 `log/` 目录下扩展名为 `.log` 的所有文件. 类似的比如：~  
>`$ git rm \*~`   
>该命令会删除所有名字以 `~` 结尾的文件.   

可以用 `git mv <source> <destination>` 命令来对文件改名.   
相当于   
```
mv <source> <destination>  
kgit rm <source>  
git add <destination>  
```

### 查看提交历史   

可以使用 `git log` 命令查看提交历史.   
- 没有参数的情况下,会按时间先后顺序列出所有的提交,最近的更新排在最上面
- 加 `-p\--patch` 参数,它会按补丁格式显示出每个提交所引入的差异
- 加 `-n` 参数,显示最近n次提交
- 加 `--stat` 参数,查看提交的简略统计信息
	- `--shortstat` 参数,只显示最后的行数修改统计
- 加 `--name-only` 仅在提交信息后显示以修改的文件清单
- 加 `--name-status` 显示新增、修改、删除的文件清单
- 加 `--abbrev-commit` 仅显示SHA-1校验和所有40个字符中的前几个字符
- 加 `--relative-date` 使用较短的相对时间而不是完整格式显示日期(如"2 weeks age")
- 加 `--pretty` 参数,可以使用不同的默认格式的方式展示提交历史
	- `--pretty=oneline` 将每个提交放在一行显示
	- `--pretty=short` 
	- `--pretty=full` 
	- `--pretty=fuller` 
	- `--pretty=format` 定制记录的显示格式
- 加 `--graph` 参数,在日志旁以ASCII图形显示分支与合并记录
- 加 `--since\--after` 参数,仅显示指定时间之后的提交
- 加 `--until\--before` 参数,仅显示指定时间之前的提交
- 加 `--committer` 参数,仅显示提交者匹配指定字符串的提交
- 加 `--author` 参数,显示指定作者匹配指定字符串的提交
- 加 `--grep` 参数,仅显示提交说明中包含指定字符出的提交 
- 加 `-S <string>` 参数,仅显示添加或删除内容匹配指定字符串的提交
- 加 `-- <path>` 参数,查找某些文件或目录的提交
- 加 `--no-merges` 选项,隐藏合并提交
- 加 `--decorate` 查看各个分支当前所指的对象   

>你可以指定多个 `--author` 和 `--grep` 搜索条件,这样会只输出匹配**任意** `--author` 模式和**任意** `--grep` 模式的提交.然而,如果你添加了 `--all-match` 选项, 则只会输出匹配**所有** `--grep` 模式的提交.

>**作者与提交者**  
>作者指的是实际作出修改的人,提交者指的是最后将此工作成果提交到仓库的人.  

>其实也并不是在任何情况下都是所有,但你用 `git reset --hard` 切换到旧记录,此时并不会显示所有提交,因为这时的master分支跑到了旧分支, `log` 按分支节点递归查找,所有会丢失后面的提交. 

表1. format常用格式

| 选项    | 说明                          |
| ----- | --------------------------- |
| `%H`  | 提交的完整哈希值                    |
| `%h`  | 提交的简写哈希值                    |
| `%T`  | 树的完整哈希值                     |
| `%t`  | 树的简写哈希值                     |
| `%P`  | 父提交的完整哈希值                   |
| `%p`  | 父提交的简写哈希值                   |
| `%an` | 作者名字                        |
| `%ae` | 作者的电子邮件地址                   |
| `%ad` | 作者修订日期（可以用 --date=选项 来定制格式） |
| `%ar` | 作者修订日期,按多久以前的方式显示           |
| `%cn` | 提交者的名字                      |
| `%ce` | 提交者的电子邮件地址                  |
| `%cd` | 提交日期                        |
| `%cr` | 提交日期（距今多长时间）                |
| `%s`  | 提交说明                        |

### 撤销

>**注意,有些撤消操作是不可逆的. 这是在使用 Git 的过程中,会因为操作失误而导致之前的工作丢失的少有的几个地方之一.**   

可以用 `git commit --amend` 命令覆盖上一次的提交.

>修补提交最明显的价值是可以稍微改进你最后的提交,而不会让“啊,忘了添加一个文件”或者 “小修补,修正笔误”这种提交信息弄乱你的仓库历史.   

可以用 `git reset HEAD <file>` 命令来取消暂存.  

>`git reset` 确实是个危险的命令,如果加上了 `--hard` 选项则更是如此.然而在上述场景中,工作目录中的文件尚未修改,因此相对安全一些.   

可以用 `git checkout -- <file>` 命令来撤销文件的修改.  

>请务必记得 `git checkout — <file>` 是一个危险的命令. 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它. 除非你确实清楚不想要对那个文件的本地修改了,否则请不要使用这个命令.   

>记住,在 Git 中任何**已提交**的东西几乎总是可以恢复的. 甚至那些被删除的分支中的提交或使用 `--amend` 选项覆盖的提交也可以恢复.然而,任何你未提交的东西丢失后很可能再也找不到了.    

### 远程仓库   

**介绍**：远程仓库是指托管在因特网或其他网络中的你的项目的版本库. 你可以有好几个远程仓库,通常有些仓库对你只读,有些则可以读写. 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据. **管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪**等等.   

>**远程仓库可以在你的本地主机上**   
>你完全可以在一个“远程”仓库上工作,而实际上它在你本地的主机上. 词语“远程”未必表示仓库在网络或互联网上的其它位置,而只是表示它在别处. 在这样的远程仓库上工作,仍然需要和其它远程仓库上一样的标准推送、拉取和抓取操作.

可以用 `git remote` 命令去查看你已经配置的远程仓库服务器.
- 加 `-v` 参数,会显示需要读写远程仓库使用的简写与其对应的URL  

可以用 `git remote add <shortname> <url>` 命令添加一个新的远程Git仓库.同时指定一个方便的简写.   

可以用 `git fetch <remote>` 命令从远程仓库中获得数据,这个命令会访问远程仓库,从中拉取所有你还没有的数据. 执行完成后,你将会拥有那个远程仓库中所有分支的引用,可以随时合并或查看.  

>必须注意 `git fetch` 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作. 当准备好时你必须手动将其合并入你的工作.   

可以用 `git pull` 命令来自动抓取后台合并该远程分支到当前分支.     

>前提是你的当前分支设置了跟踪远程分支,默认情况下,`git clone` 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 `master` 分支（或其它名字的默认分支）.    

可以用 `git push` 命令将本地进度推送到上游.    

>必须要有写入权限,并且之前没有人推送过时,这条命令才能生效.当你和其他人在同一时间克隆,他们先推送到上游然后你再推送到上游,你的推送就会毫无疑问地被拒绝. 你必须先抓取他们的工作并将其合并进你的工作后才能推送.   

可以用 `git remote show <remote>` 命令去查看一个远程仓库的更多信息. 

可以用 `git remote <rename>` 命令修改一个远程仓库的简写名.   

可以用 `git remote remove <remotename>` 命令可以去移除一个远程仓库.   

### 标签  

可以用 `git tag -l\--list` 命令以字母顺序列出已有的标签.  

>默认的 `git tag` 给出的就是完整的标签列表,要用通配符的话,需要有 `-l\--list` 参数.   

标签有两种：
- 轻量标签：很像一个不会改变的分支——它只是某个特定提交的引用.  
- 附注标签：是存储在 Git 数据库中的一个完整对象, 它们是可以被校验的,其中包含打标签者的名字、电子邮件地址、日期时间, 此外还有一个标签信息,并且可以使用 GNU Privacy Guard (GPG)签名并验证.   

>通常会建议创建附注标签,这样你可以拥有以上所有信息.但是如果你只是想用一个临时的标签, 或者因为某些原因不想要保存这些信息,那么也可以用轻量标签.  

#### 附注标签  

可以用 `git tag -a <tag> -m <message>` 创建, `-m` 指定了一条将会存储在标签中的信息.如果没有为附注标签指定一条信息,Git会启动编辑器要求你输入信息.

可以用 `git show <tagname>` 命令查看标签信息与和与之对应的提交信息.  

#### 轻量标签   

轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息.   

创建轻量标签,不需要使用 `-a`,`-s` 或 `-m` 选项,只需要提供标签名字.如   
`git tag v1.1`   

这时用 `git show <tagname>` 只会显示提交提交信息.    

#### 后期打标签  

可以用 `git tag -a <tagname> <hashkey>` 给特定的记录打上标签.  

#### 共享标签  

默认情况下,`git push` 命令并不会传送标签到远程仓库服务器上. 在创建完标签后你必须显式地推送标签到共享服务器上.   
可以用 `git push <remotename> <tagname>` 进行推送.
- 加 `-tags` 参数,把所有不在远程仓库服务器上的标签全部传送到那里.   

>使用 `git push <remote> --tags` 推送标签并不会区分轻量标签和附注标签, 没有简单的选项能够让你只选择推送一种标签.  

#### 删除标签   

可以用 `git tag -d <tagname>` 删除本地仓库上的标签.

>上述命令并不会从任何远程仓库中移除这个标签.

可以用 `git push <remote> :refs/tags/<tagname>` 或者 `git push <remote> --delete <tagname>` 命令,去删除远程仓库的标签.   

>上面这种操作的含义是,将冒号前面的空值推送到远程标签名,从而高效地删除它.   

#### 检出标签  

可以用 `git checkout <tagname>` 去查看某个标签所指向的文件版本.

>这会使你的仓库处于“**分离头指针（detached HEAD）**”的状态——这个状态有些不好的副作用：**在“分离头指针”状态下,如果你做了某些更改然后提交它们,标签不会发生变化, 但你的新提交将不属于任何分支,并且将无法访问,除非通过确切的提交哈希才能访问.**  

## Git分支   

### 分支简介  

有人把 Git 的分支模型称为它的“必杀技特性”,也正因为这一特性,使得 Git 从众多版本控制系统中脱颖而出.     

在进行提交操作时,Git 会保存一个**提交对象（commit object）**. 知道了 Git 保存数据的方式,我们可以很自然的想到——该**提交对象会包含一个指向暂存内容快照的指针**.但不仅仅是这样,该提交对象**还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针.**   

>**首次提交产生的提交对象没有父对象,普通提交操作产生的提交对象有一个父对象, 而由多个分支合并产生的提交对象有多个父对象.**  

暂存操作会为每一个文件计算校验和(SHA-1 哈希算法）,然后会把当前版本的文件快照保存到 Git 仓库中 (Git 使用 **blob 对象**来保存它们) .   

当使用 `git commit` 进行提交操作时,Git 会先计算每一个子目录（本例中只有项目根目录）的校验和, 然后在 Git 仓库中这些校验和保存为**树对象**.随后,Git 便会创建一个提交对象, 它除了包含上面提到的那些信息外,还包含指向这个树对象（项目根目录）的指针. 如此一来,Git 就可以在需要的时候重现此次保存的快照.   

**blob对象**：保存着文件快照.     
**树对象**：记录着目录结构和blob 对象索引.      
**提交对象**：包含着指向前述树对象的指针和所有提交信息.       

**Git 的分支,其实本质上仅仅是指向提交对象的可变指针.** Git 的默认分支名字是 `master`. 在多次提交操作之后,你其实已经有一个指向最后那个提交对象的 `master` 分支. `master` 分支会在每次提交时自动向前移动.

>Git 的 `master` 分支并不是一个特殊分支. 它就跟其它分支完全没有区别. 之所以几乎每一个仓库都有 master 分支,是因为 `git init` 命令默认创建它,并且大多数人都懒得去改动它.

**Git有一个名为 `HEAD` 的特殊指针.** 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 `HEAD` 概念完全不同. 在 Git 中,它是一个指针,指向当前所在的本地分支.

>`HEAD` 会如同你的影子一般跟随你   
>PS：一次就好,我带你去看天荒地老～   

由于 Git 的分支实质上仅是包含所指对象校验和(长度为 40 的 SHA-1 值字符串)的文件,所以它的创建和销毁都异常高效. 创建一个新分支就相当于往一个文件中写入 41 个字节(40 个字符和 1 个换行符）,如此的简单能不快吗?      

### 分支的创建与合并   

可以用 `git branch <branchname>` 创建分支.   
- 加 `-d` 参数,可以删除分支
- 加 `-D` 参数,可以强制删除分支  

可以用 `git checkout -b` 创建分支并切换过去.    

可以用 `git merge` 命令合并分支.    

>合并时使用三方合并——两个分支所指的快照以及这两个分支的公共祖先.

>当合并时,要合并的分支是当前分支的直接后继,那么Git会直接将指针向前移动.因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”.     

>当合并分支时,不同的分支都涉及了对同一个文件的同一个部分进行了不同的修改,那么合并时会产生合并冲突.**任何因包含合并冲突而有待解决的文件,都会以未合并状态标识出来. Git 会在有冲突的文件中加入标准的冲突解决标记**,这样你可以打开这些包含冲突的文件然后手动解决冲突.   

### 分支管理    

可以用 `git branch` 命令查看分支列表.    
- 加 `-v` 参数,查看每一个分支的最后一次提交
- 加 `--merged` 参数,查看已经合并的分支   
- 加 `--no-merged` 参数,查看尚未合并的分支  

>上面描述的选项 `--merged` 和 `--no-merged` 会在没有给定提交或分支名作为参数时, 分别列出已合并或未合并到 **当前** 分支的分支.你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们.   

### 远程分支      

#### 远程跟踪分支   

**远程跟踪分支是远程分支状态的引用.它们是你无法移动的本地引用**.一旦你进行了网络通信, Git 就会为你移动它们以精确反映远程仓库的状态.请将它们看做书签, 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置.它们以 `<remote>/<branch>` 的形式命名.     

可以用 `git push <remote> <branch>` 命令将本地的分支推送到远端分支.
- `git push <remote> <branch>:<remotebranch>` 命令将本地的分支推送到远端 `<remotebranch>` 上

可以用 `git ls-remote <remote>` 命令来显式地获得远程引用的完整列表.   

> [!tip] 抓取远程分支时    
> 要特别注意的一点是当抓取到新的远程跟踪分支时,本地不会自动生成一份可编辑的副本（拷贝）. 换一句话说,这种情况下,不会有一个新的 `serverfix` 分支——只有一个不可以修改的 `origin/serverfix` 指针.
#### 跟踪分支  

从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”(它跟踪的分支叫做“上游分支”）. 跟踪分支是与远程分支有直接关系的本地分支. 如果在一个跟踪分支上输入 `git pull`,Git 能自动地识别去哪个服务器上抓取、合并到哪个分支.

可以用 `git checkout --track <remotebranch>` 命令跟踪远端分支.   
- `git checkout -b <branch> <remote>/<branch>` 创建一个分支跟踪远端分支  

> [!tip]
> 如果你尝试检出的本地分支不存在且远端分支刚好只有一个名字与之匹配的远程分支,那么 Git 就会为你创建一个跟踪分支.

> [!tip] 上游快捷方式    
>当设置好跟踪分支后,可以通过简写 `@{upstream}` 或 `@{u}` 来引用它的上游分支. 所以在 `master` 分支时并且它正在跟踪 `origin/master` 时,如果愿意的话可以使用 `git merge @{u}` 来取代 `git merge origin/master`.

可以用 `git branch -vv` 命令根据本地数据查看所有跟踪分支以及进度.

> [!tip] 如果想要统计最新的领先与落后数字,需要在运行此命令前抓取所有的远程仓库. 可以像这样做：    
>
>```console
>$ git fetch --all; git branch -vv
>```

#### 拉取  

当 `git fetch` 命令从服务器上抓取本地没有的数据时,它并不会修改工作目录中的内容. 它只会获取数据然后让你自己合并.    

有一个命令叫作 `git pull` 在大多数情况下它的含义是一个 `git fetch` 紧接着一个 `git merge` 命令.   

>由于 `git pull` 的魔法经常令人困惑所以通常单独显式地使用 `fetch` 与 `merge` 命令会更好一些.   

#### 删除远端分支  

可以用 `git push <remote> --delete <remotename>` 删除一个远端分支.

### 变基    

在 Git 中整合来自不同分支的修改主要有两种方法：
- `merge` 合并：详见[分支的创建与合并](#分支的创建与合并)
- `rebase` 变基：将提交到某一分支上的所有修改都移至另一分支上,就好像“重新播放”一样.  

> [!tip] 原理    
> 首先找到这两个分支的最近共同祖先,然后对比当前分支相对于该祖先的历次提交,提取相应的修改并存为临时文件, 然后将当前分支指向目标基底,最后以此将之前另存为临时文件的修改依序应用.

`git rebase --onto <目标基底分支> <旧的基底分支> <要移动的分支>` 将要移动的分支从旧的基底分支分离出来变基到目标基底分支.   

`git rebase <basebranch> <topicbranch>` 命令可以直接将主题分支变基到目标分支上.   

变基完成后,进行合并.     

> [!warning] 奇妙的变基也并非完美无缺,要用它得遵守一条准则      
> 如果提交存在于你的仓库之外,而别人可能基于这些提交进行开发,那么不要执行变基.如果你遵循这条金科玉律,就不会出差错. 否则,人民群众会仇恨你,你的朋友和家人也会嘲笑你,唾弃你.

**变基操作的实质是丢弃一些现有的提交,然后相应地新建一些内容一样但实际上不同的提交.**  

> [!tip] 如果你在多人协作的仓库上使用了变基--用变基解决变基     
> 实际上,Git 除了对整个提交计算 SHA-1 校验和以外,也对本次提交所引入的修改计算了校验和——即 "patch-id".如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话,一般情况下 Git 都能成功分辨出哪些是你的修改,并把它们应用到新分支上.  
> 举个例子,如果遇到前面提到的有人推送了经过变基的提交,并丢弃了你的本地开发所基于的一些提交那种情境,如果我们不是执行合并,而是执行 `git rebase <remote>/<branch>`, Git 将会：
> - 检查哪些提交是我们的分支上独有的
> - 检查其中哪些提交不是合并操作的结果
> - 检查哪些提交在对方覆盖更新时并没有被纳入目标分支
> - 把查到的这些提交应用在远程分支上面     
> 
>也可以用 `git pull --rebase` 命令,代替 `git fetch;git rebase` 命令.

> [!tip] 变基 vs. 合并      
> 变基会该改变提交的记录,合并不会,为此,根据自己的需求选择合适的方式.
> > [!warning] 但记住      
> > 总的原则是,只对尚未推送或分享给别人的本地修改执行变基操作清理历史, 从不对已推送至别处的提交执行变基操作,这样,你才能享受到两种方式带来的便利.

## 服务器上的Git   

一个远程仓库通常只是一个裸仓库(bare repository)——即一个没有当前工作目录的仓库.因为该仓库仅仅作为合作媒介,不需要从磁盘检查快照；存放的只有Git的资料.即只有 `.git` 子目录的内容,不包含其他资料.    

一般的做法里,会同时提供SSH或者HTTPS协议的访问服务,只让少数几个开发者有推送(写)权限,其他人通过 `git://` 访问只有读权限.

### 协议   

Git可以使用四种不同的协议来传输资料：
- 本地协议(Local protocol)
- HTTP协议
- SSH协议(Secure Shell)
- Git协议

#### 本地协议(Local protocol)    

最基本的就是本地协议,其中的远程版本库就是同一主机上的另一个目录.这常见于团队每一个成员都对一个共享的文件系统(例如一个挂载的NFS)拥有访问权,或者比较少见的多人共用同一台电脑的情况.后者并不理想,因为你的所有代码版本库如果长存于同一台电脑,更可能发生灾难性的损失.     

如果你使用共享文件系统,就可以从本地版本库克隆(clone）、推送(push)以及拉取(pull）. 像这样去克隆一个版本库或者增加一个远程到现有的项目中,**使用版本库路径作为 URL**. 例如,克隆一个本地版本库,可以执行如下的命令：    
`$ git clone /srv/git/project.git`     
或你可以执行这个命令：  
`$ git clone file:///srv/git/project.git`     

> [!tip]    
>如果在 URL 开头明确的指定 `file://`,那么 Git 的行为会略有不同.   
>如果仅是指定路径,Git 会尝试使用硬链接（hard link）或直接复制所需要的文件.  
>如果指定 `file://`,Git 会触发平时用于网路传输资料的进程,那样传输效率会更低.  
>指定 `file://` 的主要目的是取得一个没有外部参考(extraneous references)或对象(object)的干净版本库副本——通常是在从其他版本控制系统导入后或一些类似情况需要这么做      

要增加一个本地版本库到现有的 Git 项目,可以执行如下的命令：     
`$ git remote add local_proj /srv/git/project.git`       

**优点**   
- 简单
- 直接使用了现有的文件权限和网络访问权限    

**缺点**      
- 通常共享文件系统比较难配置
- 比起基本的网络连接访问,这不方便从多个位置访问
- 相比网络连接的访问方式,配置不方便,速度也慢
- 不保护仓库避免意外的损失,每一个用户都有完整的权限,没有方法可以阻止他们修改或删除Git内部文件和损坏仓库

#### HTTP协议  

**Git 通过 HTTP 通信有两种模式**.在 Git 1.6.6 版本之前只有一个方式可用,十分简单并且通常是只读模式的.Git 1.6.6 版本引入了一种新的、更智能的协议,让 Git 可以像通过 SSH 那样智能的协商和传输数据. 之后几年,这个新的 HTTP 协议因为其简单、智能变的十分流行. 新版本的 HTTP 协议一般被称为**智能**HTTP 协议,旧版本的一般被称为**哑**HTTP 协议.   

**智能HTTP协议**    
智能HTTP的运行方式和SSH及Git协议类似,只是运行在标准的HTTP/S端口上并且可以使用各种HTTP验证机制, 这意味着使用起来会比SSH协议简单的多,比如可以使用HTTP协议的用户名/密码授权,免去设置SSH公钥.     
智能HTTP协议或许已经是最流行的使用Git的方式了,它既支持像 `git://` 协议一样设置匿名服务, 也可以像SSH协议一样提供传输时的授权和加密.而且只用一个URL就可以都做到,省去了为不同的需求设置不同的URL.如果你要推送到一个需要授权的服务器上(一般来讲都需要）,服务器会提示你输入用户名和密码. 从服务器获取数据时也一样.

**哑HTTP协议**   
如果服务器没有提供智能HTTP协议的服务,Git 客户端会尝试使用更简单的“哑”HTTP协议. 哑HTTP协议里web服务器仅把裸版本库当作普通文件来对待,提供文件服务.哑HTTP协议的优美之处在于设置起来简单.基本上,只需要把一个裸版本库放在HTTP根目录,设置一个叫做 `post-update` 的挂钩就可以了.    

通常的,会在可以提供读／写的智能 HTTP 服务和简单的只读的哑 HTTP 服务之间选一个. 极少会将二者混合提供服务.   

**优点——我们将只关注智能 HTTP 协议的优点**     
- 不同的访问方式只需要一个URL以及服务器只在需要授权时提示输入授权信息,这两个简便性让终端用户使用Git变得非常简单
- 相比SSH协议,可以使用用户名／密码授权是一个很大的优势,这样用户就不必须在使用Git之前先在本地生成SSH密钥对再把公钥上传到服务器. 对非资深的使用者,或者系统上缺少SSH相关程序的使用者,HTTP协议的可用性是主要的优势.
- 与SSH协议类似,HTTP协议也非常快和高效
- 你也可以在HTTPS协议上提供只读版本库的服务,如此你在传输数据的时候就可以加密数据；或者,你甚至可以让客户端使用指定的 SSL 证书
- HTTPS协议被广泛使用,一般的企业防火墙都会允许这些端口的数据通过

**缺点**    
- 在一些服务器上,架设HTTPS协议的服务端会比SSH协议的棘手一些.除了这一点,用其他协议提供Git服务与智能HTTP协议相比就几乎没有优势了
- 如果你在HTTP上使用需授权的推送,管理凭证会比使用SSH密钥认证麻烦一些. 然而,你可以选择使用凭证存储工具,比如macOS的Keychain或者Windows的凭证管理器   

#### SSH协议

架设Git服务器时常用SSH协议作为传输协议. 因为大多数环境下服务器已经支持通过SSH访问 —— 即使没有也很容易架设.SSH协议也是一个验证授权的网络协议；并且,因为其普遍性,架设和使用都很容易.

通过SSH协议克隆版本库,你可以指定一个 `ssh://` 的URL：
`$ git clone ssh://[user@]server/project.git`     
或者使用一个简短的scp式的写法：   
`$ git clone [user@]server:project.git`    
在上面两种情况中,如果你不指定可选的用户名,那么 Git 会使用当前登录的用户的名字.      

**优点**    
- SSH 架设相对简单 —— SSH 守护进程很常见,多数管理员都有使用经验,并且多数操作系统都包含了它及相关的管理工具
- 通过 SSH 访问是安全的 —— 所有传输数据都要经过授权和加密
- 与 HTTPS 协议、Git 协议及本地协议一样,SSH 协议很高效,在传输前也会尽量压缩数据

**缺点**   
- 在于它不支持匿名访问 Git 仓库   

#### Git协议     

这是包含在Git里的一个特殊的守护进程；它监听在一个特定的端口(9418）,类似于SSH服务,但是访问无需任何授权.要让版本库支持Git协议,需要先创建一个 `git-daemon-export-ok` 文件——它是Git协议守护进程为这个版本库提供服务的必要条件——但是除此之外没有任何安全措施. 要么谁都可以克隆这个版本库,要么谁也不能.    

**优点**   
- Git 协议是 Git 使用的网络传输协议里最快的
- 它使用与 SSH 相同的数据传输机制,但是省去了加密和授权的开销

**缺点**  
- 缺乏授权机制
-  Git 协议也许也是最难架设的,它要求有自己的守护进程,这就要配置 `xinetd`、`systemd` 或者其他的程序,这些工作并不简单. 它还要求防火墙开放 9418 端口,但是企业防火墙一般不会开放这个非标准端口. 而大型的企业防火墙通常会封锁这个端口.

### 在服务器上搭建Git   

在开始架设Git服务器前,需要把现有仓库导出为裸仓库——即一个不包含当前工作目录的仓库. 这通常是很简单的. 为了通过克隆你的仓库来创建一个新的裸仓库,你需要在克隆命令后加上 `--bare` 选项.按照惯例,裸仓库的目录名以 .git 结尾   

整体上效果大致相当于 `$ cp -Rf my_project/.git my_project.git`   

虽然在配置文件中有若干不同,但是对于你的目的来说,这两种方式都是一样的. 它只取出 Git 仓库自身,不要工作目录,然后特别为它单独创建一个目录. 

既然你有了裸仓库的副本,剩下要做的就是把裸仓库放到服务器上并设置你的协议.    

>如果一个用户,通过使用 SSH 连接到一个服务器,并且其对 `/srv/git/my_project.git` 目录拥有可写权限,那么他将自动拥有推送权限. 

如果只是和几个人在一个私有项目上合作的话,仅仅是一个SSH服务器和裸仓库就足够了.   

**小型安装**    
如果设备较少或者你只想在小型开发团队里尝试 Git ,那么一切都很简单. 架设 Git 服务最复杂的地方在于用户管理. 如果需要仓库对特定的用户可读,而给另一部分用户读写权限,那么访问和许可安排就会比较困难.   

**SSH连接**    
如果需要团队里的每个人都对仓库有写权限,又不能给每个人在服务器上建立账户,那么提供 SSH 连接就是唯一的选择了. 我们假设用来共享仓库的服务器已经安装了 SSH 服务,而且你通过它访问服务器.   
有几个方法可以使你给团队每个成员提供访问权：
1. 就是给团队里的每个人创建账号,这种方法很直接但也很麻烦. 或许你不会想要为每个人运行一次 `adduser`(或者 `useradd` )并且设置临时密码.
2. 是在主机上建立一个 'git' 账户,让每个需要写权限的人发送一个SSH公钥, 然后将其加入git账户的 `~/.ssh/authorized_keys` 文件. 这样一来,所有人都将通过 'git' 账户访问主机. 这一点也不会影响提交的数据——访问主机用的身份不会影响提交对象的提交者信息.
3. 让SSH服务器通过某个LDAP服务,或者其他已经设定好的集中授权机制,来进行授权. 只要每个用户可以获得主机的shell访问权限,任何SSH授权机制你都可视为是有效的.   

### 生成SSH公钥   

如前所述,许多Git服务器都使用SSH公钥进行认证. 为了向Git服务器提供SSH公钥,如果某系统用户尚未拥有密钥,必须事先为其生成一份. 这个过程在所有操作系统上都是相似的. 首先,你需要确认自己是否已经拥有密钥. 默认情况下,用户的 SSH 密钥存储在其 `~/.ssh` 目录下.   

我们需要寻找一对以 `id_dsa` 或 `id_rsa` 命名的文件,其中一个带有 `.pub` 扩展名. `.pub` 文件是你的公钥,另一个则是与之对应的私钥. 如果找不到这样的文件（或者根本没有 `.ssh` 目录）,你可以通过运行 `ssh-keygen` 程序来创建它们.     

首先 `ssh-keygen` 会确认密钥的存储位置（默认是 `.ssh/id_rsa`）,然后它会要求你输入两次密钥口令. 如果你不想在使用密钥时输入口令,将其留空即可. 然而,如果你使用了密码,那么请确保添加了 `-o` 选项,它会以比默认格式更能抗暴力破解的格式保存私钥. 你也可以用 `ssh-agent` 工具来避免每次都要输入密码.      

现在,进行了上述操作的用户需要将各自的公钥发送给任意一个Git服务器管理员 （假设服务器正在使用基于公钥的SSH验证设置）. 他们所要做的就是复制各自的 `.pub` 文件内容,并将其通过邮件发送.

### 配置服务器    

> [!note]
> 以下操作可通过 `ssh-copy-id` 命令自动完成,这样就不必手动复制并安装公钥了.  

首先,创建一个操作系统用户 `git`,并为其建立一个 `.ssh` 目录.    

接着,我们需要为系统用户 `git` 的 `authorized_keys` 文件添加一些开发者 SSH 公钥. 假设我们已经获得了若干受信任的公钥,并将它们保存在临时文件中.   

将这些公钥加入系统用户 `git` 的 `.ssh` 目录下 `authorized_keys` 文件的末尾.

现在我们来为开发者新建一个空仓库.可以借助带 `--bare` 选项的 `git init` 命令来做到这一点,该命令在初始化仓库时不会创建工作目录.

请注意,每添加一个新项目,都需要有人登录服务器取得shell,并创建一个裸仓库.    

需要注意的是,目前所有（获得授权的）开发者用户都能以系统用户 `git` 的身份登录服务器从而获得一个普通shell. 如果你想对此加以限制,则需要修改 `/etc/passwd` 文件中(`git` 用户所对应)的shell值.

借助一个名为 `git-shell` 的受限shell工具,你可以方便地将用户 `git` 的活动限制在与 Git 相关的范围内. 该工具随Git软件包一同提供.如果将 `git-shell` 设置为用户 `git` 的登录shell(login shell), 那么该用户便不能获得此服务器的普通 shell 访问权限. 若要使用 `git-shell`,需要用它替换掉bash或csh,使其成为该用户的登录 shell. 为进行上述操作,首先你必须确保 `git-shell` 的完整路径名已存在于 `/etc/shells` 文件中.    
现在你可以使用 `chsh <username> -s <shell>` 命令修改任一系统用户的shell.这样,用户 `git` 就只能利用SSH连接对Git仓库进行推送和拉取操作,而不能登录机器并取得普通shell. 如果试图登录,你会发现尝试被拒绝.   

此时,用户仍可通过 SSH 端口转发来访问任何可达的 git 服务器. 如果你想要避免它,可编辑 `authorized_keys` 文件并在所有想要限制的公钥之前添加以下选项：     
```console
no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty
```

现在,网络相关的 Git 命令依然能够正常工作,但是开发者用户已经无法得到一个普通 shell 了. 正如输出信息所提示的,你也可以在 `git` 用户的主目录下建立一个目录,来对 `git-shell` 命令进行一定程度的自定义. 比如,你可以限制掉某些本应被服务器接受的 Git 命令,或者对刚才的 SSH 拒绝登录信息进行自定义,这样,当有开发者用户以类似方式尝试登录时,便会看到你的信息. 要了解更多有关自定义 shell 的信息,请运行 `git help shell`.     

### Git守护进程   

>请注意,因为其不包含授权服务,任何通过该协议管理的内容将在其网络上公开.     

如果运行在防火墙之外的服务器上,它应该只对那些公开的只读项目服务. 如果运行在防火墙之内的服务器上,它可用于支撑大量参与人员或自动系统 （用于持续集成或编译的主机）只读访问的项目,这样可以省去逐一配置 SSH 公钥的麻烦.   

无论何时,该 Git 协议都是相对容易设定的. 通常,你只需要以守护进程的形式运行该命令：

```console
$ git daemon --reuseaddr --base-path=/srv/git/ /srv/git/
```

`--reuseaddr` 选项允许服务器在无需等待旧连接超时的情况下重启,而 `--base-path` 选项允许用户在未完全指定路径的条件下克隆项目, 结尾的路径将告诉Git守护进程从何处寻找仓库来导出. 如果有防火墙正在运行,你需要开放端口9418的通信权限.    

由于在现代的Linux发行版中,`systemd` 是最常见的初始化系统,因此你可以用它来达到此目的. 只要在 `/etc/systemd/system/git-daemon.service` 中放一个文件即可,其内容如下：

```console
[Unit]
Description=Start Git Daemon

[Service]
ExecStart=/usr/bin/git daemon --reuseaddr --base-path=/srv/git/ /srv/git/

Restart=always
RestartSec=500ms

StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=git-daemon

User=git
Group=git

[Install]
WantedBy=multi-user.target
```

你可能会注意这里以 `git` 启动的Git驻留程序同时使用了Group和User权限.按需修改它并确保提供的用户在此系统上.此外,请确保Git二进制文件位于 `/usr/bin/git`,必要时可修改此路径.最后,你需要运行 `systemctl enable git-daemon` 以让它在系统启动时自动运行, 这样也能让它通过 `systemctl start git-daemon` 启动,通过 `systemctl stop git-daemon` 停止.     

在其他系统中,你可以使用 `sysvinit` 系统中的 `xinetd` 脚本,或者另外的方式来实现——只要你能够将其命令守护进程化并实现监控.    

接下来,你需要告诉 Git 哪些仓库允许基于服务器的无授权访问. 你可以在每个仓库下创建一个名为 `git-daemon-export-ok` 的文件来实现.    

```console
$ cd /path/to/project.git
$ touch git-daemon-export-ok
```

该文件将允许Git提供无需授权的项目访问服务.     

### Smart HTTP 

我们一般通过SSH进行授权访问,通过git:// 进行无授权访问,但是还有一种协议可以同时实现以上两种方式的访问. 设置Smart HTTP一般只需要在服务器上启用一个Git自带的名为 `git-http-backend` 的CGI脚本. 该CGI脚本将会读取由 `git fetch` 或 `git push` 命令向 HTTP URL发送的请求路径和头部信息, 来判断该客户端是否支持HTTP通信（不低于 1.6.6 版本的客户端支持此特性）. 如果CGI发现该客户端支持智能(Smart)模式,它将会以智能模式与它进行通信, 否则它将会回落到哑(Dumb)模式下(因此它可以对某些老的客户端实现向下兼容）.      

在完成以上简单的安装步骤后, 我们将用Apache来作为CGI服务器. 如果你没有安装 Apache,你可以在Linux环境下执行如下或类似的命令来安装：   

```console
$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env
```

该操作将会启用 `mod_cgi`, `mod_alias` 和 `mod_env` 等Apache模块, 这些模块都是使该功能正常工作所必须的.    

你还需要将 `/srv/git` 的Unix用户组设置为 `www-data`,这样 Web 服务器才能读写该仓库, 因为运行CGI脚本的Apache实例默认会以该用户的权限运行：     

```console
$ chgrp -R www-data /srv/git
```

接下来我们要向Apache配置文件添加一些内容,来让 `git-http-backend` 作为Web服务器对 `/git` 路径请求的处理器.     

```console
SetEnv GIT_PROJECT_ROOT /srv/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/
```

如果留空 `GIT_HTTP_EXPORT_ALL` 这个环境变量,Git将只对无授权客户端提供带 `git-daemon-export-ok` 文件的版本库,就像Git守护进程一样.     

最后,如果想让 Apache 允许 `git-http-backend` 请求并实现写入操作的授权验证,使用如下授权屏蔽配置即可：    

```console
<Files "git-http-backend">
    AuthType Basic
    AuthName "Git Access"
    AuthUserFile /srv/git/.htpasswd
    Require expr !(%{QUERY_STRING} -strmatch '*service=git-receive-pack*' || %{REQUEST_URI} =~ m#/git-receive-pack$#)
    Require valid-user
</Files>
```

这需要你创建一个包含所有合法用户密码的 `.htpasswd` 文件. 以下是一个添加 “schacon” 用户到此文件的例子：   

```console
$ htpasswd -c /srv/git/.htpasswd schacon
```

你可以通过许多方式添加Apache授权用户,选择使用其中一种方式即可. 以上仅仅只是我们可以找到的最简单的一个例子. 如果愿意的话,你也可以通过SSL运行它,以保证所有数据是在加密状态下进行传输的.   

>Apache的主要原理是使用一个Git附带的,名为 `git-http-backend` 的CGI.它被引用来处理协商通过HTTP发送和接收的数据. 它本身并不包含任何授权功能,但是授权功能可以在Web服务器层引用它时被轻松实现. 你可以在任何所有可以处理CGI的Web服务器上办到这点,所以随便挑一个你最熟悉的 Web 服务器试手吧.    

### GitWeb

如果你对项目有读写权限或只读权限,你可能需要建立起一个基于网页的简易查看器. Git提供了一个叫做GitWeb的CGI脚本来做这项工作.     

如果你想要查看GitWeb如何展示你的项目,并且在服务器上安装了轻量级Web服务器比如 `lighttpd` 或 `webrick` ,Git提供了一个命令来让你启动一个临时的服务器. 在Linux系统的电脑上,`lighttpd` 通常已经安装了,所以你只需要在项目目录里执行 `git instaweb` 命令即可. 如果你使用Mac系统,Mac OS X Leopard系统已经预安装了Ruby,所以 `webrick` 或许是你最好的选择. 如果不想使用lighttpd启动 `instaweb` 命令,你需要在执行时加入 `--httpd` 参数.    

这个命令启动了一个监听1234端口的HTTP服务器,并且自动打开了浏览器. 这对你来说十分方便. 当你已经完成了工作并想关闭这个服务器,你可以执行同一个命令,并加上 `--stop` 选项.     

如果你现在想为你的团队或你托管的开源项目持续的运行这个页面,你需要通过普通的Web服务器来设置CGI脚本. 一些Linux发行版的软件库有 `gitweb` 包,可以通过 `apt` 或 `dnf` 来安装,你可以先试试. 接下来我们来快速的了解一下如何手动安装GitWeb.      

首先,你需要获得Git的源代码,它包含了GitWeb,并可以生成自定义的CGI脚本   
```console
$ git clone git://git.kernel.org/pub/scm/git/git.git
$ cd git/
$ make GITWEB_PROJECTROOT="/srv/git" prefix=/usr gitweb
    SUBDIR gitweb
    SUBDIR ../
make[2]: `GIT-VERSION-FILE' is up to date.
    GEN gitweb.cgi
    GEN static/gitweb.js
$ sudo cp -Rf gitweb /var/www/
```

>需要注意的是,你需要在命令中指定 `GITWEB_PROJECTROOT` 变量来让程序知道你的 Git 版本库的位置.   

现在,你需要在 Apache 中使用这个CGI脚本,你需要为此添加一个虚拟主机：

```console
<VirtualHost *:80>
    ServerName gitserver
    DocumentRoot /var/www/gitweb
    <Directory /var/www/gitweb>
        Options +ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
        AllowOverride All
        order allow,deny
        Allow from all
        AddHandler cgi-script cgi
        DirectoryIndex gitweb.cgi
    </Directory>
</VirtualHost>
```

### GitLab

GitLab是一个数据库支持的 web 应用,所以相比于其他 git 服务器,它的安装过程涉及到更多的东西. 幸运的是,这个过程有非常详细的文档说明和支持.   

**下载**：    
- 下载虚拟机镜像
- [bitnami获取一键安装包](https://bitnami.com/stack/gitlab) 同时调整配置使之符合你特定的环境.Bitnami的一个优点在于它的登录界面(通过alt+->键),会告诉你安装好的GitLab的IP地址以及默认的用户名和密码

无论如何,跟着[GitLab社区版的readme](https://gitlab.com/gitlab-org/gitlab-ce/tree/master)文件一步步来,在这里你将会在主菜单中找到安装GitLab的帮助,一个可以在Digital Ocean上运行的虚拟机,以及RPM和DEB包（都是测试版）. 这里还有 “非官方” 的引导让GitLab运行在非标准的操作系统和数据库上,一个全手动的安装脚本,以及许多其他的话题.     

**管理**：    
GitLab 的管理界面是通过网络进入的. 将你的浏览器转到已经安装 GitLab 的 主机名或 IP 地址,然后以管理员身份登录即可. 默认的用户名是 `admin@local.host`,默认的密码是 `5iveL!fe`（你会得到类似 请登录后尽快更换密码 的提示）. 登录后,点击主栏上方靠右位置的 “Admin area” 图标进行管理.     

## 分布式Git 

### 工作流程    

#### 集中式工作流

通常使用的是单点协作模型.一个中心仓库,可以接受代码,所有人将自己的工作与之同步.   

这意味着如果两个开发者从中心仓库克隆代码下来,同时作了一些修改,那么只有第一个开发者可以顺利地把数据推送回共享服务器. 第二个开发者在推送修改之前,必须先将第一个人的工作合并进来,这样才不会覆盖第一个人的修改. 这和 Subversion （或任何 CVCS）中的概念一样,而且这个模式也可以很好地运用到 Git 中.    

#### 集成管理者工作流

Git 允许多个远程仓库存在,使得这样一种工作流成为可能：每个开发者拥有自己仓库的写权限和其他所有人仓库的读权限. 这种情形下通常会有个代表“官方”项目的权威的仓库. 要为这个项目做贡献,你需要从该项目克隆出一个自己的公开仓库,然后将自己的修改推送上去. 接着你可以请求官方仓库的维护者拉取更新合并到主项目. 维护者可以将你的仓库作为远程仓库添加进来,在本地测试你的变更,将其合并入他们的分支并推送回官方仓库.即：
1. 项目维护者推送到主仓库
2. 贡献者克隆此仓库,做出修改
3. 贡献将数据推送到自己的公开仓库
4. 贡献者给维护者发送邮件,请求拉取自己的更新,即PR(Pull request)   
5. 维护者在自己本地的仓库中,将贡献者的仓库加为远程仓库并合并修改
6. 维护者将合并后的修改推送到主仓库

#### 主管与副主管工作流   
 
这其实是多仓库工作流程的变种. 一般拥有数百位协作开发者的超大型项目才会用到这样的工作方式,例如著名的 Linux 内核项目.    

副主管负责集成项目中的特定部分,所有这些副主管的头上有一位主管负责统筹,主管维护的仓库作为参考仓库,为所有协作者提供他们需要拉取的项目代码.即：   
1. 普通开发者在自己的主题分支上工作,并根据 `master` 分支进行变基.这里的 `master` 分支为主管推送的参考仓库的 `master` 分支
2. 副主管将普通开发者的主题分支合并到自己的 `master` 分支中
3. 主管将所有副主管的 `master` 分支并入自己的 `master` 分支中
4. 最后,主管将集成后的 `master` 分支推送到参考仓库中,以便所有其他开发者以此为基础进行变基

### 向一个项目贡献

#### 提交准则   

在我们开始查看特定的用例前,这里有一个关于提交信息的快速说明. 有一个好的创建提交的准则并且坚持使用会让与 Git 工作和与其他人协作更容易. Git 项目提供了一个文档,其中列举了关于创建提交到提交补丁的若干好的提示——可以在 Git 源代码中的`Documentation/SubmittingPatches` 文件中阅读它.     

首先,你的提交不应该包含任何空白错误. Git 提供了一个简单的方式来检查这点——在提交前,运行 `git diff --check`,它将会找到可能的空白错误并将它们为你列出来.     

接下来,尝试让每一个提交成为一个逻辑上的独立变更集.如果可以,尝试让改动可以理解——不要在整个周末编码解决五个问题,然后在周一时将它们提交为一个巨大的提交.   

最后一件要牢记的事是提交信息. 有一个创建优质提交信息的习惯会使 Git 的使用与协作容易的多. 一般情况下,信息应当以少于 50 个字符（25个汉字）的单行开始且简要地描述变更,接着是一个空白行,再接着是一个更详细的解释.Git 项目要求一个更详细的解释,包括做改动的动机和它的实现与之前行为的对比——这是一个值得遵循的好规则. 使用指令式的语气来编写提交信息,比如使用“Fix bug”而非“Fixed bug”或“Fixes bug”.  这里是一份[最初由 Tim Pope 写的模板](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)：   

>Git 项目有一个良好格式化的提交信息——尝试在那儿运行 `git log --no-merges` 来看看漂亮的格式化的项目提交历史像什么样.  

#### 私有小型团队   

[集中式工作流](#集中式工作流)   

#### 私有管理团队    

[主管与副主管工作流](#主管与副主管工作流)  

#### 派生的公开项目    

[集成管理者工作流](#集成管理者工作流)    

#### 通过邮件的公开项目  

与上者相似,区别为生成每一个提交序列的电子邮件版本然后邮寄它们到开发者邮件列表,而不是派生项目然后推送到你自己的可写版本.  
可以用 `git format-patch` 命令来生成可以邮寄到列表的mbox格式文件——它将每一个提交转换为一封电子邮件,提交信息的第一行作为主题,剩余信息与提交引入的补丁作为正文.它有一个好处是使用 `format-patch` 生成的一封电子邮件应用的提交正确地保留了所有的提交信息.       

### 维护项目   

#### 在分支中工作    

如果你想向项目中整合一些新东西,最好将这些尝试局限在**主题分支**——一种通常用来尝试新东西的临时分支中. 这样便于单独调整补丁,如果遇到无法正常工作的情况,可以先不用管,等到有时间的时候再来处理.        

#### 应用来自邮件的补丁   

如果你通过电子邮件收到了一个需要整合进入项目的补丁,你需要将其应用到主题分支中进行评估.有两种应用该种补丁的方法：      
- `git apply`
- `git am` 

**apply**：      
如果你收到了一个使用 `git diff` 或 Unix `diff` 命令的变体（不推荐使用这种方式,具体见下一节） 创建的补丁,可以使用 `git apply` 命令来应用.    

这会修改工作目录中的文件. 它与运行 `patch -p1` 命令来应用补丁几乎是等效的,但是这种方式更加严格,相对于 patch 来说,它能够接受的模糊匹配更少.    

与 `patch` 对比：
- 它也能够处理 `git diff` 格式文件所描述的文件添加、删除和重命名操作,而 `patch` 则不会.
- 最后,`git apply` 命令采用了一种“全部应用,否则就全部撤销(apply all or abort all）”的模型, 即补丁只有全部内容都被应用和完全不被应用两个状态,而 `patch` 可能会导致补丁文件被部分应用, 最后使你的工作目录保持在一个比较奇怪的状态.
- 总体来看,`git apply` 命令要比 `patch` 谨慎得多. 并且,它不会为你创建提交——在运行之后,你需要手动暂存并提交补丁所引入的更改. 

在实际应用补丁前,你还可以使用 git apply 来检查补丁是否可以顺利应用——即对补丁运行 `git apply --check` 命令,如果没有产生输出,则该补丁可以顺利应用. 如果检查失败了,该命令还会以一个非零的状态退出,所以需要时你也可以在脚本中使用它.    

**am**：    
要应用一个由 `format-patch` 命令生成的补丁,你应该使用 `git am` 命令(该命令的名字 `am` 表示它“应用(Apply)一系列来自邮箱(Mailbox)的补丁”）. 从技术的角度看,`git am` 是为了读取mbox文件而构建的.

>mbox是一种用来在单个文本文件中存储一个或多个电子邮件消息的简单纯文本格式.    

如果你所使用的邮件客户端能够同时将多封邮件保存为mbox格式的文件, 你甚至能够将一系列补丁打包为单个mbox文件,并利用 `git am` 命令将它们一次性全部应用.    

如果贡献者将 `git format-patch` 生成的补丁文件上传到工单系统或类似的任务处理系统, 你可以先将其保存到本地,之后通过 `git am` 来应用补丁.    

你会看到补丁被顺利地应用,并且为你自动创建了一个新的提交.    

但是,有时候无法顺利地应用补丁. 这也许是因为你的主分支和创建补丁的分支相差较多,也有可能是因为这个补丁依赖于其他你尚未应用的补丁. 这种情况下,`git am` 进程将会报错并且询问你要做什么.**该命令将会在所有出现问题的文件内加入冲突标记,就和发生冲突的合并或变基操作一样**. 而你解决问题的手段很大程度上也是一样的——即手动编辑那些文件来解决冲突,暂存新的文件, 之后运行 `git am --resolved` 继续应用下一个补丁 .    

如果你希望 Git 能够尝试以更加智能的方式解决冲突,你可以对其传递 `-3` 选项来使 Git 尝试进行三方合并. 该选项默认并没有打开,因为如果用于创建补丁的提交并不在你的版本库内的话,这样做是没有用处的. 而如果你确实有那个提交的话——比如补丁是基于某个公共提交的——那么通常 `-3` 选项对于应用有冲突的补丁是更加明智的选择.      

当与你的特性相关的所有补丁都被应用并提交到分支中之后,你就可以选择是否以及如何将其整合到更长期的分支中去了.   

#### 检出远程分支   

如果你的贡献者建立了自己的版本库,并且向其中推送了若干修改, 之后将版本库的 URL 和包含更改的远程分支发送给你,那么你可以将其添加为一个远程分支,并且在本地进行合并.   

这对于与他人长期合作工作来说很有用. 而对于提交补丁频率较小的贡献者,相对于每个人维护自己的服务器,不断增删远程分支的做法,使用电子邮件来接收可能会比较省时. 况且你也不会想要加入数百个只提供一两个补丁的远程分支. 然而,脚本和托管服务在一定程度上可以简化这些工作——这很大程度上依赖于你和你的贡献者开发的方式.   

这种方式的另一种优点是你可以同时得到提交历史. 虽然代码合并中可能会出现问题,但是你能获知他人的工作是基于你的历史中的具体哪一个位置；所以 Git 会默认进行三方合并,不需要提供 `-3` 选项,你也不需要担心补丁是基于某个你无法访问的提交生成的.      

对于非持续性的合作,如果你依然想要以这种方式拉取数据的话,你可以对远程版本库的 URL 调用 `git pull` 命令. 这会执行一个一次性的抓取,而不会将该 URL 存为远程引用.    

#### 确定引入了哪些东西    

一般来说,你应该对该分支中所有 `master` 分支尚未包含的提交进行检查. 通过在分支名称前加入 `--not` 选项,你可以排除 `master` 分支中的提交.     

如果要查看每次提交所引入的具体修改,你应该记得可以给 `git log` 命令传递 `-p` 选项,这样它会在每次提交后面附加对应的差异（diff）.    

Git 提供了一种比较便捷的方式：三点语法. 对于 `git diff` 命令来说,你可以通过把 `…​` 置于另一个分支名后来对该分支的最新提交与两个分支的共同祖先进行比较：    

```console
$ git diff master...contrib
```

**该命令仅会显示自当前主题分支与 `master` 分支的共同祖先起,该分支中的工作. 这个语法很有用,应该牢记.**     

#### 将贡献的工作整合进来     

当主题分支中所有的工作都已经准备好整合进入更靠近主线的分支时,接下来的问题就是如何进行整合了. 此外,还有一个问题是,你想使用怎样的总体工作流来维护你的项目？     

##### 合并工作流   

一种基本的工作流就是将所有的工作直接合并到 `master` 分支. 在这种情况下,`master` 分支包含的代码是基本稳定的. 当你完成某个主题分支的工作,或审核通过了其他人所贡献的工作时,你会将其合并进入 `master` 分支,之后将主题分支删除,如此反复.    

如果你的项目非常重要,你可能会使用两阶段合并循环. 在这种情况下,你会维护两个长期分支,分别是 `master` 和 `develop`,`master` 分支只会在一个非常稳定的版本发布时才会更新,而所有的新代码会首先整合进入 `develop` 分支. 你定期将这两个分支推送到公共版本库中.每次需要合并新的主题分支时,你都应该合并进入 `develop` 分支,当打标签发布的时候,你会将 `master` 分支快进到已经稳定的 `develop` 分支.    

你也可以扩展这个概念,维护一个将所有工作合并到一起的整合分支. 当该分支的代码稳定并通过测试之后,将其合并进入 `develop` 分支； 经过一段时间,确认其稳定之后,将其以快进的形式并入 `master` 分支.   

##### 大项目合并工作流    

Git 项目包含四个长期分支：`master`,`next`,用于新工作的 `pu`（proposed updates）和用于维护性向后移植工作（maintenance backports）的 `maint` 分支.之后对主题分支进行测试评估,检查其是否已经能够合并,或者仍需要更多工作. 安全的主题分支会被合并入 `next` 分支,之后该分支会被推送使得所有人都可以尝试整合到一起的特性.如果主题分支需要更多工作,它则会被并入 `pu` 分支. 当它们完全稳定之后,会被再次并入 `master` 分支. 这意味着 `master` 分支始终在进行快进,`next` 分支偶尔会被变基,而 `pu` 分支的变基比较频繁.Git 项目还有一个从上一次发布中派生出来的 `maint` 分支来提供向后移植过来的补丁以供发布维护更新.       

##### 变基与拣选工作流

为了保持线性的提交历史,有些维护者更喜欢在 `master` 分支上对贡献过来的工作进行变基和拣选,而不是直接将其合并. 当你完成了某个主题分支中的工作,并且决定要将其整合的时候,你可以在该分支中运行变基命令, 在当前 `master` 分支（或者是 `develop` 等分支）的基础上重新构造修改. 如果结果理想的话,你可以快进 `master` 分支,最后得到一个线性的项目提交历史.    

Git 中的拣选类似于对特定的某次提交的变基. 它会提取该提交的补丁,之后尝试将其重新应用到当前分支上. 这种方式在你只想引入主题分支中的某个提交,或者主题分支中只有一个提交,而你不想运行变基时很有用.    

`git cherry-pick <hashkey>` 拣选命令.     

##### Rerere   

如果你在进行大量的合并或变基,或维护一个长期的主题分支,Git 提供的一个叫做“rerere”的功能会有一些帮助.    

Rerere是“重用已记录的冲突解决方案（reuse recorded resolution）”的意思——它是一种简化冲突解决的方法. 当启用rerere时,Git将会维护一些成功合并之前和之后的镜像,当Git发现之前已经修复过类似的冲突时, 便会使用之前的修复方案,而不需要你的干预.    

这个功能包含两个部分：    
- 一个配置选项
- 一个命令

其中的配置选项是 `rerere.enabled`,把它放在全局配置中就可以了：       

```console
$ git config --global rerere.enabled true
```

现在每当你进行一次需要解决冲突的合并时,解决方案都会被记录在缓存中,以备之后使用.   

如果你需要和 rerere 的缓存交互,你可以使用 `git rerere` 命令. 当单独调用它时,Git 会检查解决方案数据库,尝试寻找一个和当前任一冲突相关的匹配项并解决冲突(尽管当 `rerere.enabled` 被设置为 `true` 时会自动进行）. 它也有若干子命令,可用来查看记录项,删除特定解决方案和清除缓存全部内容等.      

##### 为发布打标签    

当你决定进行一次发布时,你可能想要打一个标签,这样在之后的任何一个提交点都可以重新创建该发布.    

如果你为标签签名了,你可能会遇到分发用来签名的 PGP 公钥的问题. Git 项目的维护者已经解决了这一问题,其方法是在版本库中以 blob 对象的形式包含他们的公钥,并添加一个直接指向该内容的标签.   
1. 要完成这一任务,首先你可以通过运行 `gpg --list-keys` 找出你所想要的key.        
2. 之后你可以通过导出 key 并通过管道传递给 `git hash-object` 来直接将 key 导入到 Git 的数据库中,`git hash-object` 命令会向 Git 中写入一个包含其内容的新 blob 对象,并向你返回该 blob 对象的SHA-1值.      
3. 既然 Git 中已经包含你的 key 的内容了,你就可以通过指定由 `hash-object` 命令给出的新SHA-1值来创建一个直接指向它的标签.如果你运行 `git push --tags` 命令,那么标签将会被共享给所有人. 需要校验标签的人可以通过从数据库中直接拉取 blob 对象并导入到 GPG 中来导入PGP key.   
人们可以使用这个 key 来校验所有由你签名的标签. 另外,如果你在标签信息中包含了一些操作说明,用户可以通过运行 `git show <tag>` 来获取更多关于标签校验的说明.      

##### 生成一个构建号   

Git中不存在随每次提交递增的“v123”之类的数字序列,如果你想要为提交附上一个可读的名称, 可以对其运行 `git describe` 命令.作为回应,Git将会生成一个字符串, 它由最近的标签名、自该标签之后的提交数目和你所描述的提交的部分SHA-1值(前缀的 `g` 表示Git)构成.   

这样你在导出一个快照或构建时,可以给出一个便于人们理解的命名. 实际上,如果你的Git是从Git自己的版本库克隆下来并构建的,那么 `git --version` 命令给出的结果是与此类似的. **如果你所描述的提交自身就有一个标签,那么它将只会输出标签名,没有后面两项信息.**    

**默认情况下, `git describe` 命令需要有注解的标签（即使用 `-a` 或 `-s` 选项创建的标签）**； 如果你想使用轻量标签（无注解的标签）,请在命令后添加 `--tags` 选项. 你也可以使用这个字符串来调用 `git checkout` 或 `git show` 命令, 但是这依赖于其末尾的简短SHA-1值,因此不一定一直有效. 比如,最近Linux内核为了保证SHA-1值对象的唯一性,将其位数由8位扩展到了10位, 导致以前的 `git describe` 输出全部失效.

##### 准备一次发布  

现在你可以发布一个构建了. 其中一件事情就是为那些不使用 Git 的可怜包们创建一个最新的快照归档. 使用 `git archive` 命令完成此工作.   

如果有人将这个压缩包解压,他就可以在一个 `project` 目录中得到你项目的最新快照. 你也可以以类似的方式创建一个zip压缩包,但此时你应该向 `git archive` 命令传递 `--format=zip` 选项.    

##### 制作提交简报     

使用 `git shortlog` 命令可以快速生成一份包含从上次发布之后项目新增内容的修改日志(changelog)类文档. 它会对你给定范围内的所有提交进行总结.   

这份整洁的总结包括了自上一次版本以来的所有提交,并且已经按照作者分好组,你可以通过电子邮件将其直接发送到列表中.      

## Git高级操作    

### 选定提交    

#### 单个修订版本    

**简短的SHA-1**     

Git十分智能,你只需要提供SHA-1的前几个字符就可以获得对应的那次提交, 当然你提供的SHA-1字符数量不得少于4个,并且没有歧义——也就是说, 当前对象数据库中没有其它对象以这段SHA-1开头.     

> [!note] 许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同. 然后呢？     
> 
如果你真的向仓库里提交了一个对象,它跟之前的某个不同对象的SHA-1值相同,Git会发现该对象的散列值已经存在于仓库里了,于是就会认为该对象被写入,然后直接使用它. 如果之后你想检出那个对象时,你将得到先前那个对象的数据.    
但是这种情况发生的概率十分渺小.SHA-1摘要长度是20字节,也就是160位.2^80 个随机哈希对象才有50%的概率出现一次冲突 （计算冲突机率的公式是 `p = (n(n-1)/2) * (1/2^160))` ）.2^80是1.2x10^24,也就是一亿亿亿,这是地球上沙粒总数的1200倍.    

**引用日志**     

`git reflog` 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史.每当你的 HEAD 所指向的位置发生了变化,Git 就会将这个信息存储到引用日志这个历史记录里.你也可以通过 reflog 数据来获取之前的提交历史.     

如果你想查看仓库中 HEAD 在五次前的所指向的提交,你可以使用 `@{n}` 来引用 reflog 中输出的提交记录, `git show HEAD@{5}`    

你同样可以使用这个语法来查看某个分支在一定时间前的位置. 例如,查看你的 `master` 分支在昨天的时候指向了哪个提交,你可以输入 `git show master@{yesterday}`     

可以运行 `git log -g` 来查看类似于 `git log` 输出格式的引用日志信息.    

>值得注意的是,引用日志只存在于本地仓库,它只是一个记录你在自己的仓库里做过什么的日志. 其他人拷贝的仓库里的引用日志不会和你的相同,而你新克隆一个仓库的时候,引用日志是空的,因为你在仓库里还没有操作.   

**祖先引用**      

祖先引用是另一种指明一个提交的方式. 如果你在引用的尾部加上一个 `^`（脱字符）, Git 会将其解析为该引用的上一个提交.你也可以在 `^` 后面添加一个数字来指明想要哪一个父提交.     

另一种指明祖先提交的方法是 `~`（波浪号）.

>两者在没有加数字时是等价的,加数字时 `^` 代表第几个父提交, `~` 代表第几个父提交.    

#### 提交区间   

**双点**    

这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交.      

你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支. 你可以使用 `master..experiment` 来让 Git 显示这些提交.也就是“在 experiment 分支中而不在 master 分支中的提交”.反过来,如果你想查看在 `master` 分支中而不在 `experiment` 分支中的提交,你只要交换分支名即可.        

**多点**    

双点语法很好用,但有时候你可能需要两个以上的分支才能确定你所需要的修订, 比如查看哪些提交是被包含在某些分支中的一个,但是不在你当前的分支上.Git允许你在任意引用前加上 `^` 字符或者 `--not` 来指明你不希望提交被包含其中的分支.        

**三点**    

最后一种主要的区间选择语法是三点,这个语法可以选择出被两个引用之一包含但又不被两者同时包含的提交.    

这种情形下,`log` 命令的一个常用参数是 `--left-right`,它会显示每个提交到底处于哪一侧的分支.     

### 交互式暂存    

本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交. 当你在修改了大量文件后,希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时,这几个工具会非常有用. 通过这种方式,可以确保提交是逻辑上独立的变更集,同时也会使其他开发者在与你工作时很容易地审核. 如果运行 `git add` 时使用 `-i` 或者 `--interactive` 选项,Git 将会进入一个交互式终端模式.     

Git 也可以暂存文件的特定部分.在和上一节一样的交互式提示符中,输入 `p` 或 `5`（补丁）. Git 会询问你想要部分暂存哪些文件；然后,对已选择文件的每一个部分,它都会一个个地显示文件区别并询问你是否想要暂存它们.    

也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 `git add -p` 或 `git add --patch` 来启动同样的脚本.      

更进一步地,可以使用 `git reset --patch` 命令的补丁模式来部分重置文件, 通过 `git checkout --patch` 命令来部分检出文件与 `git stash save --patch` 命令来部分暂存文件.

### 贮藏与清理    

**贮藏**     

有时,当你在项目的一部分上已经工作一段时间后,所有东西都进入了混乱的状态, 而这时你想要切换到另一个分支做一点别的事情. 问题是,你不想仅仅因为过会儿回到这一点而为做了一半的工作创建一次提交. 针对这个问题的答案是 `git stash` 命令.    

贮藏（stash）会处理工作目录的脏的状态——即跟踪文件的修改与暂存的改动——然后将未完成的修改保存到一个栈上, 而你可以在任何时候重新应用这些改动（甚至在不同的分支上）.    

你的修改被存储在栈上. 要查看贮藏的东西,可以使用 `git stash list` .    

可以通过原来 stash 命令的帮助提示中的命令将你刚刚贮藏的工作重新应用：`git stash apply`.如果想要应用其中一个更旧的贮藏,可以通过名字指定它,像这样：`git stash apply stash@{2}` .       

并不是必须要有一个干净的工作目录,或者要应用到同一分支才能成功应用贮藏. 可以在一个分支上保存一个贮藏,切换到另一个分支,然后尝试重新应用这些修改. 当应用贮藏时工作目录中也可以有修改与未提交的文件——如果有任何东西不能干净地应用,Git 会产生合并冲突.    
**清理**    

对于工作目录中一些工作或文件,你想做的也许不是贮藏而是移除. `git clean` 命令就是用来干这个的.     

清理工作目录有一些常见的原因,比如说为了移除由合并或外部工具生成的东西, 或是为了运行一个干净的构建而移除之前构建的残留.     

**你需要谨慎地使用这个命令,因为它被设计为从工作目录中移除未被追踪的文件.** 如果你改变主意了,你也不一定能找回来那些文件的内容. 一个更安全的选项是运行 `git stash --all` 来移除每一样东西并存放在栈中.      

如果只是想要看看它会做什么,可以使用 `--dry-run` 或 `-n` 选项来运行命令, 这意味着“做一次演习然后告诉你将要移除什么”.

默认情况下,`git clean` 命令只会移除没有忽略的未跟踪文件. 任何与 `.gitignore` 或其他忽略文件中的模式匹配的文件都不会被移除. 如果你也想要移除那些文件,例如为了做一次完全干净的构建而移除所有由构建生成的 `.o` 文件, 可以给 clean 命令增加一个 `-x` 选项.    
 
另一个小心处理过程的方式是使用 `-i` 或 “interactive” 标记来运行它.这将会以交互模式运行 clean 命令.     

>在一种奇怪的情况下,可能需要格外用力才能让 Git 清理你的工作目录. 如果你恰好在工作目录中复制或克隆了其他 Git 仓库（可能是子模块）,那么即便是 `git clean -fd` 都会拒绝删除这些目录.这种情况下,你需要加上第二个 `-f` 选项来强调.    

### 签署工作    

Git 虽然是密码级安全的,但它不是万无一失的. 如果你从因特网上的其他人那里拿取工作,并且想要验证提交是不是真正地来自于可信来源, Git 提供了几种通过 GPG 来签署和验证工作的方式.   

**GPG介绍**    

首先,在开始签名之前你需要先配置GPG并安装个人密钥.    

```console
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   2048R/0A46826A 2014-06-04
uid                  Scott Chacon (Git signing key) <schacon@gmail.com>
sub   2048R/874529A9 2014-06-04
```

如果你还没有安装一个密钥,可以使用 `gpg --gen-key` 生成一个.    

```console
$ gpg --gen-key
```

一旦你有一个可以签署的私钥,可以通过设置 Git 的 `user.signingkey` 选项来签署.     

```console
$ git config --global user.signingkey 0A46826A
```

现在 Git 默认使用你的密钥来签署标签与提交.    

**签署标签**    

如果已经设置好一个 GPG 私钥,可以使用它来签署新的标签. 所有需要做的只是使用 `-s` 代替 `-a` .      

如果在那个标签上运行 `git show`,会看到你的 GPG 签名附属在后面.   

**验证标签**    

要验证一个签署的标签,可以运行 `git tag -v <tag-name>`. 这个命令使用 GPG 来验证签名. 为了验证能正常工作,签署者的公钥需要在你的钥匙链中.     

**签署提交**    

在最新版本的Git中(v1.7.9及以上）,也可以签署个人提交. 如果相对于标签而言你对直接签署到提交更感兴趣的话,所有要做的只是增加一个 `-S` 到 `git commit` 命令.    

`git log` 也有一个 `--show-signature` 选项来查看及验证这些签名.     

在Git 1.8.3及以后的版本中,`git merge` 与 `git pull` 可以使用 `--verify-signatures` 选项来检查并拒绝没有携带可信GPG签名的提交.      

也可以给 `git merge` 命令附加 `-S` 选项来签署自己生成的合并提交. 下面的例子演示了验证将要合并的分支的每一个提交都是签名的并且签署最后生成的合并提交.      

**每个人必须签署**    

签署标签与提交很棒,但是如果决定在正常的工作流程中使用它,你必须确保团队中的每一个人都理解如何这样做. 如果没有,你将会花费大量时间帮助其他人找出并用签名的版本重写提交. 在采用签署成为标准工作流程的一部分前,确保你完全理解 GPG 及签署带来的好处.    

### 搜索    

无论仓库里的代码量有多少,你经常需要查找一个函数是在哪里调用或者定义的,或者显示一个方法的变更历史. Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交.    

#### Git Grep   

Git 提供了一个 `grep` 命令,你可以很方便地从提交历史、工作目录、甚至索引中查找一个字符串或者正则表达式.    

相比于一些常用的搜索命令比如 `grep` 和 `ack`,`git grep` 命令有一些的优点. 第一就是速度非常快,第二是你不仅仅可以可以搜索工作目录,还可以搜索任意的 Git 树.    

#### Git 日志搜索   

或许你不想知道某一项在哪里,而是想知道是什么时候存在或者引入的. `git log` 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交.      

例如,如果我们想找到 `ZLIB_BUF_MAX` 常量是什么时候引入的,我们可以使用 `-S` 选项 （在 Git 中俗称“鹤嘴锄（pickaxe）”选项）来显示新增和删除该字符串的提交.    
   
如果你希望得到更精确的结果,你可以使用 `-G` 选项来使用正则表达式搜索.    

**行日志搜索**    

行日志搜索是另一个相当高级并且有用的日志搜索功能. 在 `git log` 后加上 `-L` 选项即可调用,它可以展示代码中一行或者一个函数的历史.     

如果 Git 无法计算出如何匹配你代码中的函数或者方法,你可以提供一个正则表达式.你也可以提供单行或者一个范围的行号来获得相同的输出.    

### 重写历史    

许多时候,在使用 Git 时,你可能想要修订提交历史. Git 很棒的一点是它允许你在最后时刻做决定. 你可以在将暂存区内容提交前决定哪些文件进入提交,可以通过 `git stash` 来决定不与某些内容工作, 也可以重写已经发生的提交就像它们以另一种方式发生的一样. 这可能涉及改变提交的顺序,改变提交中的信息或修改文件,将提交压缩或是拆分, 或完全地移除提交——在将你的工作成果与他人共享之前.    

#### 修改最后一次提交   

修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个.你往往想做两件事情：简单地修改提交信息, 或者通过添加、移除或修改文件来更改提交实际的内容.   

使用 `git commit --amend` 修改最近一次提交.     

#### 修改多个提交信息    

为了修改在提交历史中较远的提交,必须使用更复杂的工具. Git 没有一个改变历史工具,但是可以使用变基工具来变基一系列提交,基于它们原来的 HEAD 而不是将其移动到另一个新的上面. 通过交互式变基工具,可以在任何想要修改的提交后停止,然后修改信息、添加文件或做任何想做的事情. 可以通过给 `git rebase` 增加 `-i` 选项来交互式地运行变基. 必须指定想要重写多久远的历史,这可以通过告诉命令将要变基到的提交来做到.     

如 `git rebase -i HEAD~3` 

**重新排序提交**   

也可以使用交互式变基来重新排序或完全移除提交.  

**压缩提交**  

通过交互式变基工具,也可以将一连串提交压缩成一个单独的提交.   

如果,指定 “squash” 而不是 “pick” 或 “edit”,Git 将应用两者的修改并合并提交信息在一起. 

**拆分提交**   

拆分一个提交会撤消这个提交,然后多次地部分地暂存与提交直到完成你所需次数的提交.  

>再次强调,这些改动了所有在列表中的提交的 SHA-1 校验和,所以要确保列表中的提交还没有推送到共享仓库中.   

#### 核武器级选项：filter-branch   

有另一个历史改写的选项,如果想要通过脚本的方式改写大量提交的话可以使用它——例如,全局修改你的邮箱地址或从每一个提交中移除一个文件.这个命令是 `filter-branch`,它可以改写历史中大量的提交,**除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作,否则你不应当使用它**. 然而,它可以很有用.    

> [!warning] 
> `git filter-branch` 有很多陷阱,不再推荐使用它来重写历史. 请考虑使用 `git-filter-repo`,它是一个 Python 脚本,相比大多数使用 `filter-branch` 的应用来说,它做得要更好.[它的文档和源码](https://github.com/newren/git-filter-repo) .

**从每一个提交中移除一个文件**    

`filter-branch` 是一个可能会用来擦洗整个提交历史的工具. 为了从整个提交历史中移除一个叫做 `passwords.txt` 的文件,可以使用 `--tree-filter` 选项给 `filter-branch` .      

```git
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
```

`--tree-filter` 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果.    

最后将可以看到 Git 重写树与提交然后移动分支指针. 通常一个好的想法是在一个测试分支中做这件事,然后当你决定最终结果是真正想要的,可以硬重置 `master` 分支. 为了让 `filter-branch` 在所有分支上运行,可以给命令传递 `--all` 选项.   

**使一个子目录作为新的根目录**   

假设已经从另一个源代码控制系统中导入,并且有几个没意义的子目录（`trunk`、`tags` 等等）. 如果想要让 `trunk` 子目录作为每一个提交的新的项目根目录,`filter-branch` 也可以帮助你那么做：

```console
$ git filter-branch --subdirectory-filter trunk HEAD
```

现在新项目根目录是 `trunk` 子目录了. Git 会自动移除所有不影响子目录的提交.    

**全局修改邮箱地址**   

另一个常见的情形是在你开始工作时忘记运行 `git config` 来设置你的名字与邮箱地址, 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址. 任何情形下,你也可以通过 `filter-branch` 来一次性修改多个提交中的邮箱地址. 需要小心的是只修改你自己的邮箱地址,所以你使用 `--commit-filter`：    

```console
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
```

这会遍历并重写每一个提交来包含你的新邮箱地址. 因为提交包含了它们父提交的 SHA-1 校验和,这个命令会修改你的历史中的每一个提交的 SHA-1 校验和, 而不仅仅只是那些匹配邮箱地址的提交.    

### 重置揭秘   

>在继续了解更专业的工具前,我们先探讨一下 Git 的 `reset` 和 `checkout` 命令. 在初遇的 Git 命令中,这两个是最让人困惑的.    

#### 三棵树   

理解 `reset` 和 `checkout` 的最简方法,就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树.   

>“树” 在我们这里的实际意思是 “文件的集合”,而不是指特定的数据结构. （在某些情况下索引看起来并不像一棵树,不过我们现在的目的是用简单的方式思考它.）   


| tree              | usage              |
| ----------------- | ------------------ |
| HEAD              | 上一次提交的快照,下一次提交的父节点 |
| Index             | 预期的下一次提交的快照        |
| Working Directory | 沙盒                 |
**HEAD**   

HEAD 是当前分支引用的指针,它总是指向该分支上的最后一次提交. 这表示 HEAD 将是下一次提交的父结点. 通常,理解 HEAD 的最简方式,就是将它看做该分支上的最后一次提交的快照.     

`git cat-file` 查看快照   

`git ls-tree` 显示出索引当前的样子    

**索引**   

索引是你的预期的下一次提交.我们也会将这个概念引用为Git的“暂存区”,这就是当你运行 `git commit` 时Git看起来的样子.    

Git 将上一次检出到工作目录中的所有文件填充到索引区,它们看起来就像最初被检出时的样子. 之后你会将其中一些文件替换为新版本,接着通过 `git commit` 将它们转换为树来用作新的提交.     

>确切来说,索引在技术上并非树结构,它其实是以扁平的清单实现的.不过对我们而言,把它当做树就够了.      

**工作目录(工作区)**   

另外两棵树以一种高效但并不直观的方式,将它们的内容存储在 `.git` 文件夹中. 工作目录会将它们解包为实际的文件以便编辑. 你可以把工作目录当做沙盒.在你将修改提交到暂存区并记录到历史之前,可以随意更改.    

#### 重置的作用    

**第一步：移动HEAD**   

`reset` 做的第一件事是移动 HEAD 的指向. 这与改变 HEAD 自身不同（`checkout` 所做的）；`reset` 移动 HEAD 指向的分支. 这意味着如果 HEAD 设置为 `master` 分支（例如,你正在 `master` 分支上）, 运行 `git reset 9e5e6a4` 将会使 `master` 指向 `9e5e6a4`.    

无论你调用了何种形式的带有一个提交的 `reset`,它首先都会尝试这样做. 使用 `reset --soft`,它将仅仅停在那儿.    

它本质上是撤销了上一次 `git commit` 命令.    

**第二步：更新索引(--mixed)**   

注意,如果你现在运行 `git status` 的话,就会看到新的 HEAD 和以绿色标出的它和索引之间的区别.     

接下来,`reset` 会用 HEAD 指向的当前快照的内容来更新索引.    

如果指定 `--mixed` 选项,`reset` 将会在这时停止. 这也是默认行为,所以如果没有指定任何选项（在本例中只是 `git reset HEAD~`）,这就是命令将会停止的地方.    

它依然会撤销上一次 `提交`,但还会 _取消暂存_ 所有的东西. 于是,我们回滚到了所有 `git add` 和 `git commit` 的命令执行之前.    

**第三步：更新工作目录(--hard)**   

`reset` 要做的第三件事情就是让工作目录看起来像索引. 如果使用 `--hard` 选项,它将会继续这一步.   

现在让我们回想一下刚才发生的事情. 你撤销了最后的提交、`git add` 和 `git commit` 命令以及工作目录中的所有工作.   

> [!warning] 
> 必须注意,`--hard` 标记是 `reset` 命令唯一的危险用法,它也是 Git 会真正地销毁数据的仅有的几个操作之一. 其他任何形式的 `reset` 调用都可以轻松撤消,但是 `--hard` 选项不能,因为它强制覆盖了工作目录中的文件. 在这种特殊情况下,我们的 Git 数据库中的一个提交内还留有该文件的最新修改版本, 我们可以通过 `reflog` 来找回它.但是若该文件还未提交,Git 仍会覆盖它从而导致无法恢复.   

#### 通过路径来重置    

你还可以给它提供一个作用路径. 若指定了一个路径,`reset` 将会跳过第1步,并且将它的作用范围限定为指定的文件或文件集合. 这样做自然有它的道理,因为HEAD只是一个指针,你无法让它同时指向两个提交中各自的一部分. 不过索引和工作目录可以部分更新,所以重置会继续进行第2、3步.     

`git reset <path>` 取消暂存文件    

我们可以不让 Git 从 HEAD 拉取数据,而是通过具体指定一个提交来拉取该文件的对应版本. 我们只需运行类似于 `git reset eb43bf <file>` 的命令即可.    

还有一点同 `git add` 一样,就是 `reset` 命令也可以接受一个 `--patch` 选项来一块一块地取消暂存的内容. 这样你就可以根据选择来取消暂存或恢复内容了.   

#### 压缩

利用 `git reset --soft <hashkey>` 移动到旧分支提交覆盖.

#### 检出

和 `reset` 一样,`checkout` 也操纵三棵树,不过它有一点不同,这取决于你是否传给该命令一个文件路径.    

**不带路径**

运行 `git checkout <branch>` 与运行 `git reset --hard <branch>` 非常相似,它会更新所有三棵树使其看起来像 `<branch>`,不过有两点重要的区别：
- 首先不同于 `reset --hard`,`checkout` 对工作目录是安全的,它会通过检查来确保不会将已更改的文件弄丢. 其实它还更聪明一些.**它会在工作目录中先试着简单合并一下**,这样所有**还未修改过的**文件都会被更新. 而 `reset --hard` 则会不做检查就全面地替换所有东西.
- 第二个重要的区别是 `checkout` 如何更新HEAD. `reset` 会移动HEAD分支的指向,而 `checkout` 只会移动HEAD自身来指向另一个分支.   

**带路径**    

运行 `checkout` 的另一种方式就是指定一个文件路径,这会像 `reset` 一样不会移动HEAD.      

它就像 `git reset <branch> file` 那样用该次提交中的那个文件来更新索引,但是它也会覆盖工作目录中对应的文件.如同 `git reset --hard <branch> <file>` .这样对工作目录并不安全,它也不会移动HEAD.    

此外,同 `git reset` 和 `git add` 一样,`checkout` 也接受一个 `--patch` 选项,允许你根据选择一块一块地恢复文件内容.    

### 高级合并    

**中断一次合并**    

可以用 `git merge --abort` 命令来简单地退出合并.      

它会尝试恢复到你运行合并前的状态. 但当运行命令前,在工作目录中有未储藏、未提交的修改时它不能完美处理,除此之外它都工作地很好.   

**忽略空白**      

如果你看到在一次合并中有大量关于空白的问题,你可以直接中止它并重做一次, 这次使用 `-Xignore-all-space` 或 `-Xignore-space-change` 选项. 第一个选项在比较行时完全忽略空白修改,第二个选项将一个空白符与多个连续的空白字符视作等价的.     

**手动文件再合并**      

合并时,会将合并分支与它们的共同祖先的修改在索引区(暂存)中进行存储,Stage 1是共同祖先版本,Stage 2是当前分支的版本,Stage 3是来自你将要合并入的版本.       

通过 `git show` 命令与一个特别的语法,你可以将冲突文件的这些版本释放出一份拷贝.如：     
`git show :1:<filename>`    

也可以使用 `ls-files -u` 底层命令来得到这些文件的Git blob对象实际的SHA-1值.         

然后通过手工修复这三个文件,使用鲜为人知的 `git merge-file` 命令来重新合并那个文件    
`git merge-file -p <file1> <file2> <file3> > <filefinal>`    

实际上,这比使用 `ignore-space-change` 选项要更好,因为在合并前真正地修复了空白修改而不是简单地忽略它们.     

要在合并前比较结果与在你的分支上的内容,可以运行 `git diff --ours` .       

想要查看合并的结果与他们那边有什么不同,可以运行 `git diff --theirs` .       

最终,你可以通过 `git diff --base` 来查看文件在两边是如何改动的,运行 `git clean` 清理额外文件.    

**检出冲突**    

利用 `git checkout --conflict` 命令重新检出文件并替换合并冲突标记.     

可以传递给 `--conflict` 参数 `diff3` 或 `merge(默认)` 选项. 如果传给它 `diff3` Git会使用一个略微不同版本的冲突标记：不仅仅只给你"ours"和“theirs"版本,同时也会有"base"版本在中间来给你更多的上下文.      
`git checkout --conflict=diff3 <filename>`     

**合并日志**    

使用 `git log` 的三点语法和 `--merge` 或 `-p` 选项来解决合并冲突.      

**组合式差异格式**     

使用 `git diff` 来解决合并冲突.     

**撤销合并**    

有两种方法:
- 修复引用    
- 还原提交,用 `git revert -m n HEAD` 还原提交, `-m n` 为第几个父提交.   

**其他类型的合并**      

默认情况下,当 Git 看到两个分支合并中的冲突时,它会将合并冲突标记添加到你的代码中并标记文件为冲突状态来让你解决.如果你希望Git简单地选择特定的一边并忽略另外一边而不是让你手动解决冲突,你可以传递给 `merge` 命令一个 `-Xours` 或 `-Xtheirs` 参数.   

**子树合并**     

子树合并的思想是你有两个项目,并且其中一个映射到另一个项目的一个子目录,或者反过来也行. 当你执行一个子树合并时,Git通常可以自动计算出其中一个是另外一个的子树从而实现正确的合并.    

这个是一个比较奇怪的概念.并不是仓库中的所有分支都是必须属于同一个项目的分支. 这并不常见,因为没啥用,但是却是在不同分支里包含两条完全不同提交历史的最简单的方法.    

我们可以在Git中执行 `git read-tree` 来实现.

接着,我们可以将这些变更合并回我们的 `master` 分支.使用 `--squash` 选项和使用 `-Xsubtree` 选项(它采用递归合并策略),都可以用来可以拉取变更并且预填充提交信息.(递归策略在这里是默认的)    

这给我们提供了一种类似子模块工作流的工作方式,我们可以在自己的仓库中保持一些和其他项目相关的分支,偶尔使用子树合并将它们合并到我们的项目中.      

另外一个有点奇怪的地方是,当你想查看 `rack` 子目录和 `rack_branch` 分支的差异—— 来确定你是否需要合并它们——你不能使用普通的 `diff` 命令.取而代之的是,你必须使用 `git diff-tree` 来和你的目标分支做比较.     

### Rerere    

`git rerere` 功能是一个隐藏的功能.正如它的名字“重用记录的解决方案(reuse recorded resolution)”所示,它允许你让Git记住解决一个快冲突的方法,这样下一次看到相同冲突时,Git可以为你自动地解决.      

要启用 `rerere` 功能,只需要运行以下配置选项即可：    
`git config --global rerere.enabled true`    

### 使用Git调试    

**文件标注**     

如果你在追踪代码中的一个 bug,并且想知道是什么时候以及为何会引入,文件标注通常是最好用的工具.它能显示任何文件中每行最后一次修改的提交记录.     

你可以使用 `git blame` 标注这个文件,查看哪一次提交引入了这行.    

`blame` 中的前缀 `^` 指出了该文件自第一次提交后从未修改的那些行.

另一件比较酷的事情是Git不会显式地记录文件的重命名.它会记录快照,然后在事后尝试计算出重命名的动作.    

这其中有一个很有意思的特性就是你可以让Git找出所有的代码移动.如果你在 `git blame` 后面加上一个 `-C`,Git会分析你正在标注的文件, 并且尝试找出文件中从别的地方复制过来的代码片段的原始出处.    

**二分查找**    

当你知道问题是在哪里引入的情况下文件标注可以帮助你查找问题. 如果你不知道哪里出了问题,并且自从上次可以正常运行到现在已经有数十个或者上百个提交, 这个时候你可以使用 `git bisect` 来帮助查找.      
1. 首先执行 `git bisect start` 来启动
2. 接着执行 `git bisect bad` 来告诉系统当前你所在的提交是有问题的
3. 然后你必须使用 `git bisect good <good_commit>` ,告诉 bisect 已知的最后一次正常状态是哪次提交
4. 当你完成这些操作之后,你应该执行 `git bisect reset` 重置你的 HEAD 指针到最开始的位置,否则你会停留在一个奇怪的状态

事实上,如果你有一个脚本在项目是正常的情况下返回0,在不正常的情况下返回非0,你可以使 `git bisect` 自动化这些操作. 首先,你设定好项目正常以及不正常所在提交的二分查找范围. 你可以通过 `bisect start` 命令的参数来设定这两个提交,第一个参数是项目不正常的提交,第二个参数是项目正常的提交.

### 子模块     

有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目. 也许是第三方库,或者你独立开发的,用于多个父项目的库. 现在问题来了：你想要把它们当做两个独立的项目,同时又想在一个项目中使用另一个.      

可以通过在 `git submodule add` 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块.      

### 打包      

Git 可以将它的数据“打包”到一个文件中.     

`git bundle` 命令会将 `git push` 命令所传输的所有内容打包成一个二进制文件.        

如果你希望这个仓库可以在别处被克隆,你应该像例子中那样增加一个 HEAD 引用.    

>如果你在打包时没有包含HEAD引用,你还需要在命令后指定一个 `-b master` 或者其他被引入的分支, 否则 Git 不知道应该检出哪一个分支.    

`verify` 参数进行验证.     

当你在没有合适的网络或者可共享仓库的情况下,`git bundle` 很适合用于共享或者网络类型的操作.

### 替换     

我们之前强调过,Git对象数据库中的对象是不可改变的, 然而Git提供了一种有趣的方式来用其他对象假装替换数据库中的Git对象.    

`replace` 命令可以让你在 Git 中指定某个对象并告诉 Git：“每次遇到这个 Git 对象时,假装它是其它对象”. 在你用一个不同的提交替换历史中的一个提交而不想以 `git filter-branch` 之类的方式重建完整的历史时,这会非常有用.      

### 凭证存储    

如果你使用的是SSH方式连接远端,并且设置了一个没有口令的密钥,这样就可以在不输入用户名和密码的情况下安全地传输数据. 然而,这对HTTP协议来说是不可能的 —— 每一个连接都是需要用户名和密码的. 这在使用双重认证的情况下会更麻烦,因为你需要输入一个随机生成并且毫无规律的token作为密码.     

Git 拥有一个凭证系统来处理这个事情,如：
- 默认所有都不缓存,每一次连接都会询问你的用户名和密码
- “cache” 模式会将凭证存放在内存中一段时间,密码永远不会被存储在磁盘中,并且在15分钟后从内存中清除
- “store” 模式会将凭证用明文的形式存放在磁盘中,并且永不过期
- 如果你使用的是 Mac,还有一种 “osxkeychain” 模式,它会将凭证缓存到你系统用户的钥匙串中,这种方式将凭证存放在磁盘中,并且永不过期,但是是被加密的,这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的
- 如果你使用的是 Windows,你可以安装一个叫做 “Git Credential Manager for Windows” 的辅助工具

你可以设置 Git 的配置来选择上述的一种方式如：     
`git config --global credential.helper cache`       

## Git内部原理     

从根本上来讲Git是一个**内容寻址文件系统**,并在此之上提供了一个版本控制系统.        

**.git  catalog**      

- config：包含项目特有的配置选项
- description：仅供Gitweb程序使用
- info：包含一个全局性排除文件,用以放置那些不希望被记录在 `.gitignore` 文件中的忽略模式
- hooks：包含客户端或服务端的钩子脚本
- HEAD：指向目前被检出的分支
- objects：存储所有数据内容
- refs：存储指向数据的提交对象的指针
- index：保存暂存区信息

### Git对象     

Git的核心部分是一个简单的键值对数据库,你可以向Git仓库插入任意类型的内容,它会返回一个唯一的键,通过该键可以在任一时刻再次取回该内容.          

**数据对象**     

可以通过 `git hash-object` 来将任意数据保存于 `.git/objects` ,并返回指向该数据对象的唯一的键.       

一旦你将内容存储在了对象数据库中,那么可以通过 `cat-file` 命令从Git那里取回数据.

**树对象**     

一个树对象包含了一条或多条树对象记录(tree entry),每条记录含有一个指向数据对象或者子树对象的SHA-1指针,以及相应的模式,类型,文件名信息.       

可以用 `git update-index` 创建一个暂存区.            

可以用 `git write-tree` 命令将暂存区内容写入一个树对象.        

可以通过 `git read-tree` 命令,把树对象读入暂存区.        

**提交对象**    

可以用 `git commit-tree` 来创建一个提交对象,为此需要指定一个树对象的SHA-1值,以及该提交的父提交对象.        

提交对象的格式     
- 指定一个顶层树对象
- 可能的父提交
- 作者/提交者信息
- 提交注释

**对象储存**      

向Git仓库提交的所有对象都会有个头部信息一并被保存.        

步骤为     
1. 识别出对象的类型作为开头来构造一个头部信息
2. 在头部的第一部分添加一个空格,随后是数据内容的字节数,最后是一个空字节
3. 将头部信息和原始数据拼接起来,并计算出这条新内容的SHA-1校验和
4. 通过zlib压缩
5. 将这条压缩的内容写入磁盘的某个对象

### Git引用     

可以用 `git update-ref` 来更加安全的更新某个引用.      

**HEAD引用**        

HEAD文件通常是一个符号引用,指向目前所在的分支.所谓符号引用,表示它是一个指向其他引用的指针.          

在某些情况下,HEAD文件可能会包含一个Git对象的SHA-1值 ,当你在检出一个标签,提交或远程分支,让你的仓库变成"分离HEAD"状态.        

可以用 `git symbolic-ref` 来查看,设置HEAD引用对应的值.       

>不能把符号引用设置为一个不符合引用规范的值.      

**标签引用**      

**标签对象**：
- 一个标签创建者信息
- 一个日期
- 一段注释信息
- 一个指针

>标签对象通常指向一个提交对象,而不是一个树对象.

用 `git update-ref` 也可以创建一个标签对象.      

**远程引用**     

如果你添加了一个远程版本库并对其执行过推送操作,Git会记录下最近一次推送操作时每一个分支所对应的值,并保存在 `refs/remotes` 目录下.        

远程引用和分支(位于 `refs/heads` 目录下的引用)之间最主要的区别在于,远程引用是只读的.虽然可以 `git checkout` 到某个远程引用,但是Git并不会将HEAD引用指向该远程引用.因此,你永远不能通过 `commit` 命令来更新远程引用.Git将这些远程引用作为记录远程服务器上各分支最后已知位置状态的书签来管理.        

### 包文件      

Git最初向磁盘中储存对象时所使用的格式被称为"松散(loose)"对象格式,但是,Git会是不是地将多个这些对象打包成一个称为”包文件“的二进制文件,以节省空间和提升效率.当版本库中有太多的松散对象,或者你手动执行 `git gc` 命令,或者你向远程服务器执行推送时,Git都会这样做.要看到打包过程,你可以手动执行 `git gc` 命令让Git对对象进行打包.       

>打包会将提交记录里引用的对象打包,生成包文件和一个索引.未被打包的称为悬空(dangling).  

包文件包含了从文件系统中移除的所有对象的内容,索引文件包含了包文件的偏移信息.            

通过 `git verify-pack` 命令可以查看已打包的内容.      

### 引用规范       

添加一个远程仓库后,会在 `.git/config` 文件中添加一个小节,并在其中指定远程版本库的名称,URL和一个用于获取操作的**引用规范**.      

**引用规范的格式**：     
- 一个可选的 `+` 号,告诉Git即使在不能快进的情况下也要(强制)更新引用
- 紧随其后的 `<src>:<dst>` ,其中的 `<src>` 是一个模式,代表远程版本库中的引用, `<dst>` 是本地跟踪的远程引用的位置

默认情况下,引用规范 `git remote add origin` 命令自动生成,Git获取服务器中 `refs/heads/` 下面的所有引用,并将它写入到本地的 `refs/remotes/origin/` 中.           

将 `<src>` 留空,可以删除引用.

###  传输协议     

Git可以通过两种主要的方式在版本库之间传输数据：      
- 哑(dumb)协议
- 智能(smart)协议    

**哑协议**     

这个协议之所以被称为“哑”协议,是因为在传输过程中,服务端不需要有针对 Git 特有的代码;抓取过程是一系列HTTP的 `GET` 请求，这种情况下,客户端可以推断出服务端Git仓库的布局.        

>现在已经很少使用哑协议了.使用哑协议的版本库很难保证安全性和私有化,所以大多数Git服务器宿主(包括云端和本地)都会拒绝使用它.一般情况下都建议使用智能协议,我们会在后面进行介绍.      

**智能协议**     

哑协议虽然很简单但效率略低,且它不能从客户端向服务端发送数据.智能协议是更常用的传送数据的方法,但它需要在服务端运行一个进程,而这也是Git的智能之处——它可以读取本地数据,理解客户端有什么和需要什么,并为它生成合适的包文件.**总共有两组进程用于传输数据,它们分别负责上传和下载数据**.

**上传数据**      

为了上传数据至远端,Git使用 `send-pack(客户端)` 和 `receive-pack(服务器)` 进程.      

**下载数据**    

当下载数据时, `fetch-pack(客户端)` 和 `upload-pack(服务器)` 进程就起作用了.       

### 维护与数据恢复    

**维护**     

Git会不定时地自动运行一个叫做 `auto gc` 的命令.大多数时候,这个命令并不会产生效果.然而,如果有太多松散对象(不在包文件中的对象)或者太多包文件,Git会运行一个完整的 `git gc` 命令.“gc”代表垃圾回收,这个命令会做以下事情：收集所有松散对象并将它们放置到包文件中,将多个包文件合并为一个大的包文件,移除与任何提交都不相关的陈旧对象.        

>大约需要 7000 个以上的松散对象或超过 50 个的包文件才能让 Git 启动一次真正的 gc 命令.可以通过修改 `gc.auto` 与 `gc.autopacklimit` 的设置来改动这些数值.    

`gc` 将会做的另一件事是打包你的引用到一个单独的文件. 打包到 `.git/packed-refs` 中.

>这个文件中如果有 `^` 开头,表示它上一行的标签是附注标签,所在的那一行是附注标签指向的那个提交.

**数据恢复**    

1. 使用引用日志或 `git log -g` 来找回之前的提交
2. 使用 `git fsck` 工具,加 `-full` 参数会显示出所有没有被其他对象指向的对象

**移除对象**      

> [!warning]
> **这个操作对提交历史的修改是破坏性的**.      
> 如果你在导入仓库后,在任何人开始基于这些提交工作前执行这个操作,那么将不会有任何问题——否则,你必须通知所有的贡献者他们需要将他们的成果变基到你的新提交上.       

1. 查看文件大小,以便可以找到要删除的文件,相关命令 `git gc,git verify-pack,git rev-list` 
2. 使用 `filter-branch` 删除历史中的文件,使用 `--index-filter` 参数,使用 `git rm --cached` 命令来移除文件,而不是 `rm` ,因为需要从索引中移除,而不是磁盘,还有个原因是速度——Git在运行过滤器时不会检出每个修订版本到磁盘,所有这个过程非常快
3. 移除对这个文件的引用以及任何包含指向那些旧提交的指针的文件
4. 这个大文件其实还在松散对象中,若真的想要删除它,可以通过 `--expire` 选项的 `git prune` 命令来完全移除

### 环境变量     

Git总是在一个 `bash` shell中运行,并借助一些shell环境变量来决定它的运行方式.     

**全局行为**    

`GIT_EXEC_PATH` : 决定Git到哪找它的子程序.     
`PREFIX` ：配置文件路径.     
`GIT_CONFIG_NOSYSTEM` : 禁用系统级别的配置文件.    
`GIT_PAGER` ：控制在命令行显示多页输出的程序.      
`GIT_EDITOR` ：Git的文本编辑器.       

**版本库位置**     

`GIT_DIR` ： `.git` 目录的位置.      
`GIT_CEILING_DIRECTORIES` ：控制查找 `.git` 目录的行为.      
`GIT_WORK_TREE` ：非空版本库的工作目录的根路径.      
`GIT_INDEX_FILE` ：索引文件的路径.      
`GIT_OBJECT_DIRECTORY` ：用来指定 `.git/objects` 目录的位置.      
`GIT_ALTERNATE_OBJECT_DIRECTORIES` ：一个冒号分割的列表,用来告述Git到哪里去找不在 `GIT_OBJECT_DIRECTORY` 目录中的对象.         

**路径规则**         

`GIT_GLOB_PATHSPECS/GIT_NOGLOB_PATHSPECS` ：控制通配符在路径规则中的默认行为.      
`GIT_LITERAL_PATHSPECS` ：禁用上面两种行为.      
`GIT_ICASE_PATHSPECS` ：让所有路径规范忽略大小写.     

**提交**     

`GIT_AUTHOR_NAME` ：是"author"字段的名字.     
`GIT_AUTHOR_EMAIL` ：是"author"字段的邮件.     
`GIT_AUTHOR_DATE` ：是"author"字段的时间戳.      
`GIT_COMMITTER_NAME` ：是"committer"字段的名字.      
`GIT_COMMITTER_EMAIL` ：是"committer"字段的邮件.     
`GIT_COMMITTER_DATE` ：是"committer"字段的时间戳.      

**网络**     

`GIT_CURL_VERBOSE` ：告述Git显示所有由那个库产生的消息.       
`GIT_SSL_NO_VERIFY` ：告述Git不用验证SSL证书.      
`GIT_HTTP_LOW_SPEED_LIMIT` ：最低传输速率.      
`GIT_HTTP_LOW_SPEED_TIME` ：允许工作在低于最低传输速率的持续时间.      
`GIT_HTTP_USER_AGENT` ：设置Git在通过HTTP通讯时用到的user-agent.         

**比较和合并**     

`GIT_DIFF_OPTS` ：用来控制 `git diff` 命令中显示的内容行数.    
`GIT_EXTERNAL_DIFF` ：用来覆盖 `diff.external` 配置的值.       
`GIT_DIFF_PATH_COUNTER/GIT_DIFF_PATH_TOTAL` ：对于 `GIT_EXTERNAL_DIFF` 或 `diff.external` 指定的程序有用.前者表示在一系列文件中哪个是被比较的,后者表示每批文件的总数.           
`GIT_MERGE_VERBOSITY` ：控制递归合并策略的输出.       

**调试**     

`GIT_TRACE` ：控制常规跟踪,并不适用特殊情况.     
`GIT_TRACE_PACK_ACCESS` ：控制访问打包文件的跟踪信息.     
`GIT_TRACE_PACKET` ：打开网络操作包级别的跟踪信息.      
`GIT_TRACE_PERFORMANCE` ：控制性能数据的日志打印.     
`GIT_TRACE_SETUP` ：显示Git发现的关于版本库和交互环境的信息.      

**其他**     

`GIT_SSH` ：Git连接SSH主机时会用指定的程序代替ssh.       
`GIT_ASKPASS` ：覆盖了 `core.askpass` 配置.     
`GIT_NAMESPACE` ：控制有命令空间的引用的访问,与 `--namespace` 标志是相同.     
`GIT_FLUSH` ：强制Git在向标准输出增量写入时使用没有缓存的I/O.      
`GIT_REFLOG_ACTION` ：让你可以指定描述性的文字写到reflog中.    

## 命令
### 基础命令  

- `git config --global user.name <username>` 刚安装时使用,进行用户签名
- `git config --global user.email <useremail>` 刚安装时使用,进行用户签名
- `git config --global core.editor <editor>` 配置文本编辑器
- `git init` 初始化本地仓库   
- `git status` 查看本地库状态  
- `git show` 查看目标信息
- `git add <filename>` 添加到暂存区  
- `git commit <filename>` 提交到本地库
- `git help <command>` 获取git命令的帮助信息
- `git tag` 创建标签  
- `git diff <filename>` 显示与暂存区文件的差异  
- `git diff <revision> <filename>` 显示某个文件两个版本之间的差异  

### 查看日志命令

- `git log` 显示历史日志  
  - `git log --all --graph --decorate` 可视化历史记录（有向无环图）  
- `git reflog` 查看reflog信息  

### 分支和合并

- `git branch` 显示分支  
- `git branch <name>` 创建分支  
- `git merge <revision>` 合并到当前分支  
- `git mergetool` 使用工具来处理冲突  
- `git rebase` 将一系列补丁变基为新的基线  
- `git checkout <revision>` 更新HEAD和目前的分支  
  - `git checkout -b <name>` 创建并切换分支
- `git reset --hard <revision>` 重置HEAD指针到指定的提交  
- `git rebase` 变基

### 远端操作  

- `git remote` 列出远端  
- `git remote add <name> <url>` 添加一个远端  
- `git push <remote> <local branch>:<remote branch>` 将对象传送至远端并更新远端引用  
- `git branch --set-upstream-to <remote>/<remote branch>` 创建本地和远端分支的关联关系  
- `git fetch` 从远端获取对象/索引  
- `git pull` 相当于git fetch;git merge  
- `git clone <url>` 从远端下载仓库  

### 撤销

- `git commit --amend` 编辑提交的内容或信息  
- `git reset HEAD <filename>` 恢复暂存文件  
- `git checkout -- <filename>` 丢弃修改  
- `git restore` git2.32 版本后取代 git reset 进行许多撤销操作  

### 高级操作  

- `git config` Git 是一个高度可定制的工具  
- `git clone --depth=1` 浅克隆(shallow clone),不包括完整的版本历史信息  
- `git add -p` 交互式暂存  
- `git rebase -i` 交互式变基  
- `git blame` 查看最后修改某行的人  
- `git stash` 暂时移除工作目录下的修改内容  
- `git bisect` 通过二分查找搜索历史记录  
- `.gitignore` 指定故意不追踪的文件(不是命令,是dot file)  
- `git format-patch` 生成补丁
- `git am/apply` 应用补丁
- `git cherry-pick <hashkey>` 拣选命令
- `git rerere` 重用已记录的冲突解决方案
- `git describe` 生成一个构建号
- `git archive` 创建一个最新快照归档
- `git shortlog` 制作简报

## 获取帮助  

有三种方式可以找到Git命令的综合手册：
- `$ git help <verb>`  
- `$ git <verb> --help`
- `$ man git-<verb>`

你可以尝试在 [Freenode IRC](https://freenode.net/) 服务器上的 `#git` 或 `#github` 频道寻求帮助.  

此外,如果你不需要全面的手册,只需要可用选项的快速参考,那么可以用 `-h` 选项获得更简明的手册

## QA  

> [!faq] **1. `log` 与 `reflog` 的区别**  
>`log` 显示当前HEAD及其祖先.也就是说,它会打印HEAD指向的提交,然后是其父级、其父级的父级....它会通过递归查找每个提交的父级来遍历存储库的祖先.`reflog` 不会遍历HEAD的祖先,它是HEAD指向的提交的有序列表,是存储库的撤销历史记录,它不是存储库本身的一部分（它与提交本身分开存储）,也不包含在推送,提取或克隆中,它纯粹是本地的.  
>另外：了解 `reflog` 意味着一旦提交,就不会真正丢失在存储库里的数据.如果不小心重置为较旧的版本,或错误的重新设置了基数,或任何其他直观地“删除”操作,都可以使用 `reflog` 查看之前的位置,然后通过 `git reset --hard <hashkey>` 返回该引用以恢复之前的状态.引用不止意味着提交,也意味着背后整个的历史记录,但reflog条目并不会永久保留,但错误至少在两周内会是安全的.  

> [!question] **2. `checkout` 与 `reset --hard` 的区别**  
>前者只去更新HEAD指针,列如,在使用时,从主线切换到其他地方,只有HEAD指针去移动,而后者,则将主线指针也一并带了过来,为此可能会出现丢失数据的情况,就要用到 `reflog` 了.  

> [!faq] **3. `checkout -- <filename>` 与 `reset HEAD <filename>` 区别**  
>前者如果文件没有添加到缓存区,那么将最近一次提交的版本替换工作目录中的文件,丢弃本地的修改,后者仅将文件从暂存区中移除.  

> [!question] ORIG_HEAD是什么
> 是上次执行 `git reset/pull/merge` 命令前指针所在的位置.




