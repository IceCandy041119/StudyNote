
## 名称和环境  

编程语言的一个关键方面是它提供使用名称来引用计算对象的方式。如果一个值被赋予了一个名称，我们说这个名称绑定到了这个值。   

>在Python的解释器中，如果你单单给出一个名称，Python解释器会输出一个对应的值给你。  

在Python中，我们可以使用赋值语句来建立新的绑定，该语句包含等号左边的名称和等号右边的值：
```python
identifier = <expressive>
```
名称也通过导入语句绑定：  
```python
from math import pi
```

等号（=）在Python（以及许多其他语言）中被称为赋值运算符。赋值是我们最简单的抽象手段，因为它允许我们使用简单的名称来引用复合运算的结果。复杂程序是通过逐步构建越来越复杂的计算对象来构建的。  

将名称绑定到值并在以后通过名称检索这些值意味着解释器必须维护某种形式的内存，以跟踪名称、值和绑定。这种内存被称为**环境**。  

**名称也可以绑定到函数**。例如，名称max绑定到我们一直在使用的max函数。与数字不同，函数很难以文本形式表示，因此当Python被要求描述一个函数时，它会打印一个标识性描述：  
```python
>>> max
<build-in function max>
```

我们可以使用赋值语句给现有函数赋予新的名称。 
```python
>>>f=max
>>>f
<build-in function max>
```

并且连续的赋值语句可以将一个名称重新绑定到新值，相当于程序顺序执行，最后的赋值覆盖先前的赋值。  

在Python中，名称通常被称为变量名或变量，因为它们可以在程序执行过程中绑定到不同的值。当一个名称通过赋值绑定到新值时，它就不再绑定到任何之前的值。甚至可以将内置名称绑定到新值。  

在执行赋值语句时，Python会在更改左侧名称的绑定之前，先评估等号右侧的表达式。因此，可以在右侧表达式中引用一个名称，即使它是赋值语句要绑定的名称。  
```python
a = a + 1
```

我们在一个语句中也可以为多个名称赋多个值，其中=左边的名称和=右边的表达式之间用逗号分隔。  
```python
a, b = 1, 2
```

使用多重赋值时，等号右侧的所有表达式在将任何名称左侧绑定到这些值之前都会被评估。根据此规则，可以在单个语句中执行交换两个名称所绑定值的操作。  

```python 
>>> x, y = 3, 4.5
>>> y, x = x, y
>>> x
4.5
>>> y
3
```


更改一个名称的值不会影响其他名称。比如说你a = b + 1，假设之前的b为1，你得到了a=2，但在这之后，你把b改为2，a的值并不会改变。你可以通过将a绑定一个函数，这样每次输入a，即会重新评估一下函数对应的表达式。  

一个表达式评估的环境由一系列框架组成，这些框架以框的形式表示。每个框架包含一系列绑定，每个绑定将一个名称与其对应的值关联起来，存在一个单独的全局框架中。

赋值和导入语句将条目添加到当前环境的第一个框架中。

应用用户定义的函数会引入第二个局部框架，该框架仅对该函数可访问。要将用户定义的函数应用于某些参数：
- 绑定参数到函数形式参数的名称，在一个局部框架中
- 执行以该帧开始的环境的函数体

对函数体评估的环境由两个框架组成：
- 首先是包含形式参数绑定的局部框架
- 然后是包含其他内容的全局框架
- 每个函数实例应用在它自己的独立框架

环境中的帧顺序会影响通过表达式查找名称时返回的值：
- 名称评估：
	- 一个名称评估为在当前环境中找到该名称的最早帧中于该名称绑定的值

## 基本语法

### 语句与表达式

Python代码有**表达式**和**语句**组成。广义上，计算机程序由指令组成，用于：
1. 计算某个值
2. 执行某个动作
**语句**通常用于描述动作。当Python解释器执行一个语句时，它执行相应的动作。    
**表达式**通常用于描述计算。当Python解释器评估一个表达式时，它计算该表达式的值。    

```python
expressive := value  
			  | value operator value
			  | function #such as add(a,b) mul(a,b) etc...
			  | call expression #嵌套表达式 add(mul(a,b),c)
```

>Python虽然支持使用中缀表示法的常见数学运算符，但任何运算符都可以表示为一个具有名称的函数。 

为了评估一个调用表达式，Python将执行以下操作：  
1. 评估操作符和操作数子表达式
2. 将操作符子表达式的值作为函数应用于操作子表达式的值作为参数

第一步规定了，为了完成调用表示的评估过程，我们首先必须评估其他表达式。因此，评估程序在本质上具有递归性。

> [!note] [BNF](http://en.wikipedia.org/wiki/Backus–Naur_Form)
根据上述BNF定义, 一种解决方案已经逐渐成型了: 既然长表达式是由短表达式构成的, 我们就先对短表达式求值, 然后再对长表达式求值. 这种十分自然的解决方案就是[分治法](http://en.wikipedia.org/wiki/Divide_and_conquer_algorithms)的应用, 就算你没听过这个高大上的名词, 也不难理解这种思路. 而要实现这种解决方案, 递归是你的不二选择.

>注意环境在确定表达式中的符号含义方面的重要作用。在Python中，如果不指定任何关于环境的信息,那么谈论表达式的值是没有意义的，该环境将为名称x（甚至名称add）提供含义。   
>环境提供了评估发生的环境，这在理解程序执行方面起着重要作用。   

此评估程序不足以评估所有Python代码，仅限于调用表达式、数字和名称。例如，它不处理赋值语句。执行没有返回值也不会对某些参数评估函数，因为赋值的目的是将名称绑定到值。一般来说，语句不是评估而是执行；它们不会产生值，而是做出一些改变。每种表达式或语句都有其自己的评估或执行程序。   

一个严格的注解：当我们说“一个数字评估为数字”时，我们实际上是指Python解释器将数字评估为数字。是解释器赋予了编程语言意义。鉴于解释器是一个始终表现一致的固定程序，我们可以说数字（和表达式）本身在Python程序上下文中评估为值。

>Python对这数字有保护，你不能将一个数字赋值为另一个数字。   

一般来说，Python代码是一系列语句，简单语句是单行且不以冒号结尾的语句。复合语句之所以被称为复合语句，是因为它由其他语句组成。复合语句通常跨越多行，并以一个以冒号结尾的单行标题开始，用于标识语句类型。**一个标题和缩进的语句序列统称为子句**。**复合语句由一个或多个子句组成**。
```python
<header>:
	<statement>
	<statement>
	...
<separating header>:
	<statement>
	<statement>
	...
```


>在缩进一个代码块时，所以行必须以相同的方式缩进相同数量（使用空格，而不是制表符）。任何缩进变化都会导致错误。

赋值语句的效果是将一个名称绑定到当前环境的第一帧中的值。因此，函数体内的赋值语句无法影响全局帧。



### 函数

函数封装了操作数据的逻辑。  

Python定义了大量的函数，但并不是所有函数的名字都默认可用，Python将所知的函数和其他量组织成模块，这些模块共同构成了Python库。要使用这些元素，需要导入它们。例如，math模块提供了各种熟悉的数学函数：
```python
from math import sqrt # 或者 add , mul etc...
```
一个导入语句指定了一个模块的名称，然后列出要导入的该模块的命名属性。一旦导入一个函数，就可以多次调用它。   

>使用这些运算符函数（如，add）和运算符符号本身（如，+）之间没有区别。   

>[Python3库文档](https://docs.python.org/3/library/index.html)列出了每个模块定义的函数。    

#### 纯函数和非纯函数

在这段文本中，我们将区分两种类型的函数：
- **纯函数**：函数有一些输入（它们的参数）并返回一些输出（应用它们的结果）。内置函数可以被描绘成一个小的机器，它接受输入并产生输出。
	- **性质**：应用它们只会返回一个值，不会产生其他影响。此外，纯函数在用相同的参数调用两次时必须始终返回相同的值。
- **非纯函数**：除了返回一个值之外，应用非纯函数还可以产生副作用，这会改变解释器或计算机的状态。一个常见的副作用是使用print函数生成额外的输出，超出返回值。


纯函数受到限制，它们不能有副作用或随时间改变行为。施加这些限制带来显著的好处。首先，纯函数可以更可靠地组合成复合调用表达式。   

其次，纯函数通常更容易测试。一组参数将始终导致相同的返回值，这可以与预期的返回值进行比较。    

#### 函数定义

**定义一个函数**：函数定义由一个表示\<name\>的`def`语句和一个以逗号分隔被称为\<formal paramenters\>的列表组成，然后是一个被称为**函数体**的reurn语句，该语句指定了函数的\<return expression\>，这是一个在函数被调用时评估的表达式。
```python
def <name>(<formal parameters>):
	return <return expression>
```
在python中，第二行开始必须缩进，大多数程序员缩进4个空格。返回表达式不会被立即评估，它会作为函数的一部分被存储，并且只在嘴中被调用时才评估。

在**函数体**中，我们可以使用其他函数。用户定义的函数与内置函数的使用方式完全相同。  

函数实现的一个细节，实现者对函数形式参数命名的选择不应该影响函数的行为。这一原则对编程语言有重要影响。最简单的后果是，函数的参数名称必须局限于函数体内部。我们说一个局部名称的作用域仅限于定义它的用户自定义函数的主体。当一个名称不可再访问时，它就超出了作用域。

>[python社区代码规范](https://peps.python.org/pep-0008/)

#### 函数抽象

函数定义应该能过抑制细节。函数的使用者可能并没有自己编写函数，而是从其他程序员哪里作为黑盒获得的。程序员在使用函数时不需要知道函数是如何使用的。

#### 运算符

数学运算符为我们提供了组合方法的第一例，但我们尚未定义包含这些运算符的表达式评估程序。

python表达式使用中缀表达式各自有其评估过程，但你可以看作是调用表达式的简写。

中缀表达法可以嵌套，就像调用表达式一样，python应用正常的数学运算符优先级规则。这些规则规定了如何解释包含多个运算符的复合表达式。

python 提供了两个中缀运算符：
- /
	- 正常除法，结果是浮点数或者小数
- //
	- 将结果向下取整

这两个运算符是`truediv`和`floordiv`函数的简写。

#### 函数设计  

- 每个函数应该恰好有一个任务，这个任务应该可以通过一个简短的名字识别，并且可以用一行文本来描述。执行多个任务的函数应该被分成多个函数
- _Don't repeat yourself_ 是软件工程的一个核心原则。所谓的DRY原则指出，不应有多个代码片段描述冗余逻辑。相反，应该将该逻辑实现一次，赋予一个名称，并在多个地方使用。如果你发现自己正在复制粘贴一段代码，那么你可能发现了一个进行功能抽象的机会。
- 函数应该被一般性定义，Square并不是Python库中的特殊函数，恰恰是应为它是pow函数的一个特列，pow函数可以将数字提升到任意次幂

##### Documentation

函数定义通常包括描述函数的文档，称为文档字符串(docstring)，它必须于函数体缩进一致。文档字符串通常使用三种引号。第一行描述函数的功能，以下行可以描述参数并阐明函数的行为。

当你以函数名称作为参数调用帮助时，你会看到它的文档字符床，在编写Python程序时，出来最简单的函数外，都要包含文档字符串。Python文档包括文档字符串指南，这些指南在不同Python项目中保持一致。

注释，Python中的注释可以附加在\#符号之后的行尾。

##### Default Argument Values

具有许多参数的函数在调用时可能显得笨拙，且难以阅读。

在Python中，我们可以为函数的参数提供默认值。在调用该函数时，具有默认值的参数是可选的。如果没有提供，则默认值将绑定到形式参数名。
```python
def sum(x, y=2):
	return x + y
```

在def语句的头部，等号不执行赋值操作，而是表示在调用函数时使用的默认值。一些永远不会改变的值，可以在函数体内或者全局框架中绑定

#### 测试

测试一个函数是指验证该函数的行为是否符合预期。  

测试时一种系统性地执行这种验证的机制，测试通常采取另一种函数的形式，其中包含对被测试函数的一个或多个样本调用。然后，返回值将与预期结果进行验证。与大多数旨在通用的函数不同，测试涉及选择和验证具有特定参数的调用。测试还充当文档：它们演示了如何调用函数以及适当的参数值。

##### assert

`assert`，程序员使用`assert`来验证期望，例如测试函数的输出。断言语句在布尔上下文中有一个表达式，后跟一个引号中的文本行，如果表达式被评估为假值，则会显示该文本。

如果被断言表达式评估为真值时，执行断言语句没有效果。当它时假值，断言会导致错误并停止执行。

在文件中编写Python代码时，通常不是直接写入解释器，而时将测试代码写在同一文件或响铃文件中，文件名以_test.py结尾。

##### Doctests

Python提供了一种方便的方法，可以直接在函数的文档字符串中放置简单的测试。文档字符串的第一行，应包含函数的一行描述，后面跟一个空行，接下来可以时对参数和行为的具体描述。此外，文档字符串还可以包括一个调用函数的示例交互会话：
```python
>>> def fun():
		""" print hello
		>>> fun()
		hello
		"""
		print('hello')
```

然后可以通过[doctest module](https://docs.python.org/3/library/doctest.html)验证交互。

在python3命令行测试文档字符串需要调用`run_docstring_examples` 函数，具体看文档吧

在文件中编写Python时，可以通过使用doctest命令行选项启动Python来运行文件中的所有doctests：
`python3 -m doctest <python_source_file>`

有效的测试关键在于实现新功能后立即编写（并运行）测试。在实施之前编写一些测试也是良好的实践，以便在心中有一些示例输入输出。应用单个函数的测试称为单元测试。彻底的单元测试是良好程序设计的标识。

### 控制语句

#### 布尔

##### 布尔上下文

条件块标题语句中的表达式被称为处于布尔上下文中：它们的真值对控制流程很重要，但除此之外，它们的值不会被赋值或返回。Python中包含几个假值，包括0，None和布尔值False。所以其他数字是真值。  

##### 布尔值 

Python有两个布尔值，分别称为True和False。布尔值代表逻辑表示式中的真值。内置的比较操作符：
- >
- <
- >=
- <=
- ==
- !=

##### 布尔运算符  

Python还内置了三个基本逻辑运算符：
- and
- or
- not

逻辑表示有相应的评估程序，这些程序利用了这样一个事实：有时可以不评估逻辑表达式的所有子表达式就能确定其真值，这一特性称为**短路**。  

评估\<left\> and \<right\>:
1. 评估子表达式\<left\>
2. 如果结果是假值v，则表达式评估为v
3. 否则，表达式评估为子表达式\<right\>的值

\<left\>  or \<right\>
1. 评估子表达式\<left\>
2. 如果结果是真值v，则表达式结果评估为v
3. 否则，表达式评估为\<right\>的值

not \<exp>
1. 如果表达式的结果是false，则值为True,反之为False


#### 条件语句

```python
if <expression>:
	<suite>
elif <expression>:
	<suite>
else:
	<suite>
```

执行条件语句时，每个子句按顺序考虑。执行条件子句的计算过程如下：
1. 评估头部表达式的值
2. 如果它是真值，则执行代码块。然后跳过条件语句中所以后续的子句

如果执行到else子句，则执行其后的代码块。  

#### 循环语句

while 子句包含一个头部表达式，后跟一个代码块：
```python
while <expression>
	<suite>
```

执行While子句：
1. 评估头部表达式的值
2. 如果是真值，则执行表达式，然后返回步骤1，在步骤2中，在再次评估头部表达式之前，while子句的整个代码块都会被执行
